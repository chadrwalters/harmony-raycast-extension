This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-18T20:49:57.291Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docs/
  architecture.md
local-docs/
  harmony-raycast.md
src/
  components/
    DeviceList.tsx
    ErrorBoundary.tsx
    FeedbackState.tsx
    HarmonyCommand.tsx
  features/
    control/
      types/
        harmony.ts
  hooks/
    useHarmony.ts
  services/
    harmony/
      commandQueue.ts
      harmonyClient.ts
      harmonyManager.ts
      harmonyState.ts
    errorHandler.ts
    localStorage.ts
    logger.ts
    secure-storage.ts
    session-manager.ts
  types/
    components.ts
    errors.ts
    harmony.ts
    logging.ts
    preferences.ts
    state.ts
    websocket.ts
  ui/
    toast-manager.ts
  utils/
    validation.ts
  control.tsx
.eslintrc.json
.gitignore
.prettierrc
CHANGELOG.md
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/architecture.md">
# Harmony Raycast Extension: Technical Architecture

This document provides a technical overview of the Harmony Raycast Extension's architecture and design. It covers the project's structure, key modules, and the relationships between them, helping anyone—including large language models—quickly understand how the application works.

## Overview

The Harmony Raycast Extension integrates with Logitech Harmony Hubs to:
* Discover Harmony Hubs on a local network
* Connect to a selected hub
* Retrieve and display devices and activities
* Send commands (e.g., power, volume) to devices
* Start/stop activities on the hub

It uses React (and React hooks) to manage the UI within Raycast, and it organizes functionality into logical layers:
1. UI Components: React-based screens and lists displayed in Raycast
2. Business Logic Hooks: Custom hooks (notably useHarmony) for hub discovery, connection, caching, and error handling
3. Services: Classes and modules that handle Harmony Hub networking, caching, logging, secure storage, and session management
4. Types: A set of TypeScript interfaces, enums, and error classes describing domain objects and categorizing errors

## Project Structure

Below is a high-level breakdown of the key directories and files:

```
/assets
├── command-icon.png
└── extension-icon.png

/docs
/metadata
├── harmony-control-1.png
├── harmony-control-2.png
├── harmony-control-3.png
└── harmony-control-4.png

/src
├── components
├── features
├── hooks
├── services
├── types
├── ui
├── utils
└── control.tsx

.eslintrc.json
.Plan
.prettierrc
package.json
README.md
tsconfig.json
```

### /assets
Contains image assets such as icons displayed in Raycast.

### /docs and /metadata
* `/docs`: Placeholder for documentation files (if any)
* `/metadata`: Contains image files used in readme-like metadata or for visual references in the extension

### /src
The main source directory containing all logic, UI components, and service files. The key subfolders are:

#### 1. /components
Reusable React components. Notable files:
* `DeviceList.tsx`: Renders a searchable list of devices and their commands. Uses useHarmony to fetch device data, filter commands, and send commands
* `FeedbackState.tsx`: A UI component for displaying loading states, error states, or empty states. It also includes predefined states for loading and errors
* `ErrorBoundary.tsx`: Standard React error boundary component to catch and display errors gracefully
* `HarmonyCommand.tsx`: A core component providing a unified interface for controlling devices and activities. It sets up various views (hubs list, devices list, activities list) with searching and filtering

#### 2. /features/control
Specialized domain logic for controlling the Harmony Hub (types, etc.):
* `types/harmony.ts`: Domain-specific types for hubs, devices, commands, and activities

#### 3. /hooks
Contains custom React hooks, most notably:
* `useHarmony.ts`: Central hook managing discovery, connection, state, and commands for the Harmony Hubs. Internally uses a singleton HarmonyManager and HarmonyClient to handle lower-level interactions

#### 4. /services
Encapsulates core business logic that sits apart from React components. Key files:
* `harmony/harmonyManager.ts`: Orchestrates discovery of Harmony Hubs on the local network, caching results, and providing a centralized manager for discovered hubs
* `harmony/harmonyClient.ts`: A client for interacting with a specific Harmony Hub (fetching devices/activities, sending commands, etc.)
* `harmony/commandQueue.ts`: Queues and processes commands for concurrency control and retries
* `harmony/harmonyMachine.ts`: An XState-based state machine for transitions related to discovery and connection
* `harmony/harmonyWebSocket.ts`: WebSocket-based approach for direct network control
* `harmony/harmonyState.ts`: Defines constants and interfaces for describing loading stages
* `errorHandler.ts`: Provides a standard way to handle and display errors
* `localStorage.ts`: A thin wrapper around Raycast's local storage API with logging
* `logger.ts`: Central logging mechanism that writes logs to the console or keeps them in memory
* `secure-storage.ts`: Example of encrypted storage usage with Raycast's local storage
* `session-manager.ts`: Manages session tokens, expiration, and cache clearing

#### 5. /types
A set of TypeScript definitions for core concepts, logging, errors, and preferences. Notable files:
* `errors.ts`: Defines the HarmonyError class, error categories, severities, and potential recovery actions
* `harmony.ts`: Describes domain objects like HarmonyHub, HarmonyDevice, HarmonyCommand, HarmonyActivity, and the HarmonyStage enum
* `logging.ts`: Log levels, interfaces, and structures for the logging system
* `preferences.ts`: Interface for user preferences (e.g., default view, command hold time, etc.)
* `websocket.ts`: Types for WebSocket-based message structures, commands, and responses

#### 6. /ui
* `toast-manager.ts`: A small helper class that wraps Raycast showToast calls for consistent success/error/loading toasts

#### 7. /utils
* `validation.ts`: Validation utilities for checking hub IPs, device properties, command requests, and retry configurations

#### 8. control.tsx
The main entry point for the extension's command. It wraps the HarmonyCommand component with the HarmonyProvider, thereby setting up the context and hooking everything together.

## Flow of the Application

### 1. Startup & Discovery
* When the extension is opened, `control.tsx` loads the HarmonyProvider (from hooks/useHarmony)
* HarmonyProvider automatically starts discovering Harmony Hubs via `HarmonyManager.startDiscovery`

### 2. Selecting a Hub
* The user sees a list of available hubs (HarmonyCommand shows the "hubs" view)
* Selecting a hub triggers `connect(hub)` in useHarmony, creating a HarmonyClient to load devices, activities, and the current activity

### 3. Browsing Devices and Activities
* Users can switch between "Devices" and "Activities" via dropdown in the Raycast UI, or they can filter commands directly
* Devices (and their commands) come from `getDevices()`. Activities come from `getActivities()`

### 4. Sending Commands or Starting Activities
* The DeviceList or HarmonyCommand will call `executeCommand()` or `startActivity()`/`stopActivity()` from useHarmony
* This is relayed to HarmonyClient which sends the appropriate commands to the Harmony Hub over a websocket or direct protocol

### 5. Error Handling
* If an error occurs at any point (discovery, connection, command execution), a HarmonyError is thrown
* The UI displays error states via `FeedbackState.tsx`. The `ErrorBoundary.tsx` also catches unhandled component errors

### 6. Caching & Logging
* `harmonyManager.ts` caches discovered hubs to speed up subsequent loads
* `harmonyClient.ts` may cache devices/activities to reduce repeated network calls
* The Logger writes debug information based on user preferences (e.g., debugLogging)

## Key Components and Hooks

### 1. DeviceList.tsx
* Accepts optional filters (e.g., a single deviceType) and shows matching devices in a Raycast list
* Uses `executeCommand()` to trigger commands on item selection

### 2. HarmonyCommand.tsx
* A comprehensive UI for controlling hubs, devices, and activities in a single list-based interface
* Organizes multiple views: Hubs, Activities, Devices, or Commands (when user toggles the dropdown)
* Performs searching and filtering, then calls `executeCommand`, `startActivity`, `stopActivity`, or `connect`

### 3. FeedbackState.tsx
* A common UI for loading messages, empty states, and error states
* Includes ready-to-use states like `LOADING_DEVICES` or `GENERAL_ERROR`

### 4. useHarmony.ts
The main hook providing the "HarmonyContext" to the entire UI. Manages:
* Discovery (via HarmonyManager)
* Connection (via HarmonyClient)
* State (devices, activities, current activity)
* Commands (execute a command, start/stop an activity)
* Handles errors and loading states, exposing error and loadingState

### 5. ErrorBoundary.tsx
* Catches runtime errors in child components, logging them and rendering a fallback FeedbackState

## Services and Architecture

### 1. Harmony Management

#### HarmonyManager
* Discovers hubs using @harmonyhub/discover, caches results, and has logic to handle timeouts
* Provides an interface to clear caches and re-discover

#### HarmonyClient
* Connects to a chosen hub, fetching devices/activities
* Sends commands to the hub, handling logic such as "hold" and "release" for IR-based commands
* Maintains a local cache for devices/activities to reduce repeated lookups

#### commandQueue.ts
* Can queue commands to manage concurrency and retries

### 2. State Machines and WebSocket
* `harmonyMachine.ts`: An XState-based finite state machine that defines states like DISCOVERING, CONNECTING, CONNECTED, etc.
* `harmonyWebSocket.ts`: A lower-level approach to managing direct WebSocket communication with the hub

### 3. Error Handling and Logging
* `errorHandler.ts`: Central logic to convert generic errors into HarmonyError objects and optionally show Raycast toasts
* `logger.ts`: Manages log levels (DEBUG, INFO, WARN, ERROR) with in-memory or console output
* `localStorage.ts`: Thin abstraction over Raycast LocalStorage with error logging
* `secure-storage.ts`: Demonstrates encryption of stored data using crypto

### 4. Session Management
* `session-manager.ts`: Manages user sessions for local operation with the Harmony Hub

## Types & Data Modeling

The application defines a consistent domain model across all services:
* `HarmonyHub`: A discovered hub with an ip, name, hubId, remoteId, etc.
* `HarmonyDevice`: A device on the hub, containing a list of HarmonyCommands
* `HarmonyActivity`: Represents an activity with an id, name, and isCurrent status
* `HarmonyCommand`: Identifies a command (like volumeUp) with fields for id, name, label, and group

Error handling uses `HarmonyError` (in `errors.ts`), which includes:
* `category` (e.g., CONNECTION, COMMAND_EXECUTION)
* `severity`
* `recoveryStrategies` (possible user or automatic actions)

There are also enumerations like `HarmonyStage` (describing the extension's states: DISCOVERING, CONNECTING, CONNECTED, etc.) and `LogLevel` for logging.

## Putting It All Together

### 1. Raycast Command Entry Point
* `control.tsx` is the root command file
* It wraps everything in a `HarmonyProvider` (from `useHarmony`), which initializes the hub discovery and sets up the context

### 2. Hub Discovery & Selection
* Automatically fetches previously cached hubs or triggers new discovery
* Lists them for user selection in a Raycast list

### 3. Connected State
* Once connected, the extension loads devices and activities. Users can browse them and issue commands

### 4. Commands & Activities
* The UI (especially `HarmonyCommand.tsx` and `DeviceList.tsx`) references `useHarmony` methods to send commands or switch activities

### 5. Error and Loading States
* If errors arise, the `FeedbackState` and `ErrorBoundary` handle user-facing messages. Logging captures them for debugging

## Additional Notes

* Styling: Raycast's API provides the user interface elements (lists, actions, toasts) rather than a custom styling approach
* Caching: The application uses a combination of local storage for caching discovered hubs and the HarmonyClient cache for device/activity configurations
* Testing: While not shown, many of these services and hooks could be tested independently of Raycast's UI using standard React testing or pure TypeScript tests

## Conclusion

The Harmony Raycast Extension is a React/TypeScript application structured into clear domain-driven modules. Its key hooks (`useHarmony`), services (`HarmonyManager`, `HarmonyClient`), and UI components (`HarmonyCommand`, `DeviceList`, etc.) offer a coherent flow: from discovering Harmony Hubs, establishing a connection, and rendering device/activity data, to sending commands and handling errors. This layout provides a solid foundation for extending or customizing the extension's capabilities.
</file>

<file path="local-docs/harmony-raycast.md">
```markdown
# Harmony Control for Raycast

Harmony Control is a Raycast extension that allows you to control your Logitech Harmony Hub devices directly from Raycast. It provides a fast and efficient interface for managing your home entertainment system.

## Quick Start

### Installation

1.  Open Raycast.
2.  Search for "Harmony Control".
3.  Click Install.

### Usage

1.  Launch the extension by typing "Harmony Control" in Raycast.
2.  The extension will automatically discover Harmony Hubs on your local network.
3.  Select your hub from the list.
4.  Browse and control your devices and activities.

## Configuration

You can configure the extension in Raycast's preferences:

*   **Default View:** Choose whether to show "Activities" or "Devices" by default.
*   **Command Hold Time:** Adjust the duration (in milliseconds) to hold a command. Default is 100ms.
*   **Cache Duration:**  Set how long hub data is cached (in seconds). Default is 3600 seconds (1 hour).
*   **Debug Logging:** Enable or disable debug logging. Default is true.
*   **Network Timeout:**  Set the network request timeout (in milliseconds). Default is 5000ms.
* **Auto Retry:** Enable/Disable automatic retries for failed operations. Defaults to true
* **Max Retries**: Maximum number of times to retry. Defaults to 3.

## Features

### Device Control

*   Browse all configured devices.
*   Execute device-specific commands (e.g., power, volume, input).

### Activity Management

*   Start and stop Harmony activities.
*   View the current activity status.

### Hub Discovery
* Automatically detects hubs on the local network

### Other
* Refresh the current connection.
* Clear cache and re-discover hubs.

## Troubleshooting
* Ensure your Hub and Mac are on the same network.
* Make sure the Hub is powered on and connected to your Wi-Fi.
* Check your firewall settings and unblock ports required by Harmony.
* Verify that the hub has a direct line of sight to IR-controlled devices.

## Dependencies

*   `@harmonyhub/client-ws`:  Harmony Hub client library.
*   `@harmonyhub/discover`:  Harmony Hub discovery library.
*   `@raycast/api`: Raycast API library.
*   `@raycast/utils`: Raycast utilities.
*   `ws`: WebSocket library.

## Public Interfaces and Features

The extension's main functionalities are organized around React components, custom hooks, and services. Here's a breakdown:

### `src/control.tsx`

This is the main entry point for the extension. It renders the `HarmonyCommand` component wrapped in a `HarmonyProvider`.

### Components (`src/components/`)

#### `DeviceList.tsx`

Displays a searchable list of Harmony devices and their commands.

*   **Props:**
    *   `deviceType?: string`: (Optional) Filters the list to a specific device type.

*   **Features:**
    *   Lists devices, showing their name, type, and number of commands.
    *   Provides a search bar to filter devices and commands.
    *   Allows execution of commands via an `ActionPanel`.

#### `ErrorBoundary.tsx`

A standard React error boundary component that catches and displays errors.

*   **Props:**
    *   `children: React.ReactNode`: The child components to wrap.

*   **Features:**
    *   Catches errors in its child component tree.
    *   Displays a generic error message.
    *   Logs errors for debugging.

#### `FeedbackState.tsx`

Displays loading, error, and empty states.

*   **Props:**
    *   `title: string`: The title to display.
    *   `description?: string`: Optional description.
    *   `icon?: Icon | { source: string }`: The icon.
    *   `color?: Color`: Icon color.
    *   `actions?: React.ReactNode`: Optional actions.
    *   `error?: HarmonyError`: Optional error object.
    *   `onRetry?: () => void`: Optional retry callback.
    * `onReconnect?: () => void`: Optional reconnect callback.
    * `onClearCache?: () => void`: Optional clear-cache callback.
    * `onResetConfig?: () => void`: Optional config-reset callback.
*   **Features:**
    *   Provides consistent UI for different states.
    *   Supports displaying error details and recovery actions.

#### `HarmonyCommand.tsx`

Provides a unified interface to control devices and activities.

*   **Features:**
    *   Displays a list of hubs, activities, or devices based on the selected view.
    *   Supports searching and filtering.
    *   Allows execution of commands and starting/stopping activities.
    *   Handles hub selection and connection.
    * Handles switching view between hubs, activities, devices, and individual commands.

### Hooks (`src/hooks/`)

#### `useHarmony.ts`

The main hook for managing Harmony Hub state and operations. Provides a context that is used by other components.

*   **Returned Values:**
    *   `hubs: HarmonyHub[]`: List of discovered hubs.
    *   `selectedHub: HarmonyHub | null`: The currently selected hub.
    *   `devices: HarmonyDevice[]`: List of devices for the selected hub.
    *   `activities: HarmonyActivity[]`: List of activities for the selected hub.
    *   `currentActivity: HarmonyActivity | null`: The currently active activity.
    *   `error: HarmonyError | null`: Any current error.
    *   `loadingState: LoadingState`: The current loading state.
    *   `connect: (hub: HarmonyHub) => Promise<void>`: Connects to the specified hub.
    *   `disconnect: () => Promise<void>`: Disconnects from the current hub.
    *   `refresh: () => Promise<void>`: Refreshes the hub state.
    *   `executeCommand: (command: HarmonyCommand) => Promise<void>`: Executes a command.
    *   `clearCache: () => Promise<void>`: Clears the cache and rediscovers hubs.
    *   `startActivity: (activityId: string) => Promise<void>`: Starts an activity.
    *   `stopActivity: () => Promise<void>`: Stops the current activity.

### Services (`src/services/`)
#### `harmony/harmonyClient.ts`

Handles communication with a specific Harmony Hub.

*   **`HarmonyClient` Class:**
    *   `constructor(hub: HarmonyHub)`: Initializes a new client for the given hub.
    *   `connect(): Promise<void>`: Connects to the hub.
    *   `getDevices(): Promise<HarmonyDevice[]>`: Retrieves the list of devices.
    *   `getActivities(): Promise<HarmonyActivity[]>`: Retrieves the list of activities.
    *   `getCurrentActivity(): Promise<HarmonyActivity | null>`: Gets the current activity.
    *   `startActivity(activityId: string): Promise<void>`: Starts an activity.
    *   `stopActivity(): Promise<void>`: Stops the current activity.
    *   `executeCommand(command: HarmonyCommand): Promise<void>`: Executes a command.
    *   `disconnect(): Promise<void>`: Disconnects from the hub.

#### `harmony/harmonyManager.ts`

Manages discovery of Harmony Hubs.

* **`HarmonyManager` Class:**
  * `startDiscovery(onProgress?: (progress: number, message: string) => void): Promise<HarmonyHub[]>`: Starts the hub discovery process, with an optional progress callback.
  * `cleanup(): Promise<void>`: Cleans up discovery.
  *  `clearCache(): Promise<void>`: Clears the hub cache.

#### `harmony/commandQueue.ts`

Manages a queue of commands to be executed.

*   **`CommandQueue` Class:**
    *   `constructor(commandSender: CommandSender, config?: Partial<CommandQueueConfig>)`: Creates a new command queue. `CommandSender` is a function that takes a `HarmonyCommand` and sends it.
    *   `enqueue(request: CommandRequest): Promise<CommandResult>`: Adds a command to the queue.
    *  `cancelAll(): void`: Cancels all pending commands
    *  `clearCompleted(): void`: Clears completed commands.

#### `errorHandler.ts`

Provides consistent error handling.

*   **`ErrorHandler` Class:**
    *   `static handle(error: Error | unknown, context?: string): void`: Handles an error by logging and showing a toast.
    *   `static handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T>`: Handles errors in an async operation.

#### `localStorage.ts`

Provides a wrapper around Raycast's `LocalStorage` with error logging.

*   **`LocalStorage` Class:**
    *   `static getItem(key: string): Promise<string | null>`: Retrieves an item.
    *   `static setItem(key: string, value: string): Promise<void>`: Stores an item.
    *   `static removeItem(key: string): Promise<void>`: Removes an item.
    *   `static clear(): Promise<void>`: Clears all items.

#### `logger.ts`

Provides a logging mechanism.

*   **`Logger` Class:**
    *   `static debug(message: string, data?: unknown): void`: Logs a debug message.
    *   `static info(message: string, data?: unknown): void`: Logs an info message.
    *   `static warn(message: string, data?: unknown): void`: Logs a warning message.
    *   `static error(message: string, data?: unknown): void`: Logs an error message.
    *   `static logError(error: Error, context?: string): void`: Logs a full error with stack trace.

#### `secure-storage.ts`
Provides secure storage using encryption. (Currently not in use.)
#### `session-manager.ts`
Manages sessions. (Currently not in use.)

#### `ui/toast-manager.ts`

Helper class to wrap and simplify Raycast `showToast` calls.

*   **`ToastManager` Class:**
    *  `static success(title: string, message?: string): void`: Shows a success toast.
    *  `static error(title: string, message?: string): void`: Shows an error toast.
    *  `static loading(title: string, message?: string): void` Shows a loading toast.

#### `utils/validation.ts`

Provides validation functions.
*   `isNonEmptyString(value: unknown): value is string`: Check if a value is not an empty string.
*  `isPositiveNumber(value: unknown): value is number`: Checks if a value is a number > 0.
*   `isValidIpAddress(value: unknown): value is string`: Checks if a value is a valid IPv4 address.
*  `validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub`: Validates Hub configurations.
*  `validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice`: Validates Device information.
* `validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity`: Validates Activity information.
* `validateCommandRequest(request: Partial<CommandRequest>): asserts request is CommandRequest`: Validates requests.

### Types (`src/types/`)

This directory contains TypeScript type definitions for the project.  Key types include:

*   `harmony.ts`:  Defines core types like `HarmonyHub`, `HarmonyDevice`, `HarmonyActivity`, `HarmonyCommand`, and `LoadingState`.
*   `errors.ts`:  Defines `HarmonyError`, `ErrorCategory`, `ErrorSeverity`, and related error handling types.
*  `preferences.ts`: Defines the `Preferences` interface.
*   `logging.ts`: Defines types related to logging (`LogLevel`, `LogEntry`, etc.).
```
</file>

<file path="src/components/DeviceList.tsx">
// External dependencies
import { useMemo, useState, useCallback } from "react";
import { List, Icon, ActionPanel, Action, showToast, Toast } from "@raycast/api";
// Types
import { HarmonyDevice, HarmonyCommand } from "../types/harmony";
import { useHarmony } from "../hooks/useHarmony";
import { Logger } from "../services/logger";
import { FeedbackState, ErrorStates, LoadingStates } from "./FeedbackState";
import { HarmonyStage } from "../types/harmony";
interface DeviceListProps {
  /** Optional filter for device types */
  deviceType?: string;
}
/**
 * DeviceList component displays a searchable list of Harmony devices and their commands.
 * Supports filtering and command execution.
 */
export function DeviceList({ deviceType }: DeviceListProps): JSX.Element {
  const { selectedHub, devices, error, loadingState, executeCommand } = useHarmony();
  const [searchText, setSearchText] = useState("");
  // Memoize filtered devices to prevent unnecessary recalculations
  const filteredDevices = useMemo(() => {
    let result = devices;
    if (deviceType) {
      result = result.filter(device => device.type === deviceType);
    }
    if (searchText) {
      const searchLower = searchText.toLowerCase();
      result = result.filter(device => 
        device.name.toLowerCase().includes(searchLower) ||
        device.commands.some(cmd => cmd.label.toLowerCase().includes(searchLower))
      );
    }
    return result;
  }, [devices, deviceType, searchText]);
  // Memoize command handler to prevent recreation on each render
  const handleCommand = useCallback(async (device: HarmonyDevice, command: HarmonyCommand) => {
    try {
      await showToast({
        style: Toast.Style.Animated,
        title: `Sending command ${command.label} to ${device.name}`,
      });
      await executeCommand({
        id: command.id,
        name: command.name,
        label: command.label || command.name,
        deviceId: device.id,
        group: command.group || "IRCommand"
      });
      await showToast({
        style: Toast.Style.Success,
        title: "Command sent successfully",
      });
    } catch (error) {
      Logger.error("Failed to execute command", error);
      await showToast({
        style: Toast.Style.Failure,
        title: "Failed to execute command",
        message: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }, [executeCommand]);
  if (!selectedHub) {
    return <FeedbackState {...ErrorStates.NO_HUB_SELECTED} />;
  }
  if (error) {
    return <FeedbackState {...ErrorStates.GENERAL_ERROR} error={error} />;
  }
  if (loadingState.stage === HarmonyStage.LOADING_DEVICES) {
    return <FeedbackState {...LoadingStates.LOADING_DEVICES} />;
  }
  return (
    <List
      searchText={searchText}
      onSearchTextChange={setSearchText}
      isLoading={loadingState.stage !== HarmonyStage.CONNECTED}
      searchBarPlaceholder="Search devices and commands..."
    >
      {filteredDevices.map((device) => (
        <List.Item
          key={device.id}
          icon={Icon.Devices}
          title={device.name}
          subtitle={device.type}
          accessories={[{ text: `${device.commands.length} commands` }]}
          actions={
            <ActionPanel>
              {device.commands.map((command) => (
                <Action
                  key={command.id}
                  title={command.label}
                  onAction={() => handleCommand(device, command)}
                />
              ))}
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}
</file>

<file path="src/components/ErrorBoundary.tsx">
import React from "react";
import { List, Icon } from "@raycast/api";
import { Logger } from "../services/logger";
import { ErrorCategory } from "../types/errors";
import { FeedbackState, ErrorStates } from "./FeedbackState";
interface ErrorBoundaryProps {
  children: React.ReactNode;
}
interface ErrorBoundaryState {
  error: Error | null;
}
/**
 * Error boundary component to catch and handle errors in the component tree.
 * Displays user-friendly error messages and logs errors for debugging.
 */
export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { error: null };
  }
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { error };
  }
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    Logger.error("Component error caught by boundary", {
      error,
      componentStack: errorInfo.componentStack,
      category: ErrorCategory.UI,
    });
  }
  render(): React.ReactNode {
    if (this.state.error) {
      return (
        <FeedbackState
          {...ErrorStates.GENERAL_ERROR}
          description={`An unexpected error occurred: ${this.state.error.message}`}
        />
      );
    }
    return this.props.children;
  }
}
</file>

<file path="src/components/FeedbackState.tsx">
import { List, Icon, Color, ActionPanel, Action } from "@raycast/api";
import React from "react";
import { HarmonyError, ErrorSeverity, ErrorRecoveryAction } from "../types/errors";
import { Logger } from "../services/logger";
/**
 * Props for the FeedbackState component.
 */
export interface FeedbackStateProps {
  /** The title to display */
  title: string;
  /** Optional description text */
  description?: string;
  /** The icon to display */
  icon?: Icon | { source: string };
  /** The color of the icon */
  color?: Color;
  /** Optional actions to display */
  actions?: React.ReactNode;
  /** Optional error object */
  error?: HarmonyError;
  /** Optional retry callback */
  onRetry?: () => void;
  /** Optional reconnect callback */
  onReconnect?: () => void;
  /** Optional clear cache callback */
  onClearCache?: () => void;
  /** Optional reset config callback */
  onResetConfig?: () => void;
}
/**
 * Type guard to check if an icon is a Raycast Icon enum
 */
function isRaycastIcon(icon: Icon | { source: string } | undefined): icon is Icon {
  return typeof icon === "string";
}
/**
 * Get icon and color based on error severity
 */
function getErrorDisplay(error?: HarmonyError): { icon: Icon; color: Color } {
  if (!error) return { icon: Icon.Circle, color: Color.PrimaryText };
  switch (error.severity) {
    case ErrorSeverity.CRITICAL:
      return { icon: Icon.ExclamationMark, color: Color.Red };
    case ErrorSeverity.ERROR:
      return { icon: Icon.Warning, color: Color.Orange };
    case ErrorSeverity.WARNING:
      return { icon: Icon.QuestionMark, color: Color.Yellow };
    case ErrorSeverity.INFO:
      return { icon: Icon.Info, color: Color.Blue };
    default:
      return { icon: Icon.ExclamationMark, color: Color.Red };
  }
}
/**
 * Get recovery actions based on error recovery strategy
 */
function getRecoveryActions(
  error: HarmonyError,
  callbacks: {
    onRetry?: () => void;
    onReconnect?: () => void;
    onClearCache?: () => void;
    onResetConfig?: () => void;
  }
): React.ReactNode {
  const strategy = error.getRecoveryStrategy();
  if (!strategy) return null;
  const actions: React.ReactNode[] = [];
  strategy.actions.forEach(action => {
    switch (action) {
      case ErrorRecoveryAction.RETRY:
        if (callbacks.onRetry) {
          actions.push(
            <Action
              key="retry"
              title="Retry"
              icon={Icon.ArrowClockwise}
              onAction={() => {
                Logger.debug("Retrying action");
                callbacks.onRetry?.();
              }}
            />
          );
        }
        break;
      case ErrorRecoveryAction.RECONNECT:
        if (callbacks.onReconnect) {
          actions.push(
            <Action
              key="reconnect"
              title="Reconnect"
              icon={Icon.Link}
              onAction={() => {
                Logger.debug("Reconnecting to hub");
                callbacks.onReconnect?.();
              }}
            />
          );
        }
        break;
      case ErrorRecoveryAction.CLEAR_CACHE:
        if (callbacks.onClearCache) {
          actions.push(
            <Action
              key="clearCache"
              title="Clear Cache"
              icon={Icon.Trash}
              onAction={() => {
                Logger.debug("Clearing cache");
                callbacks.onClearCache?.();
              }}
            />
          );
        }
        break;
      case ErrorRecoveryAction.RESET_CONFIG:
        if (callbacks.onResetConfig) {
          actions.push(
            <Action
              key="resetConfig"
              title="Reset Configuration"
              icon={Icon.Gear}
              onAction={() => {
                Logger.debug("Resetting configuration");
                callbacks.onResetConfig?.();
              }}
            />
          );
        }
        break;
    }
  });
  if (actions.length === 0) return null;
  return (
    <ActionPanel>
      {actions}
    </ActionPanel>
  );
}
/**
 * Get formatted error message with recovery suggestions
 */
function getErrorMessage(error: HarmonyError, description?: string): string {
  const messages: string[] = [];
  if (description) {
    messages.push(description);
  }
  messages.push(error.message);
  const strategy = error.getRecoveryStrategy();
  if (strategy && !strategy.automatic) {
    const recoveryMessage = error instanceof HarmonyError ? error.recoveryMessage : null;
    if (recoveryMessage) {
      messages.push(recoveryMessage);
    }
  }
  return messages.join("\n\n");
}
/**
 * FeedbackState component displays various application states with consistent styling.
 * Used for showing loading, error, and empty states throughout the application.
 *
 * @example
 * ```tsx
 * <FeedbackState
 *   title="No Devices Found"
 *   description="Please check your network connection"
 *   icon={Icon.Circle}
 *   error={error}
 *   onRetry={() => refetchDevices()}
 * />
 * ```
 */
export function FeedbackState({ 
  title, 
  description, 
  icon, 
  color = Color.PrimaryText, 
  actions,
  error,
  onRetry,
  onReconnect,
  onClearCache,
  onResetConfig
}: FeedbackStateProps) {
  // Get error display properties
  const errorDisplay = error ? getErrorDisplay(error) : undefined;
  // Use provided icon/color or error-based ones
  const iconSource = isRaycastIcon(icon) ? icon : (icon?.source || errorDisplay?.icon || Icon.Circle);
  const iconColor = error ? errorDisplay?.color : color;
  // Get error message and recovery actions
  const finalDescription = error ? getErrorMessage(error, description) : description;
  const recoveryActions = error ? getRecoveryActions(error, {
    onRetry,
    onReconnect,
    onClearCache,
    onResetConfig
  }) : actions;
  return (
    <List>
      <List.EmptyView
        icon={{ source: iconSource, tintColor: iconColor }}
        title={title}
        description={finalDescription}
        actions={recoveryActions}
      />
    </List>
  );
}
/**
 * Predefined loading states for feedback display.
 */
export const LoadingStates = {
  DISCOVERING: {
    title: "Discovering Harmony Hubs...",
    description: "Searching your network for Harmony Hubs",
    icon: Icon.MagnifyingGlass,
  },
  CONNECTING: {
    title: "Connecting to Hub...",
    description: "Establishing connection to your Harmony Hub",
    icon: Icon.Link,
  },
  LOADING_ACTIVITIES: {
    title: "Loading Activities...",
    description: "Fetching available activities from your Hub",
    icon: Icon.List,
  },
  LOADING_DEVICES: {
    title: "Loading Devices...",
    description: "Fetching connected devices and their commands",
    icon: Icon.Devices,
  },
  EXECUTING_COMMAND: {
    title: "Executing Command...",
    description: "Sending command to your device",
    icon: Icon.Play,
  }
} as const;
/**
 * Predefined error states for feedback display.
 */
export const ErrorStates = {
  NO_HUBS_FOUND: {
    title: "No Harmony Hubs Found",
    description: "Make sure your Harmony Hub is:\n• Powered on\n• Connected to WiFi\n• On the same network",
    icon: Icon.WifiDisabled,
    color: Color.Red,
  },
  CONNECTION_FAILED: {
    title: "Connection Failed",
    description:
      "Unable to connect to your Harmony Hub. Try:\n• Checking your network connection\n• Restarting your Hub\n• Verifying Hub's IP address",
    icon: Icon.ExclamationMark,
    color: Color.Red,
  },
  COMMAND_FAILED: {
    title: "Command Failed",
    description:
      "Failed to execute the command. Try:\n• Checking device power\n• Verifying IR line of sight\n• Retrying the command",
    icon: Icon.ExclamationMark,
    color: Color.Red,
  },
  GENERAL_ERROR: {
    title: "Something Went Wrong",
    description: "An unexpected error occurred. Please try again or contact support if the issue persists.",
    icon: Icon.ExclamationMark,
    color: Color.Red,
  },
  NO_HUB_SELECTED: {
    title: "No Hub Selected",
    description: "Please select a Harmony Hub to continue",
    icon: Icon.ExclamationMark,
    color: Color.Red,
  }
} as const;
/**
 * Type for loading states
 */
export type LoadingState = keyof typeof LoadingStates;
/**
 * Type for error states
 */
export type ErrorState = keyof typeof ErrorStates;
</file>

<file path="src/components/HarmonyCommand.tsx">
import { List, Icon, ActionPanel, Action, showToast, Toast, getPreferenceValues } from "@raycast/api";
import { useMemo, useState, useCallback, useEffect } from "react";
import { useHarmony } from "../hooks/useHarmony";
import { HarmonyDevice, HarmonyActivity, HarmonyHub, HarmonyStage } from "../types/harmony";
import type { HarmonyCommand } from "../types/harmony";
import { Logger } from "../services/logger";
import { FeedbackState } from "./FeedbackState";
import { ErrorBoundary } from "./ErrorBoundary";
import { Preferences } from "../types/preferences";
/**
 * HarmonyCommand component provides a unified interface for controlling Harmony devices and activities.
 * Supports searching, filtering, and executing commands.
 */
export function HarmonyCommand(): JSX.Element {
  const {
    hubs,
    selectedHub,
    devices,
    activities,
    currentActivity,
    error,
    loadingState,
    connect,
    disconnect,
    refresh,
    executeCommand,
    clearCache,
    startActivity,
    stopActivity
  } = useHarmony();
  const [searchText, setSearchText] = useState("");
  const preferences = getPreferenceValues<Preferences>();
  const defaultView = preferences.defaultView || "devices";
  const [view, setView] = useState<"hubs" | "activities" | "devices" | "commands">(
    selectedHub ? defaultView : "hubs"
  );
  const [selectedDevice, setSelectedDevice] = useState<HarmonyDevice | null>(null);
  // Start discovery on mount
  useEffect(() => {
    refresh().catch((error) => {
      Logger.error("Failed to refresh:", error);
      showToast({
        style: Toast.Style.Failure,
        title: "Failed to discover hubs",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    });
  }, [refresh]);
  // Reset to hub selection if no hub is selected
  useEffect(() => {
    if (!selectedHub && view !== "hubs") {
      setView("hubs");
    }
  }, [selectedHub, view]);
  // Get icon for command based on its label
  const getCommandIcon = useCallback((label: string): Icon => {
    const lowerLabel = label.toLowerCase();
    if (lowerLabel.includes("power")) return Icon.Power;
    if (lowerLabel.includes("volume")) return Icon.SpeakerHigh;
    if (lowerLabel.includes("mute")) return Icon.SpeakerOff;
    if (lowerLabel.includes("play")) return Icon.Play;
    if (lowerLabel.includes("pause")) return Icon.Pause;
    if (lowerLabel.includes("stop")) return Icon.Stop;
    if (lowerLabel.includes("forward")) return Icon.Forward;
    if (lowerLabel.includes("back")) return Icon.Rewind;
    if (lowerLabel.includes("input")) return Icon.Link;
    if (lowerLabel.includes("menu")) return Icon.List;
    return Icon.Circle;
  }, []);
  // Filter and sort devices based on search
  const filteredDevices = useMemo(() => {
    if (!devices) return [];
    return devices
      .filter(device => 
        device.name.toLowerCase().includes(searchText.toLowerCase()) ||
        device.commands.some(cmd => 
          cmd.name.toLowerCase().includes(searchText.toLowerCase())
        )
      )
      .sort((a, b) => a.name.localeCompare(b.name));
  }, [devices, searchText]);
  // Filter and sort activities based on search
  const filteredActivities = useMemo(() => {
    if (!activities) return [];
    return activities
      .filter(activity =>
        activity.name.toLowerCase().includes(searchText.toLowerCase())
      )
      .sort((a, b) => a.name.localeCompare(b.name));
  }, [activities, searchText]);
  // Handle hub selection
  const handleHubSelect = useCallback(async (hub: HarmonyHub) => {
    try {
      await connect(hub);
      setView(defaultView);
      setSearchText("");
    } catch (error) {
      Logger.error("Failed to connect to hub:", error);
      showToast({
        style: Toast.Style.Failure,
        title: "Failed to connect",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }, [connect, defaultView]);
  // Handle command execution
  const handleCommand = useCallback(async (command: { name: string; deviceId: string; id: string; group?: string; label?: string }) => {
    try {
      Logger.debug("Executing command:", {
        command,
        device: selectedDevice?.name,
        deviceId: selectedDevice?.id
      });
      await executeCommand({
        name: command.name,
        deviceId: command.deviceId,
        id: command.id,
        label: command.label || command.name,
        group: command.group || "IRCommand"
      });
      showToast({
        style: Toast.Style.Success,
        title: "Command sent",
        message: command.name
      });
    } catch (error) {
      Logger.error("Failed to execute command:", error);
      showToast({
        style: Toast.Style.Failure,
        title: "Command failed",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }, [executeCommand, selectedDevice]);
  const handleActivity = useCallback(async (activity: HarmonyActivity) => {
    try {
      const isCurrentActivity = currentActivity?.id === activity.id;
      if (isCurrentActivity) {
        Logger.debug("Stopping activity", { activityId: activity.id });
        await stopActivity();
        showToast({
          style: Toast.Style.Success,
          title: "Activity stopped",
          message: activity.name
        });
      } else {
        Logger.debug("Starting activity", { activityId: activity.id });
        await startActivity(activity.id);
        showToast({
          style: Toast.Style.Success,
          title: "Activity started",
          message: activity.name
        });
      }
      // Refresh to update current activity
      await refresh();
    } catch (error) {
      Logger.error("Failed to handle activity:", error);
      showToast({
        style: Toast.Style.Failure,
        title: "Activity failed",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }, [currentActivity, startActivity, stopActivity, refresh]);
  if (error) {
    return <FeedbackState 
      error={error} 
      onRetry={refresh}
      title="Failed to load Harmony Hub"
    />;
  }
  useEffect(() => {
    Logger.debug("HarmonyCommand render", {
      view,
      deviceCount: filteredDevices.length,
      activityCount: filteredActivities.length,
      loadingStage: loadingState.stage
    });
  }, [view, filteredDevices.length, filteredActivities.length, loadingState.stage]);
  // Show loading state
  if (loadingState.stage === HarmonyStage.DISCOVERING && hubs.length === 0) {
    return (
      <List isLoading={true}>
        <List.EmptyView
          key="loading"
          icon={Icon.CircleProgress}
          title="Discovering Harmony Hubs..."
          description={loadingState.message}
        />
      </List>
    );
  }
  // Show hub selection
  if (view === "hubs") {
    return (
      <List
        searchBarPlaceholder="Search hubs..."
        onSearchTextChange={setSearchText}
        isLoading={loadingState.stage === HarmonyStage.DISCOVERING}
      >
        <List.Section key="hub-selection" title="Available Hubs">
          {hubs.map((hub) => (
            <List.Item
              key={hub.ip}
              title={hub.name}
              subtitle={hub.ip}
              icon={Icon.Globe}
              actions={
                <ActionPanel>
                  <ActionPanel.Section>
                    <Action
                      title="Select Hub"
                      onAction={() => handleHubSelect(hub)}
                    />
                  </ActionPanel.Section>
                  <ActionPanel.Section>
                    <Action
                      title="Clear Cache"
                      icon={Icon.Trash}
                      shortcut={{ modifiers: ["cmd", "shift"], key: "c" }}
                      onAction={clearCache}
                    />
                    <Action
                      title="Refresh"
                      icon={Icon.ArrowClockwise}
                      onAction={refresh}
                      shortcut={{ modifiers: ["cmd"], key: "r" }}
                    />
                  </ActionPanel.Section>
                </ActionPanel>
              }
            />
          ))}
        </List.Section>
      </List>
    );
  }
  // Show devices or activities based on view
  if (view === "devices") {
    return (
      <List
        searchBarPlaceholder="Search devices..."
        onSearchTextChange={setSearchText}
        searchBarAccessory={
          <List.Dropdown
            tooltip="Select View"
            value={view}
            onChange={(newView) => {
              setView(newView as "devices" | "activities" | "commands");
              setSelectedDevice(null);  // Reset selected device when changing views
            }}
          >
            <List.Dropdown.Item key="devices" title="Devices" value="devices" />
            <List.Dropdown.Item key="activities" title="Activities" value="activities" />
            <List.Dropdown.Item key="commands" title="Commands" value="commands" />
          </List.Dropdown>
        }
      >
        {selectedDevice ? (
          // Show commands for selected device
          <List.Section key={selectedDevice.id} title={`${selectedDevice.name} Commands`}>
            {selectedDevice.commands
              .filter((command) =>
                searchText
                  ? command.name.toLowerCase().includes(searchText.toLowerCase())
                  : true
              )
              .map((command) => {
                const itemKey = `${selectedDevice.id}-${command.id}`;
                return (
                  <List.Item
                    key={itemKey}
                    title={command.name}
                    icon={getCommandIcon(command.name)}
                    actions={
                      <ActionPanel>
                        <Action
                          title="Send Command"
                          onAction={() => handleCommand({
                            name: command.name,
                            deviceId: selectedDevice.id,
                            id: command.id,
                            group: command.group || "Default"
                          })}
                        />
                        <Action
                          title="Back to Devices"
                          icon={Icon.ArrowLeft}
                          onAction={() => setSelectedDevice(null)}
                          shortcut={{ modifiers: ["cmd"], key: "[" }}
                        />
                      </ActionPanel>
                    }
                  />
                );
              })}
          </List.Section>
        ) : (
          // Show list of devices
          <List.Section key="devices" title="Devices">
            {filteredDevices.map((device) => (
              <List.Item
                key={device.id}
                title={device.name}
                subtitle={`${device.commands.length} commands`}
                icon={Icon.Devices}
                actions={
                  <ActionPanel>
                    <Action
                      title="View Commands"
                      onAction={() => setSelectedDevice(device)}
                    />
                  </ActionPanel>
                }
              />
            ))}
          </List.Section>
        )}
      </List>
    );
  }
  if (view === "commands") {
    return (
      <List
        searchBarPlaceholder="Search commands..."
        onSearchTextChange={setSearchText}
        isLoading={[
          HarmonyStage.DISCOVERING,
          HarmonyStage.CONNECTING,
          HarmonyStage.LOADING_DEVICES,
          HarmonyStage.LOADING_ACTIVITIES,
          HarmonyStage.STARTING_ACTIVITY,
          HarmonyStage.STOPPING_ACTIVITY,
          HarmonyStage.EXECUTING_COMMAND,
          HarmonyStage.REFRESHING
        ].includes(loadingState.stage)}
      >
        {devices.map((device) => {
          // Filter commands based on search text
          const filteredCommands = device.commands.filter((command) =>
            searchText
              ? command.name.toLowerCase().includes(searchText.toLowerCase()) ||
                device.name.toLowerCase().includes(searchText.toLowerCase())
              : true
          );
          // Skip devices with no matching commands when searching
          if (searchText && filteredCommands.length === 0) {
            return null;
          }
          return (
            <List.Section key={device.id} title={device.name}>
              {filteredCommands.map((command) => (
                <List.Item
                  key={`${device.id}-${command.id}`}
                  title={command.name}
                  icon={Icon.Terminal}
                  actions={
                    <ActionPanel>
                      <Action
                        title="Execute Command"
                        onAction={() => handleCommand({
                          name: command.name,
                          deviceId: device.id,
                          id: command.id,
                          group: command.group || "Default"
                        })}
                      />
                    </ActionPanel>
                  }
                />
              ))}
            </List.Section>
          );
        })}
      </List>
    );
  }
  return (
    <List
      searchBarPlaceholder="Search activities..."
      onSearchTextChange={setSearchText}
    >
      <List.Section key="activities" title="Activities">
        {filteredActivities.map((activity) => (
          <List.Item
            key={activity.id}
            title={activity.name}
            icon={currentActivity?.id === activity.id ? Icon.CheckCircle : Icon.Circle}
            actions={
              <ActionPanel>
                <Action
                  title={currentActivity?.id === activity.id ? "Stop Activity" : "Start Activity"}
                  onAction={() => handleActivity(activity)}
                />
              </ActionPanel>
            }
          />
        ))}
      </List.Section>
    </List>
  );
}
</file>

<file path="src/features/control/types/harmony.ts">
export interface HarmonyHub {
  id: string;
  ip: string;
  name: string;
  remoteId: string;
  hubId: string;
  version: string;
  port?: string;
}
export interface HarmonyDevice {
  id: string;
  label: string;
  type: string;
  commands: HarmonyCommand[];
}
export interface HarmonyCommand {
  id: string;
  name: string;
  label: string;
  deviceId: string;
}
export interface ControlGroup {
  name: string;
  function: {
    name: string;
    action: string;
  }[];
}
export interface FixItItem {
  id: string;
  description: string;
  solution: string;
  urls?: string[];
}
export interface ActivityRule {
  type: string;
  condition: string;
  action: string;
}
export interface ActivitySequence {
  id: string;
  name: string;
  steps: {
    action: string;
    delay: number;
  }[];
}
export interface HarmonyActivity {
  id: string;
  label: string;
  isAVActivity: boolean;
  activityTypeDisplayName: string;
  controlGroup: ControlGroup[];
  fixit: FixItItem[];
  rules: ActivityRule[];
  sequences: ActivitySequence[];
  suggestedDisplay: string;
  type: string;
  status: string;
}
</file>

<file path="src/hooks/useHarmony.ts">
import React, { useCallback, useEffect, useState, createContext, useContext, useRef } from "react";
import { 
  HarmonyHub, 
  HarmonyDevice, 
  HarmonyActivity, 
  HarmonyCommand, 
  LoadingState, 
  HarmonyStage 
} from "../types/harmony";
import { HarmonyManager } from "../services/harmony/harmonyManager";
import { HarmonyClient } from "../services/harmony/harmonyClient";
import { HarmonyError, ErrorCategory } from "../types/errors";
import { Logger } from "../services/logger";
import { showToast, Toast } from "@raycast/api";
// Create a single manager instance
const manager = new HarmonyManager();
interface HarmonyContextState {
  hubs: HarmonyHub[];
  selectedHub: HarmonyHub | null;
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  error: HarmonyError | null;
  loadingState: LoadingState;
  connect: (hub: HarmonyHub) => Promise<void>;
  disconnect: () => Promise<void>;
  refresh: () => Promise<void>;
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  clearCache: () => Promise<void>;
  startActivity: (activityId: string) => Promise<void>;
  stopActivity: () => Promise<void>;
}
const HarmonyContext = createContext<HarmonyContextState | null>(null);
interface HarmonyProviderProps {
  children: React.ReactNode;
}
/**
 * Provider component for Harmony Hub functionality
 */
export const HarmonyProvider: React.FC<HarmonyProviderProps> = ({ children }) => {
  const harmony = useHarmonyState();
  return React.createElement(HarmonyContext.Provider, { value: harmony }, children);
};
/**
 * Hook for managing Harmony Hub state and operations
 */
function useHarmonyState(): HarmonyContextState {
  const [hubs, setHubs] = useState<HarmonyHub[]>([]);
  const [selectedHub, setSelectedHub] = useState<HarmonyHub | null>(null);
  const [client, setClient] = useState<HarmonyClient | null>(null);
  const [devices, setDevices] = useState<HarmonyDevice[]>([]);
  const [activities, setActivities] = useState<HarmonyActivity[]>([]);
  const [currentActivity, setCurrentActivity] = useState<HarmonyActivity | null>(null);
  const [error, setError] = useState<HarmonyError | null>(null);
  const [loadingState, setLoadingState] = useState<LoadingState>({
    stage: HarmonyStage.INITIAL,
    message: "Starting hub discovery",
    progress: 0
  });
  // Use ref to track if discovery is in progress
  const isDiscovering = useRef(false);
  // Discover hubs
  const discover = useCallback(async () => {
    // Prevent multiple discoveries
    if (isDiscovering.current) {
      return;
    }
    try {
      isDiscovering.current = true;
      setError(null);
      // Show initial loading state
      setLoadingState({
        stage: HarmonyStage.DISCOVERING,
        message: "Searching for Harmony Hubs...",
        progress: 0.1
      });
      // Show toast for better feedback
      await showToast({
        style: Toast.Style.Animated,
        title: "Searching for Harmony Hubs"
      });
      const discoveredHubs = await manager.startDiscovery((progress, message) => {
        setLoadingState({
          stage: HarmonyStage.DISCOVERING,
          message,
          progress: Math.max(0.1, progress)
        });
      });
      if (!isDiscovering.current) {
        // Discovery was cancelled
        return;
      }
      setHubs(discoveredHubs);
      if (discoveredHubs.length === 0) {
        const error = new HarmonyError(
          "No Harmony Hubs found",
          ErrorCategory.HUB_COMMUNICATION
        );
        setError(error);
        setLoadingState({
          stage: HarmonyStage.ERROR,
          message: error.message,
          progress: 1
        });
        throw error;
      }
      setLoadingState({
        stage: HarmonyStage.CONNECTED,
        message: "Hubs discovered successfully",
        progress: 1
      });
    } catch (err) {
      const error = new HarmonyError(
        "Failed to discover hubs",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState({
        stage: HarmonyStage.ERROR,
        message: error.message,
        progress: 1
      });
      Logger.error("Hub discovery failed", error);
    } finally {
      isDiscovering.current = false;
    }
  }, []);
  // Connect to a hub
  const connect = useCallback(async (hub: HarmonyHub) => {
    try {
      setError(null);
      setLoadingState({
        stage: HarmonyStage.CONNECTING,
        message: `Connecting to ${hub.name}...`,
        progress: 0
      });
      // Create and connect to the client
      const newClient = new HarmonyClient(hub);
      await newClient.connect();
      setClient(newClient);
      setSelectedHub(hub);
      // Load devices
      setLoadingState({
        stage: HarmonyStage.LOADING_DEVICES,
        message: "Loading devices...",
        progress: 0.3
      });
      const hubDevices = await newClient.getDevices();
      setDevices(hubDevices);
      // Load activities
      setLoadingState({
        stage: HarmonyStage.LOADING_ACTIVITIES,
        message: "Loading activities...",
        progress: 0.6
      });
      const hubActivities = await newClient.getActivities();
      setActivities(hubActivities);
      // Get current activity
      const current = await newClient.getCurrentActivity();
      setCurrentActivity(current);
      setLoadingState({
        stage: HarmonyStage.CONNECTED,
        message: "Connected successfully",
        progress: 1
      });
    } catch (err) {
      const error = new HarmonyError(
        "Failed to connect to hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState({
        stage: HarmonyStage.ERROR,
        message: error.message,
        progress: 1
      });
      Logger.error("Hub connection failed", error);
    }
  }, []);
  // Disconnect from hub
  const disconnect = useCallback(async () => {
    if (client) {
      try {
        await client.disconnect();
        setLoadingState({
          stage: HarmonyStage.INITIAL,
          message: "Disconnected",
          progress: 0
        });
      } catch (err) {
        const error = new HarmonyError(
          "Failed to disconnect",
          ErrorCategory.HUB_COMMUNICATION,
          err instanceof Error ? err : undefined
        );
        Logger.error("Hub disconnection failed", error);
      } finally {
        setClient(null);
        setSelectedHub(null);
        setDevices([]);
        setActivities([]);
        setCurrentActivity(null);
        setError(null);
      }
    }
  }, [client]);
  // Execute a command
  const executeCommand = useCallback(async (command: HarmonyCommand) => {
    if (!client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Sending command to hub", { command });
      setLoadingState({
        stage: HarmonyStage.EXECUTING_COMMAND,
        message: `Sending ${command.name}...`,
        progress: 0.5
      });
      await client.executeCommand(command);
      setLoadingState({
        stage: HarmonyStage.CONNECTED,
        message: "Command sent successfully",
        progress: 1
      });
    } catch (err) {
      const error = new HarmonyError(
        "Failed to execute command",
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState({
        stage: HarmonyStage.ERROR,
        message: error.message,
        progress: 1
      });
      throw error;
    }
  }, [client]);
  // Refresh hub state
  const refresh = useCallback(async () => {
    if (!client || !selectedHub) {
      return;
    }
    try {
      setError(null);
      setLoadingState({
        stage: HarmonyStage.REFRESHING,
        message: "Refreshing hub state...",
        progress: 0
      });
      const [hubDevices, hubActivities, current] = await Promise.all([
        client.getDevices(),
        client.getActivities(),
        client.getCurrentActivity()
      ]);
      setDevices(hubDevices);
      setActivities(hubActivities);
      setCurrentActivity(current);
      setLoadingState({
        stage: HarmonyStage.CONNECTED,
        message: "Refresh complete",
        progress: 1
      });
    } catch (err) {
      const error = new HarmonyError(
        "Failed to refresh hub state",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState({
        stage: HarmonyStage.ERROR,
        message: error.message,
        progress: 1
      });
      Logger.error("Hub refresh failed", error);
    }
  }, [client, selectedHub]);
  // Start an activity
  const startActivity = useCallback(async (activityId: string) => {
    if (!client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      setLoadingState({
        stage: HarmonyStage.STARTING_ACTIVITY,
        message: `Starting activity ${activityId}...`,
        progress: 0.5
      });
      await client.startActivity(activityId);
      setLoadingState({
        stage: HarmonyStage.CONNECTED,
        message: "Activity started successfully",
        progress: 1
      });
    } catch (err) {
      const error = new HarmonyError(
        "Failed to start activity",
        ErrorCategory.ACTIVITY_START,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState({
        stage: HarmonyStage.ERROR,
        message: error.message,
        progress: 1
      });
      throw error;
    }
  }, [client]);
  // Stop the current activity
  const stopActivity = useCallback(async () => {
    if (!client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      setLoadingState({
        stage: HarmonyStage.STOPPING_ACTIVITY,
        message: "Stopping activity...",
        progress: 0.5
      });
      await client.stopActivity();
      setLoadingState({
        stage: HarmonyStage.CONNECTED,
        message: "Activity stopped successfully",
        progress: 1
      });
    } catch (err) {
      const error = new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.ACTIVITY_STOP,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState({
        stage: HarmonyStage.ERROR,
        message: error.message,
        progress: 1
      });
      throw error;
    }
  }, [client]);
  // Clear cache and rediscover
  const clearCache = useCallback(async () => {
    await disconnect();
    await manager.clearCache();
    await discover();
  }, [disconnect, discover]);
  // Initial discovery
  useEffect(() => {
    discover();
    return () => {
      isDiscovering.current = false;
    };
  }, [discover]);
  return {
    hubs,
    selectedHub,
    devices,
    activities,
    currentActivity,
    error,
    loadingState,
    connect,
    disconnect,
    refresh,
    executeCommand,
    clearCache,
    startActivity,
    stopActivity,
  };
}
/**
 * Hook for accessing Harmony Hub functionality
 */
export function useHarmony(): HarmonyContextState {
  const context = useContext(HarmonyContext);
  if (!context) {
    throw new Error("useHarmony must be used within a HarmonyProvider");
  }
  return context;
}
</file>

<file path="src/services/harmony/commandQueue.ts">
import { HarmonyCommand, CommandRequest, CommandStatus, CommandResult, CommandQueueConfig } from "../../types/harmony";
import { HarmonyError, ErrorCategory } from "../../types/errors";
import { Logger } from "../logger";
const DEFAULT_CONFIG: Required<CommandQueueConfig> = {
  maxQueueSize: 100,
  maxConcurrent: 1,
  defaultTimeout: 5000,
  defaultRetries: 2,
  commandDelay: 100
};
export type CommandSender = (command: HarmonyCommand) => Promise<void>;
/**
 * Validates command queue configuration
 */
function validateConfig(config: Partial<CommandQueueConfig>): Required<CommandQueueConfig> {
  const result = { ...DEFAULT_CONFIG, ...config };
  // Validate numeric values are positive
  if (result.maxQueueSize <= 0) {
    throw new HarmonyError(
      "maxQueueSize must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (result.maxConcurrent <= 0) {
    throw new HarmonyError(
      "maxConcurrent must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (result.defaultTimeout <= 0) {
    throw new HarmonyError(
      "defaultTimeout must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (result.defaultRetries < 0) {
    throw new HarmonyError(
      "defaultRetries cannot be negative",
      ErrorCategory.VALIDATION
    );
  }
  if (result.commandDelay < 0) {
    throw new HarmonyError(
      "commandDelay cannot be negative",
      ErrorCategory.VALIDATION
    );
  }
  return result;
}
/**
 * Validates a command request
 */
function validateRequest(request: CommandRequest): void {
  if (!request.id) {
    throw new HarmonyError(
      "Command request must have an id",
      ErrorCategory.VALIDATION
    );
  }
  if (!request.command) {
    throw new HarmonyError(
      "Command request must have a command",
      ErrorCategory.VALIDATION
    );
  }
  if (!request.command.id || !request.command.deviceId) {
    throw new HarmonyError(
      "Command must have id and deviceId",
      ErrorCategory.VALIDATION
    );
  }
  if (request.timeout !== undefined && request.timeout <= 0) {
    throw new HarmonyError(
      "Command timeout must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (request.retries !== undefined && request.retries < 0) {
    throw new HarmonyError(
      "Command retries cannot be negative",
      ErrorCategory.VALIDATION
    );
  }
}
/**
 * Manages command execution queue for Harmony Hub
 */
export class CommandQueue {
  private queue: CommandRequest[] = [];
  private executing: Set<string> = new Set();
  private results: Map<string, CommandResult> = new Map();
  private config: Required<CommandQueueConfig>;
  private commandSender: CommandSender;
  constructor(
    commandSender: CommandSender,
    config?: Partial<CommandQueueConfig>
  ) {
    this.commandSender = commandSender;
    this.config = validateConfig(config || {});
  }
  /**
   * Add a command to the queue
   */
  public async enqueue(request: CommandRequest): Promise<CommandResult> {
    validateRequest(request);
    if (this.queue.length >= this.config.maxQueueSize) {
      throw new HarmonyError(
        `Command queue is full (max size: ${this.config.maxQueueSize})`,
        ErrorCategory.QUEUE
      );
    }
    const result: CommandResult = {
      id: request.id,
      command: request.command,
      status: CommandStatus.QUEUED,
      queuedAt: Date.now()
    };
    this.results.set(request.id, result);
    this.queue.push(request);
    this.processQueue();
    return result;
  }
  /**
   * Process the command queue
   */
  private async processQueue(): Promise<void> {
    if (this.queue.length === 0 || this.executing.size >= this.config.maxConcurrent) {
      return;
    }
    const request = this.queue.shift();
    if (!request) return;
    this.executing.add(request.id);
    const result = this.results.get(request.id);
    if (!result) {
      this.executing.delete(request.id);
      return;
    }
    result.status = CommandStatus.EXECUTING;
    result.startedAt = Date.now();
    try {
      await this.executeCommand(request);
      result.status = CommandStatus.COMPLETED;
      request.onComplete?.();
    } catch (error) {
      result.status = CommandStatus.FAILED;
      result.error = error instanceof Error ? error : new Error(String(error));
      request.onError?.(result.error);
    } finally {
      result.completedAt = Date.now();
      this.executing.delete(request.id);
      this.processQueue();
    }
  }
  /**
   * Execute a single command
   */
  private async executeCommand(request: CommandRequest): Promise<void> {
    const timeout = request.timeout ?? this.config.defaultTimeout;
    const maxRetries = request.retries ?? this.config.defaultRetries;
    let attempts = 0;
    while (attempts <= maxRetries) {
      try {
        Logger.debug(`Executing command (Attempt ${attempts + 1}/${maxRetries + 1})`, {
          command: request.command.name,
          deviceId: request.command.deviceId,
          timeout,
          remainingRetries: maxRetries - attempts
        });
        await Promise.race([
          this.sendCommand(request.command),
          new Promise((_, reject) => 
            setTimeout(() => reject(new HarmonyError(
              `Command execution timed out after ${timeout}ms`,
              ErrorCategory.COMMAND_EXECUTION
            )), timeout)
          )
        ]);
        return;
      } catch (error) {
        attempts++;
        if (attempts > maxRetries) {
          throw new HarmonyError(
            `Command failed after ${attempts} attempts`,
            ErrorCategory.COMMAND_EXECUTION,
            error instanceof Error ? error : undefined
          );
        }
        Logger.warn(`Command failed, retrying (${attempts}/${maxRetries})`, {
          command: request.command.name,
          deviceId: request.command.deviceId,
          error
        });
        await new Promise(resolve => 
          setTimeout(resolve, this.config.commandDelay)
        );
      }
    }
  }
  /**
   * Send command to the hub
   */
  private async sendCommand(command: HarmonyCommand): Promise<void> {
    try {
      await this.commandSender(command);
    } catch (error) {
      throw new HarmonyError(
        "Failed to send command to hub",
        ErrorCategory.HUB_COMMUNICATION,
        error instanceof Error ? error : undefined
      );
    }
  }
  /**
   * Get the result of a command
   */
  public getResult(commandId: string): CommandResult | undefined {
    return this.results.get(commandId);
  }
  /**
   * Clear completed commands from results
   */
  public clearCompleted(): void {
    for (const [id, result] of this.results.entries()) {
      if (result.status === CommandStatus.COMPLETED || 
          result.status === CommandStatus.FAILED ||
          result.status === CommandStatus.CANCELLED) {
        this.results.delete(id);
      }
    }
  }
  /**
   * Cancel all pending commands
   */
  public cancelAll(): void {
    this.queue.forEach(request => {
      const result = this.results.get(request.id);
      if (result) {
        result.status = CommandStatus.CANCELLED;
        result.completedAt = Date.now();
      }
    });
    this.queue = [];
  }
  /**
   * Get current queue status
   */
  public getStatus(): {
    queueLength: number;
    executing: number;
    completed: number;
    failed: number;
  } {
    let completed = 0;
    let failed = 0;
    for (const result of this.results.values()) {
      if (result.status === CommandStatus.COMPLETED) completed++;
      if (result.status === CommandStatus.FAILED) failed++;
    }
    return {
      queueLength: this.queue.length,
      executing: this.executing.size,
      completed,
      failed
    };
  }
}
</file>

<file path="src/services/harmony/harmonyClient.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity, HarmonyCommand } from "../../types/harmony";
import { HarmonyError, ErrorCategory } from "../../types/errors";
import { Logger } from "../logger";
import getHarmonyClient from "@harmonyhub/client-ws";
import { getPreferenceValues, LocalStorage } from "@raycast/api";
// Cache constants
const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours
interface CachedConfig {
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  timestamp: number;
}
interface HarmonyHubConfig {
  device: Array<{
    id: string;
    name: string;
    type: string;
    commands: Array<{
      name: string;
      label?: string;
      action?: {
        command?: {
          type?: string;
        };
      };
    }>;
  }>;
}
interface HarmonyHubActivity {
  id: string;
  label: string;
  type: string;
}
interface HarmonyHubCurrentActivity {
  id: string;
}
interface HarmonyCommandBody {
  command: string;
  deviceId: string;
  type: string;
}
interface CommandFunction {
  name: string;
  label?: string;
  action?: {
    command?: string;
  };
}
interface CommandGroup {
  name: string;
  function: CommandFunction[];
}
interface ControlGroup {
  name: string;
  function: CommandFunction[];
}
interface RawDevice {
  id: string;
  label?: string;
  type?: string;
  controlGroup: ControlGroup[];
}
interface RawConfig {
  device: RawDevice[];
}
export class HarmonyClient {
  private client: Awaited<ReturnType<typeof getHarmonyClient>> | null = null;
  private isConnected = false;
  public readonly hub: HarmonyHub;
  private cacheKey: string;
  constructor(hub: HarmonyHub) {
    this.hub = hub;
    this.cacheKey = `harmony-config-${hub.hubId}`;
  }
  /**
   * Connect to the Harmony Hub
   */
  public async connect(): Promise<void> {
    if (this.isConnected) {
      return;
    }
    try {
      Logger.info(`Connecting to hub ${this.hub.name} (${this.hub.ip})`);
      // Create client with remoteId if available for faster connection
      this.client = await getHarmonyClient(this.hub.ip);
      this.isConnected = true;
      Logger.info(`Connected to hub ${this.hub.name}`);
      // Setup disconnect handler
      this.client?.on("disconnected", () => {
        Logger.warn(`Disconnected from hub ${this.hub.name}`);
        this.isConnected = false;
      });
    } catch (err) {
      this.isConnected = false;
      throw new HarmonyError(
        `Failed to connect to hub ${this.hub.name}`,
        ErrorCategory.CONNECTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Get devices from the hub
   */
  public async getDevices(): Promise<HarmonyDevice[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.devices) {
        Logger.info("Using cached devices for hub", this.hub.name);
        return cached.devices;
      }
      // Get from hub if not cached
      const devices = await this.getDevicesFromHub();
      const mappedDevices = devices.map(device => ({
        id: device.id,
        name: device.name,
        type: device.type,
        commands: device.commands.map(command => ({
          id: command.name,
          name: command.name,
          label: command.label,
          deviceId: device.id,
          group: command.action?.command || "IRCommand"
        }))
      })) as HarmonyDevice[];
      // Cache the new devices along with current activities
      await this.updateConfigCache(mappedDevices, await this.getActivitiesFromHub());
      return mappedDevices;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
    }
  }
  private async getDevicesFromHub(): Promise<RawDevice[]> {
    if (!this.client) {
      throw new HarmonyError(
        "Client not initialized",
        ErrorCategory.CONNECTION
      );
    }
    try {
      Logger.info("Fetching devices from hub", this.hub.name);
      const rawConfig = await this.client.getAvailableCommands() as RawConfig;
      if (!rawConfig.device || rawConfig.device.length === 0) {
        Logger.warn("No devices found in hub config");
        return [];
      }
      Logger.info(`Found ${rawConfig.device.length} devices`);
      // Log raw config structure for first device
      if (rawConfig.device[0]) {
        Logger.info("First device raw config:", JSON.stringify(rawConfig.device[0], null, 2));
      }
      const devices = rawConfig.device?.map((d: RawDevice) => {
        Logger.info(`Processing device ${d.label || d.id}`);
        Logger.info(`Control groups:`, JSON.stringify(d.controlGroup, null, 2));
        const commands = d.controlGroup?.flatMap((group: ControlGroup) => {
          Logger.info(`Processing control group ${group.name} with ${group.function?.length || 0} functions`);
          return (group.function || []).map((fn: CommandFunction) => {
            Logger.info(`Processing function ${fn.name} with action:`, JSON.stringify(fn.action, null, 2));
            return {
              name: fn.name,
              label: fn.label || fn.name,
              action: fn.action
            };
          });
        }) || [];
        Logger.info(`Device ${d.label || d.id} has ${commands.length} commands`);
        return {
          id: d.id || "",
          name: d.label || "",
          type: d.type || "Unknown",
          commands: commands
        };
      }) || [];
      return devices;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err))
      );
    }
  }
  /**
   * Get activities from the hub
   */
  public async getActivities(): Promise<HarmonyActivity[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.activities) {
        Logger.info("Using cached activities for hub", this.hub.name);
        return cached.activities;
      }
      // Get from hub if not cached
      const activities = await this.getActivitiesFromHub();
      // Cache the new activities along with current devices
      await this.updateConfigCache(await this.getDevices(), activities);
      return activities;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get activities",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Get activities directly from hub
   */
  private async getActivitiesFromHub(): Promise<HarmonyActivity[]> {
    if (!this.client) {
      throw new HarmonyError(
        "Client not initialized",
        ErrorCategory.CONNECTION
      );
    }
    const activities = await this.client.getActivities() as HarmonyHubActivity[];
    return activities.map(activity => ({
      id: activity.id,
      name: activity.label,
      type: activity.type,
      isCurrent: false // Will be updated by current activity check
    }));
  }
  /**
   * Get current activity from hub
   */
  public async getCurrentActivity(): Promise<HarmonyActivity | null> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const rawActivity = await this.client.getCurrentActivity();
      if (!rawActivity) {
        return null;
      }
      // Convert raw activity string to proper type
      const currentActivityId = String(rawActivity);
      // Get all activities to find the current one
      const activities = await this.getActivities();
      const activity = activities.find(a => a.id === currentActivityId);
      if (!activity) {
        return null;
      }
      return {
        ...activity,
        isCurrent: true
      };
    } catch (err) {
      throw new HarmonyError(
        "Failed to get current activity",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err))
      );
    }
  }
  /**
   * Start an activity
   */
  public async startActivity(activityId: string): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Starting activity", { activityId });
      await this.client.startActivity(activityId);
      // Wait for activity to start and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const currentActivity = await this.getCurrentActivity();
        if (currentActivity?.id === activityId) {
          Logger.debug("Activity started successfully", { activityId });
          return;
        }
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to start");
    } catch (err) {
      throw new HarmonyError(
        `Failed to start activity ${activityId}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Stop the current activity
   */
  public async stopActivity(): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Stopping current activity");
      const currentActivity = await this.getCurrentActivity();
      if (!currentActivity) {
        Logger.debug("No activity running");
        return;
      }
      await this.client.turnOff();
      // Wait for activity to stop and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const activity = await this.getCurrentActivity();
        if (!activity) {
          Logger.debug("Activity stopped successfully");
          return;
        }
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to stop");
    } catch (err) {
      throw new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Clear cached config for this hub
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info(`Clearing cache for hub ${this.hub.name}`);
      await LocalStorage.removeItem(this.cacheKey);
    } catch (err) {
      throw new HarmonyError(
        "Failed to clear cache",
        ErrorCategory.CACHE,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Get cached config if available and not expired
   */
  private async getCachedConfig(): Promise<CachedConfig | null> {
    try {
      const cached = await LocalStorage.getItem<string>(this.cacheKey);
      if (!cached) {
        return null;
      }
      const config = JSON.parse(cached) as CachedConfig;
      // Check if cache is expired
      if (Date.now() - config.timestamp > CACHE_EXPIRY) {
        Logger.info("Config cache expired for hub", this.hub.name);
        await LocalStorage.removeItem(this.cacheKey);
        return null;
      }
      return config;
    } catch (err) {
      Logger.warn("Failed to get cached config:", err);
      return null;
    }
  }
  /**
   * Update the config cache with new devices and activities
   */
  private async updateConfigCache(devices: HarmonyDevice[], activities: HarmonyActivity[]): Promise<void> {
    try {
      const cache: CachedConfig = {
        devices,
        activities,
        timestamp: Date.now()
      };
      await LocalStorage.setItem(this.cacheKey, JSON.stringify(cache));
      Logger.info("Cached config for hub", this.hub.name);
    } catch (err) {
      Logger.warn("Failed to cache config:", err);
    }
  }
  /**
   * Execute a command
   */
  public async executeCommand(command: HarmonyCommand): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const preferences = getPreferenceValues<{ commandHoldTime: string }>();
      const holdTime = parseInt(preferences.commandHoldTime || "100", 10);
      Logger.debug("Sending command to hub", { command });
      const commandBody: HarmonyCommandBody = {
        command: command.id,
        deviceId: command.deviceId,
        type: command.group || "IRCommand"
      };
      Logger.debug("Command body:", commandBody);
      // Send press action
      await this.client.send("holdAction", commandBody);
      // Wait for hold time
      await new Promise(resolve => setTimeout(resolve, holdTime));
      // Send release action
      await this.client.send("releaseAction", commandBody);
    } catch (err) {
      throw new HarmonyError(
        `Failed to execute command ${command.name}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Disconnect from the hub
   */
  public async disconnect(): Promise<void> {
    try {
      if (this.client && this.isConnected) {
        await this.client.end();
        this.isConnected = false;
        this.client = null;
      }
    } catch (err) {
      throw new HarmonyError(
        "Failed to disconnect from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err))
      );
    }
  }
}
</file>

<file path="src/services/harmony/harmonyManager.ts">
import { Explorer } from "@harmonyhub/discover";
import { HarmonyHub } from "../../types/harmony";
import { Logger } from "../logger";
import { LocalStorage } from "@raycast/api";
import { HarmonyError, ErrorCategory } from "../../types/errors";
// Constants
const DISCOVERY_TIMEOUT = 5000; // Reduced from 10s to 5s
const DISCOVERY_COMPLETE_DELAY = 500; // Wait 500ms after finding a hub before completing
const CACHE_KEY = "harmony-hubs";
const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours
interface CachedHubs {
  hubs: HarmonyHub[];
  timestamp: number;
}
// Hub data from discovery event
interface HubDiscoveryData {
  uuid: string;
  ip: string;
  friendlyName: string;
  fullHubInfo: {
    hubId: string;
    productId: string;
    current_fw_version: string;
    protocolVersion: string;
    port: string;
    remoteId: string;
  };
}
export class HarmonyManager {
  private explorer: Explorer | null = null;
  private isDiscovering = false;
  private discoveryPromise: Promise<HarmonyHub[]> | null = null;
  private completeTimeout: NodeJS.Timeout | null = null;
  /**
   * Create a HarmonyHub instance from discovery data
   */
  private createHub(data: HubDiscoveryData): HarmonyHub {
    // Validate required fields
    if (!data.friendlyName || !data.ip || !data.uuid || !data.fullHubInfo?.hubId) {
      throw new HarmonyError(
        "Invalid hub data received",
        ErrorCategory.VALIDATION,
        new Error(`Missing required fields: ${JSON.stringify(data)}`)
      );
    }
    return {
      id: data.uuid,
      name: data.friendlyName,
      ip: data.ip,
      hubId: data.fullHubInfo.hubId,
      remoteId: data.fullHubInfo.remoteId,
      version: data.fullHubInfo.current_fw_version,
      port: data.fullHubInfo.port,
      productId: data.fullHubInfo.productId,
      protocolVersion: data.fullHubInfo.protocolVersion
    };
  }
  /**
   * Start discovery of Harmony Hubs on the network
   */
  public async startDiscovery(
    onProgress?: (progress: number, message: string) => void
  ): Promise<HarmonyHub[]> {
    // Check cache first
    try {
      const cached = await this.getCachedHubs();
      if (cached) {
        Logger.info("Using cached hubs");
        onProgress?.(1, `Found ${cached.length} cached hub(s)`);
        return cached;
      }
    } catch (error) {
      Logger.warn("Failed to read cache:", error);
      // Continue with discovery even if cache read fails
    }
    // If discovery is already in progress, return the existing promise
    if (this.discoveryPromise) {
      return this.discoveryPromise;
    }
    try {
      // Ensure cleanup of any previous explorer
      await this.cleanup();
      this.isDiscovering = true;
      onProgress?.(0, "Starting discovery process");
      this.explorer = new Explorer();
      // Create and store the discovery promise
      this.discoveryPromise = new Promise<HarmonyHub[]>((resolve, reject) => {
        if (!this.explorer) {
          reject(new HarmonyError("Explorer not initialized", ErrorCategory.STATE));
          return;
        }
        const hubs: HarmonyHub[] = [];
        // Function to complete discovery
        const completeDiscovery = async () => {
          await this.cleanup();
          if (hubs.length > 0) {
            await this.cacheHubs(hubs);
          }
          resolve(hubs);
        };
        // Set timeout to stop discovery after DISCOVERY_TIMEOUT
        const timeout = setTimeout(async () => {
          Logger.info("Discovery timeout");
          await completeDiscovery();
        }, DISCOVERY_TIMEOUT);
        this.explorer.on("online", (data: HubDiscoveryData) => {
          try {
            const hub = this.createHub(data);
            // Check for duplicate hubs
            if (!hubs.some(h => h.hubId === hub.hubId)) {
              hubs.push(hub);
              onProgress?.(0.5, `Found hub: ${hub.name}`);
              // Clear any existing completion timeout
              if (this.completeTimeout) {
                clearTimeout(this.completeTimeout);
              }
              // Set a new completion timeout
              this.completeTimeout = setTimeout(async () => {
                clearTimeout(timeout);
                await completeDiscovery();
              }, DISCOVERY_COMPLETE_DELAY);
            } else {
              Logger.info(`Skipping duplicate hub: ${hub.name}`);
            }
          } catch (error) {
            Logger.error("Failed to process hub data:", error);
            // Don't reject here, just log and continue discovery
          }
        });
        this.explorer.on("error", async (error: Error) => {
          Logger.error("Discovery error:", error);
          clearTimeout(timeout);
          if (this.completeTimeout) {
            clearTimeout(this.completeTimeout);
          }
          await this.cleanup();
          reject(new HarmonyError(
            "Hub discovery failed",
            ErrorCategory.HUB_COMMUNICATION,
            error
          ));
        });
        // Start discovery
        this.explorer.start();
      });
      // Return the discovery promise
      return await this.discoveryPromise;
    } catch (error) {
      Logger.error("Failed to start discovery:", error);
      throw new HarmonyError(
        "Failed to start hub discovery",
        ErrorCategory.HUB_COMMUNICATION,
        error as Error
      );
    } finally {
      this.isDiscovering = false;
      this.discoveryPromise = null;
    }
  }
  /**
   * Cache discovered hubs
   */
  private async cacheHubs(hubs: HarmonyHub[]): Promise<void> {
    try {
      const cache: CachedHubs = {
        hubs,
        timestamp: Date.now()
      };
      await LocalStorage.setItem(CACHE_KEY, JSON.stringify(cache));
      Logger.info(`Cached ${hubs.length} hubs`);
    } catch (error) {
      Logger.warn("Failed to cache hubs:", error);
      throw new HarmonyError(
        "Failed to cache hubs",
        ErrorCategory.STORAGE,
        error as Error
      );
    }
  }
  /**
   * Get cached hubs if available and not expired
   */
  private async getCachedHubs(): Promise<HarmonyHub[] | null> {
    try {
      const cached = await LocalStorage.getItem<string>(CACHE_KEY);
      if (!cached) return null;
      const { hubs, timestamp } = JSON.parse(cached) as CachedHubs;
      // Check if cache is expired
      if (Date.now() - timestamp > CACHE_TTL) {
        Logger.info("Cache expired");
        await LocalStorage.removeItem(CACHE_KEY);
        return null;
      }
      // Validate cached hub data
      for (const hub of hubs) {
        if (!hub.id || !hub.name || !hub.ip || !hub.hubId) {
          Logger.warn("Invalid hub data in cache, clearing cache");
          await LocalStorage.removeItem(CACHE_KEY);
          return null;
        }
      }
      return hubs;
    } catch (error) {
      Logger.warn("Failed to get cached hubs:", error);
      throw new HarmonyError(
        "Failed to read hub cache",
        ErrorCategory.STORAGE,
        error as Error
      );
    }
  }
  /**
   * Clean up discovery resources
   */
  public async cleanup(): Promise<void> {
    if (this.explorer) {
      try {
        this.explorer.stop();
        this.explorer.removeAllListeners();
      } catch (error) {
        Logger.error("Error stopping explorer:", error);
      }
      this.explorer = null;
    }
    if (this.completeTimeout) {
      clearTimeout(this.completeTimeout);
      this.completeTimeout = null;
    }
    this.isDiscovering = false;
    this.discoveryPromise = null;
  }
  /**
   * Clear all caches (hub discovery and configs)
   */
  public async clearAllCaches(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub discovery cache
      await this.clearCache();
      // Clear all hub config caches
      const keys = await LocalStorage.allItems();
      for (const key of Object.keys(keys)) {
        if (key.startsWith('harmony-config-')) {
          await LocalStorage.removeItem(key);
        }
      }
    } catch (err) {
      throw new HarmonyError(
        "Failed to clear caches",
        ErrorCategory.CACHE,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Clear all cached data
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub cache
      await LocalStorage.removeItem(CACHE_KEY);
      // Clear all hub-specific config caches
      const allKeys = await LocalStorage.allItems();
      for (const key of Object.keys(allKeys)) {
        if (key.startsWith('harmony-config-')) {
          await LocalStorage.removeItem(key);
        }
      }
      Logger.info("All caches cleared");
    } catch (error) {
      Logger.error("Failed to clear caches:", error);
      throw new HarmonyError(
        "Failed to clear caches",
        ErrorCategory.STORAGE,
        error as Error
      );
    }
  }
}
</file>

<file path="src/services/harmony/harmonyState.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "../../types/harmony";
/**
 * State machine stages for Harmony operations
 */
export enum HarmonyStage {
  DISCOVERING = "discovering",
  CONNECTING = "connecting",
  LOADING_ACTIVITIES = "loading-activities",
  LOADING_DEVICES = "loading-devices",
  COMPLETE = "complete",
}
/**
 * Loading state information
 */
export interface LoadingState {
  stage: HarmonyStage;
  progress: number;
  message: string;
}
/**
 * Core state for Harmony operations
 */
export interface HarmonyState {
  hubs: HarmonyHub[];
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  selectedHub: HarmonyHub | null;
  error: Error | null;
}
/**
 * Initial loading state
 */
export const initialLoadingState: LoadingState = {
  stage: HarmonyStage.DISCOVERING,
  progress: 0,
  message: "Initializing...",
};
/**
 * Initial harmony state
 */
export const initialHarmonyState: HarmonyState = {
  hubs: [],
  devices: [],
  activities: [],
  currentActivity: null,
  selectedHub: null,
  error: null,
};
</file>

<file path="src/services/errorHandler.ts">
import { showToast, Toast } from "@raycast/api";
import { Logger } from "../services/logger";
import { HarmonyError, ErrorCategory } from "../types/errors";
/**
 * ErrorHandler class for consistent error handling across the application.
 * Provides methods for handling errors, showing user feedback, and logging.
 */
export class ErrorHandler {
  /**
   * Handle any type of error, converting it to a HarmonyError if needed
   */
  static handle(error: Error | unknown, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error);
    // Log the error
    Logger.logError(harmonyError, context);
    // Show user feedback
    ErrorHandler.showErrorToast(harmonyError);
  }
  /**
   * Handle a specific error with a category
   */
  static handleWithCategory(error: Error | unknown, category: ErrorCategory, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error, category);
    // Log the error
    Logger.logError(harmonyError, context);
    // Show user feedback
    ErrorHandler.showErrorToast(harmonyError);
  }
  /**
   * Convert any error to a HarmonyError
   */
  private static toHarmonyError(error: Error | unknown, category?: ErrorCategory): HarmonyError {
    if (error instanceof HarmonyError) {
      return error;
    }
    const defaultCategory = category || ErrorCategory.UNKNOWN;
    const message = error instanceof Error ? error.message : String(error);
    const originalError = error instanceof Error ? error : undefined;
    return new HarmonyError(message, defaultCategory, originalError);
  }
  /**
   * Show an error toast to the user
   */
  private static showErrorToast(error: HarmonyError): void {
    const title = ErrorHandler.getCategoryTitle(error.category);
    showToast({
      style: Toast.Style.Failure,
      title,
      message: error.message,
    });
  }
  /**
   * Get a user-friendly title for an error category
   */
  private static getCategoryTitle(category: ErrorCategory): string {
    switch (category) {
      case ErrorCategory.NETWORK:
        return "Network Error";
      case ErrorCategory.STORAGE:
        return "Storage Error";
      case ErrorCategory.HARMONY:
        return "Harmony Hub Error";
      case ErrorCategory.VALIDATION:
        return "Validation Error";
      case ErrorCategory.WEBSOCKET:
        return "Connection Error";
      case ErrorCategory.COMMAND:
        return "Command Error";
      case ErrorCategory.AUTHENTICATION:
        return "Authentication Error";
      case ErrorCategory.SYSTEM:
        return "System Error";
      default:
        return "Error";
    }
  }
  /**
   * Handle an async operation with proper error handling
   */
  static async handleAsync<T>(
    operation: () => Promise<T>,
    context?: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handle(error, context);
      throw error;
    }
  }
  /**
   * Handle an async operation with a specific error category
   */
  static async handleAsyncWithCategory<T>(
    operation: () => Promise<T>,
    category: ErrorCategory,
    context?: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handleWithCategory(error, category, context);
      throw error;
    }
  }
}
</file>

<file path="src/services/localStorage.ts">
import { LocalStorage as RaycastLocalStorage } from "@raycast/api";
import { Logger } from "./logger";
export class LocalStorage {
  public static async getItem(key: string): Promise<string | null> {
    try {
      const value = await RaycastLocalStorage.getItem(key);
      return typeof value === 'string' ? value : null;
    } catch (error) {
      Logger.error(`Failed to get item from storage: ${key}`, error);
      return null;
    }
  }
  public static async setItem(key: string, value: string): Promise<void> {
    try {
      await RaycastLocalStorage.setItem(key, value);
    } catch (error) {
      Logger.error(`Failed to set item in storage: ${key}`, error);
      throw error;
    }
  }
  public static async removeItem(key: string): Promise<void> {
    try {
      await RaycastLocalStorage.removeItem(key);
    } catch (error) {
      Logger.error(`Failed to remove item from storage: ${key}`, error);
      throw error;
    }
  }
  public static async clear(): Promise<void> {
    try {
      await RaycastLocalStorage.clear();
    } catch (error) {
      Logger.error("Failed to clear storage", error);
      throw error;
    }
  }
}
</file>

<file path="src/services/logger.ts">
import { LogLevel, LogEntry, ILogger, LoggerOptions } from "../types/logging";
import { getPreferenceValues } from "@raycast/api";
interface Preferences {
  debugLogging: boolean;
}
/**
 * Logger implementation with static methods for application-wide logging.
 * Follows singleton pattern to ensure consistent logging across the application.
 */
export class Logger implements ILogger {
  private static instance: Logger | null = null;
  private readonly options: LoggerOptions;
  private logHistory: LogEntry[] = [];
  private constructor(options: Partial<LoggerOptions> = {}) {
    const prefs = getPreferenceValues<Preferences>();
    this.options = {
      minLevel: prefs.debugLogging ? LogLevel.DEBUG : LogLevel.INFO,
      maxEntries: options.maxEntries || 1000,
    };
  }
  /**
   * Get singleton instance of Logger
   */
  private static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  /**
   * Format a log message with timestamp and context
   */
  private static formatMessage(level: LogLevel, message: string, ...args: (string | number | boolean | object | null | undefined)[]): string {
    const timestamp = new Date().toISOString();
    const pid = process.pid;
    const formattedArgs = args.map(arg => 
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ');
    return `${timestamp} [pid:${pid}] ${level}: ${message} ${formattedArgs}`.trim();
  }
  /**
   * Format a log message with timestamp and context
   */
  private formatMessage(level: LogLevel, message: string, data?: unknown): LogEntry {
    const formattedMessage = Logger.formatMessage(
      level,
      message,
      data as string | number | boolean | object | null | undefined
    );
    const entry: LogEntry = {
      level,
      message: formattedMessage,
      timestamp: new Date().toISOString()
    };
    // Add to history and maintain max entries
    this.logHistory.push(entry);
    if (this.logHistory.length > this.options.maxEntries!) {
      this.logHistory.shift();
    }
    // Always output to console for development
    const levelStr = LogLevel[level].padEnd(5);
    console.log(formattedMessage);
    return entry;
  }
  /**
   * Log at DEBUG level
   */
  public debug(message: string, data?: unknown): void {
    if (this.options.minLevel! <= LogLevel.DEBUG) {
      const entry = this.formatMessage(LogLevel.DEBUG, message, data);
    }
  }
  /**
   * Log at INFO level
   */
  public info(message: string, data?: unknown): void {
    if (this.options.minLevel! <= LogLevel.INFO) {
      const entry = this.formatMessage(LogLevel.INFO, message, data);
      console.info(entry.message, entry.data || "");
    }
  }
  /**
   * Log at WARN level
   */
  public warn(message: string, data?: unknown): void {
    if (this.options.minLevel! <= LogLevel.WARN) {
      const entry = this.formatMessage(LogLevel.WARN, message, data);
      console.warn(entry.message, entry.data || "");
    }
  }
  /**
   * Log at ERROR level
   */
  public error(message: string, data?: unknown): void {
    if (this.options.minLevel! <= LogLevel.ERROR) {
      const entry = this.formatMessage(LogLevel.ERROR, message, data);
      console.error(entry.message, entry.data || "");
    }
  }
  /**
   * Log an error with stack trace
   */
  public logError(error: Error, context?: string): void {
    const message = context ? `${context}: ${error.message}` : error.message;
    const data = {
      name: error.name,
      stack: error.stack,
      error: error,
    };
    this.error(message, data);
  }
  /**
   * Get log history
   */
  public getHistory(): LogEntry[] {
    return this.logHistory;
  }
  /**
   * Clear log history
   */
  public clearHistory(): void {
    this.logHistory = [];
  }
  /**
   * Set minimum log level
   */
  public setMinLevel(level: LogLevel): void {
    this.options.minLevel = level;
  }
  // Static methods that delegate to instance methods
  public static debug(message: string, data?: unknown): void {
    Logger.getInstance().debug(message, data);
  }
  public static info(message: string, data?: unknown): void {
    Logger.getInstance().info(message, data);
  }
  public static warn(message: string, data?: unknown): void {
    Logger.getInstance().warn(message, data);
  }
  public static error(message: string, data?: unknown): void {
    Logger.getInstance().error(message, data);
  }
  public static logError(error: Error, context?: string): void {
    Logger.getInstance().logError(error, context);
  }
  public static getLogHistory(): LogEntry[] {
    return Logger.getInstance().getHistory();
  }
  public static clearLogHistory(): void {
    Logger.getInstance().clearHistory();
  }
  public static setLogLevel(level: LogLevel): void {
    Logger.getInstance().setMinLevel(level);
  }
}
</file>

<file path="src/services/secure-storage.ts">
// External dependencies
import { LocalStorage } from "@raycast/api";
import crypto from "crypto";
// Core services
import { ErrorHandler } from "./errorHandler";
import { ErrorCategory, HarmonyError } from "../types/errors";
import { HarmonyHub } from "../types/harmony";
import { Logger } from "./logger";
/**
 * Secure storage implementation for sensitive data.
 * Uses Raycast's LocalStorage with encryption for sensitive data.
 */
export class SecureStorage {
  private static instance: SecureStorage;
  private readonly ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || "default-key-32-chars-12345678901";
  private readonly ALGORITHM = "aes-256-cbc";
  private readonly errorHandler = new ErrorHandler();
  /**
   * Gets the singleton instance of SecureStorage.
   * @returns {SecureStorage} The singleton instance
   */
  public static getInstance(): SecureStorage {
    if (!SecureStorage.instance) {
      SecureStorage.instance = new SecureStorage();
    }
    return SecureStorage.instance;
  }
  /**
   * Stores a value securely.
   *
   * @param key - Storage key
   * @param value - Value to store
   * @returns Promise<void>
   * @throws {Error} If storage fails
   *
   * @example
   * ```typescript
   * await secureStorage.set("api_key", "secret_key_123");
   * ```
   */
  public async set(key: string, value: string): Promise<void> {
    try {
      const iv = crypto.randomBytes(16);
      const cipher = crypto.createCipheriv(this.ALGORITHM, Buffer.from(this.ENCRYPTION_KEY), iv);
      let encrypted = cipher.update(value);
      encrypted = Buffer.concat([encrypted, cipher.final()]);
      await LocalStorage.setItem(
        key,
        JSON.stringify({
          iv: iv.toString("hex"),
          data: encrypted.toString("hex"),
        }),
      );
      Logger.debug("Stored value in secure storage", { key });
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to store value in secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Retrieves a value from secure storage.
   *
   * @param key - Storage key
   * @returns Promise<string | null> The stored value or null if not found
   * @throws {Error} If retrieval fails
   *
   * @example
   * ```typescript
   * const value = await secureStorage.get("api_key");
   * ```
   */
  public async get(key: string): Promise<string | null> {
    try {
      const item = await LocalStorage.getItem(key);
      if (!item) return null;
      const parsedItem = JSON.parse(item as string);
      const { iv, data } = parsedItem;
      const decipher = crypto.createDecipheriv(
        this.ALGORITHM,
        Buffer.from(this.ENCRYPTION_KEY),
        Buffer.from(iv, "hex"),
      );
      let decrypted = decipher.update(Buffer.from(data, "hex"));
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      Logger.debug("Retrieved value from secure storage", { key });
      return decrypted.toString();
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to retrieve value from secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Removes a value from secure storage.
   *
   * @param key - Storage key
   * @returns Promise<void>
   * @throws {Error} If removal fails
   *
   * @example
   * ```typescript
   * await secureStorage.remove("api_key");
   * ```
   */
  public async remove(key: string): Promise<void> {
    try {
      await LocalStorage.removeItem(key);
      Logger.debug("Removed value from secure storage", { key });
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to remove value from secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Clears all values from secure storage.
   *
   * @returns Promise<void>
   * @throws {Error} If clear operation fails
   *
   * @example
   * ```typescript
   * await secureStorage.clear();
   * ```
   */
  public async clear(): Promise<void> {
    try {
      await LocalStorage.clear();
      Logger.debug("Cleared all secure storage");
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to clear secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Checks if a key exists in secure storage.
   *
   * @param key - Storage key
   * @returns Promise<boolean> True if the key exists
   * @throws {Error} If check fails
   *
   * @example
   * ```typescript
   * const exists = await secureStorage.has("api_key");
   * ```
   */
  public async has(key: string): Promise<boolean> {
    try {
      const item = await LocalStorage.getItem(key);
      Logger.debug("Checked key existence in secure storage", { key, exists: item !== null });
      return item !== null;
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to check key existence in secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Encrypts a value for storage.
   *
   * @param value - Value to encrypt
   * @returns Encrypted value
   */
  private encrypt(value: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.ALGORITHM, Buffer.from(this.ENCRYPTION_KEY), iv);
    let encrypted = cipher.update(value);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return JSON.stringify({
      iv: iv.toString("hex"),
      data: encrypted.toString("hex"),
    });
  }
  /**
   * Decrypts a stored value.
   *
   * @param value - Value to decrypt
   * @returns Decrypted value
   */
  private decrypt(value: string): string {
    const { iv, data } = JSON.parse(value);
    const decipher = crypto.createDecipheriv(this.ALGORITHM, Buffer.from(this.ENCRYPTION_KEY), Buffer.from(iv, "hex"));
    let decrypted = decipher.update(Buffer.from(data, "hex"));
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
  }
  /**
   * Retrieves Harmony Hub data from storage.
   *
   * @returns Promise<HarmonyHub | null> The stored Harmony Hub data or null if not found
   * @throws {Error} If retrieval fails
   */
  public static async getHubData(): Promise<HarmonyHub | null> {
    try {
      const hubData = await LocalStorage.getItem<string>("hubData");
      if (!hubData) {
        return null;
      }
      Logger.debug("Retrieved Harmony Hub data from storage");
      return JSON.parse(hubData) as HarmonyHub;
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to retrieve Harmony Hub data from storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
}
</file>

<file path="src/services/session-manager.ts">
import { LocalStorage } from "@raycast/api";
import { ToastManager } from "../ui/toast-manager";
/**
 * Interface representing a user session.
 */
interface Session {
  /**
   * The session token.
   */
  token: string;
  /**
   * The timestamp when the session expires.
   */
  expiresAt: number;
  /**
   * The timestamp of the last activity.
   */
  lastActivity: number;
}
/**
 * SessionManager class handles user session state and persistence.
 * It provides methods for storing and retrieving session data securely.
 */
export class SessionManager {
  /**
   * The key used to store the session in local storage.
   */
  private static readonly SESSION_KEY = "harmony_session";
  /**
   * The key used to store the cache in local storage.
   */
  private static readonly CACHE_KEY = "harmony_cache";
  /**
   * The key used to store the hub cache in local storage.
   */
  private static readonly HUB_CACHE_KEY = "harmony_hub_cache";
  /**
   * The duration of a session in milliseconds (24 hours).
   */
  private static readonly SESSION_DURATION = 24 * 60 * 60 * 1000;
  /**
   * The threshold for session inactivity in milliseconds (30 minutes).
   */
  private static readonly ACTIVITY_THRESHOLD = 30 * 60 * 1000;
  /**
   * Creates a new session with the given token.
   * @param token The session token.
   * @returns Promise<void>
   */
  static async createSession(token: string): Promise<void> {
    const session: Session = {
      token,
      expiresAt: Date.now() + this.SESSION_DURATION,
      lastActivity: Date.now(),
    };
    await LocalStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
  }
  /**
   * Retrieves the current session.
   * @returns Promise<Session | null> The current session or null if not found.
   */
  static async getSession(): Promise<Session | null> {
    try {
      const stored = await LocalStorage.getItem(this.SESSION_KEY);
      if (!stored || typeof stored !== "string") {
        return null;
      }
      const session = JSON.parse(stored) as Session;
      const now = Date.now();
      // Check if session has expired
      if (now > session.expiresAt) {
        await this.clearSession();
        return null;
      }
      // Check if session is inactive
      if (now - session.lastActivity > this.ACTIVITY_THRESHOLD) {
        await this.clearSession();
        return null;
      }
      // Update last activity
      session.lastActivity = now;
      await LocalStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
      return session;
    } catch (error) {
      console.error("Error getting session:", error);
      return null;
    }
  }
  /**
   * Clears the current session.
   * @returns Promise<void>
   */
  static async clearSession(): Promise<void> {
    await LocalStorage.removeItem(this.SESSION_KEY);
  }
  /**
   * Clears the cache.
   * @returns Promise<void>
   */
  static async clearCache(): Promise<void> {
    await Promise.all([LocalStorage.removeItem(this.CACHE_KEY), LocalStorage.removeItem(this.HUB_CACHE_KEY)]);
    ToastManager.success("Cache cleared successfully");
  }
  /**
   * Validates the current session.
   * @returns Promise<boolean> True if the session is valid, false otherwise.
   */
  static async validateSession(): Promise<boolean> {
    const session = await this.getSession();
    if (!session) {
      await ToastManager.error("Session Expired", "Please reconnect to your Hub");
      return false;
    }
    return true;
  }
}
</file>

<file path="src/types/components.ts">
/**
 * React component Props types.
 * @module
 */
import { Icon } from "@raycast/api";
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import { HarmonyError } from "./errors";
/**
 * Props for components that display feedback states (loading, error, empty)
 * @interface FeedbackStateProps
 */
export interface FeedbackStateProps {
  /**
   * Title text to display
   */
  title: string;
  /**
   * Optional description or details
   */
  description?: string;
  /**
   * Icon to display with the feedback
   */
  icon?: Icon;
  /**
   * Optional color for styling
   */
  color?: string;
  /**
   * Optional actions that can be taken from this state
   */
  actions?: React.ReactNode;
}
/**
 * Props for HarmonyCommand component
 * @interface HarmonyCommandProps
 */
export interface HarmonyCommandProps {
  /**
   * Command title
   */
  title: string;
  /**
   * Command subtitle
   */
  subtitle?: string;
  /**
   * Command icon
   */
  icon?: Icon;
  /**
   * Action to execute when command is selected
   */
  onAction: () => void | Promise<void>;
  /**
   * Whether the command is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
}
/**
 * Props for the DeviceList component
 * @interface DeviceListProps
 */
export interface DeviceListProps {
  /**
   * List of devices to display
   */
  devices: HarmonyDevice[];
  /**
   * Currently selected device
   */
  selectedDevice?: HarmonyDevice;
  /**
   * Action to execute when a device is selected
   */
  onDeviceSelect: (device: HarmonyDevice) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for device types
   */
  deviceType?: string;
  /**
   * Optional filter for specific device IDs
   */
  deviceIds?: string[];
  /**
   * Optional custom render function for device items
   */
  renderItem?: (device: HarmonyDevice) => React.ReactNode;
}
/**
 * Props for the ActivityList component
 * @interface ActivityListProps
 */
export interface ActivityListProps {
  /**
   * List of activities to display
   */
  activities: HarmonyActivity[];
  /**
   * Currently active activity
   */
  currentActivity?: HarmonyActivity;
  /**
   * Action to execute when an activity is selected
   */
  onActivitySelect: (activity: HarmonyActivity) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for activity types
   */
  activityType?: string;
  /**
   * Optional filter for specific activity IDs
   */
  activityIds?: string[];
  /**
   * Optional custom render function for activity items
   */
  renderItem?: (activity: HarmonyActivity) => React.ReactNode;
}
/**
 * Props for the HarmonyContext provider
 * @interface HarmonyContextProps
 */
export interface HarmonyContextProps {
  /**
   * Connected Harmony Hub instance
   */
  hub: HarmonyHub | null;
  /**
   * List of available devices
   */
  devices: HarmonyDevice[];
  /**
   * List of available activities
   */
  activities: HarmonyActivity[];
  /**
   * Currently running activity
   */
  currentActivity: HarmonyActivity | null;
  /**
   * Loading state indicator
   */
  isLoading: boolean;
  /**
   * Error state if any
   */
  error: Error | null;
  /**
   * Function to refresh hub connection
   */
  refresh: () => Promise<void>;
  /**
   * Function to execute device command
   */
  executeCommand: (deviceId: string, command: string) => Promise<void>;
  /**
   * Function to start activity
   */
  startActivity: (activityId: string) => Promise<void>;
}
/**
 * Props for the ErrorBoundary component
 * @interface ErrorBoundaryProps
 */
export interface ErrorBoundaryProps {
  /**
   * Child components to wrap with error boundary
   */
  children: React.ReactNode;
  /**
   * Optional custom error renderer
   */
  renderError?: (error: Error) => React.ReactNode;
  /**
   * Optional error handler callback
   */
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}
/**
 * Props for the ErrorDisplay component
 * @interface ErrorDisplayProps
 */
export interface ErrorDisplayProps {
  /**
   * Error to display
   */
  error: HarmonyError;
  /**
   * Action to execute when retry is clicked
   */
  onRetry?: () => void;
  /**
   * Action to execute when dismiss is clicked
   */
  onDismiss?: () => void;
}
/**
 * Props for the HubSelector component
 * @interface HubSelectorProps
 */
export interface HubSelectorProps {
  /** List of available Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Callback when a hub is selected */
  onHubSelect: (hub: HarmonyHub) => void;
  /** Whether the component is in a loading state */
  isLoading?: boolean;
  /** Error state if any */
  error?: HarmonyError;
}
/**
 * Props for the LoadingIndicator component
 * @interface LoadingIndicatorProps
 */
export interface LoadingIndicatorProps {
  /**
   * Loading message to display
   */
  message?: string;
  /**
   * Progress percentage (0-100)
   */
  progress?: number;
}
</file>

<file path="src/types/errors.ts">
/**
 * Error categories for Harmony Hub extension
 */
export enum ErrorCategory {
  /** Connection-related errors */
  CONNECTION = "connection",
  /** Hub discovery errors */
  DISCOVERY = "discovery",
  /** Command execution errors */
  COMMAND = "command",
  /** State management errors */
  STATE = "state",
  /** Data retrieval or parsing errors */
  DATA = "data",
  /** UI-related errors */
  UI = "ui",
  /** Network communication errors */
  NETWORK = "network",
  /** Storage operation errors */
  STORAGE = "storage",
  /** Harmony Hub specific errors */
  HARMONY = "harmony",
  /** Input validation errors */
  VALIDATION = "validation",
  /** WebSocket communication errors */
  WEBSOCKET = "websocket",
  /** Authentication errors */
  AUTHENTICATION = "authentication",
  /** System-level errors */
  SYSTEM = "system",
  /** Command queue errors */
  QUEUE = "queue",
  /** Command execution errors */
  COMMAND_EXECUTION = "command_execution",
  /** Hub communication errors */
  HUB_COMMUNICATION = "hub_communication",
  /** Configuration errors */
  CONFIG = "config",
  /** Resource cleanup errors */
  CLEANUP = "cleanup",
  /** Rate limiting errors */
  RATE_LIMIT = "rate_limit",
  /** Permission errors */
  PERMISSION = "permission",
  /** Cache-related errors */
  CACHE = "cache",
  /** Activity start errors */
  ACTIVITY_START = "activity_start",
  /** Activity stop errors */
  ACTIVITY_STOP = "activity_stop",
  /** Unknown or unclassified errors */
  UNKNOWN = "unknown"
}
/**
 * Error severity levels
 */
export enum ErrorSeverity {
  /** Informational messages that don't affect functionality */
  INFO = "info",
  /** Minor issues that don't affect core functionality */
  WARNING = "warning",
  /** Serious issues that affect core functionality */
  ERROR = "error",
  /** Critical issues that prevent the extension from working */
  CRITICAL = "critical"
}
/**
 * Error recovery action types
 */
export enum ErrorRecoveryAction {
  /** Retry the operation */
  RETRY = "retry",
  /** Reconnect to the hub */
  RECONNECT = "reconnect",
  /** Clear cache and retry */
  CLEAR_CACHE = "clear_cache",
  /** Reset configuration */
  RESET_CONFIG = "reset_config",
  /** Restart extension */
  RESTART = "restart",
  /** Manual user intervention required */
  MANUAL = "manual"
}
/**
 * Retry configuration for error handling
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Base delay between retries in milliseconds */
  baseDelay: number;
  /** Maximum delay between retries in milliseconds */
  maxDelay: number;
  /** Whether to use exponential backoff */
  useExponentialBackoff: boolean;
  /** Categories to never retry */
  nonRetryableCategories?: ErrorCategory[];
  /** Maximum total retry duration in milliseconds */
  maxRetryDuration?: number;
}
/**
 * Timeout configuration for operations
 */
export interface TimeoutConfig {
  /** Connection timeout in milliseconds */
  connection: number;
  /** Message timeout in milliseconds */
  message: number;
  /** Activity timeout in milliseconds */
  activity: number;
  /** Command timeout in milliseconds */
  command: number;
  /** Discovery timeout in milliseconds */
  discovery: number;
  /** Cache timeout in milliseconds */
  cache: number;
}
/**
 * Retry context for error handling
 */
export interface RetryContext {
  /** Number of retry attempts made */
  attempts: number;
  /** Time of first attempt */
  firstAttempt: number;
  /** Time of last attempt */
  lastAttempt: number;
  /** Next scheduled retry time */
  nextRetry: number | null;
  /** Whether maximum retries have been reached */
  maxRetriesReached: boolean;
  /** Total retry duration in milliseconds */
  totalDuration: number;
  /** Success rate of previous attempts */
  successRate?: number;
}
/**
 * Error recovery strategy
 */
export interface ErrorRecoveryStrategy {
  /** Actions to take for recovery */
  actions: ErrorRecoveryAction[];
  /** Order to try actions */
  priority: number;
  /** Whether to attempt recovery automatically */
  automatic: boolean;
  /** Maximum attempts for this strategy */
  maxAttempts: number;
  /** Delay between recovery attempts */
  delayBetweenAttempts: number;
}
/**
 * Custom error class for Harmony Hub extension
 */
export class HarmonyError extends Error {
  /** Error category */
  public readonly category: ErrorCategory;
  /** Error severity */
  public readonly severity: ErrorSeverity;
  /** Original error if any */
  public readonly originalError?: Error;
  /** Retry context if applicable */
  public readonly retryContext?: RetryContext;
  /** Whether the error is retryable */
  public readonly isRetryable: boolean;
  /** Error code if any */
  public readonly code?: string;
  /** Additional error details */
  public readonly details?: Record<string, unknown>;
  /** Recovery strategies */
  public readonly recoveryStrategies?: ErrorRecoveryStrategy[];
  /** Timestamp when error occurred */
  public readonly timestamp: number;
  constructor(
    message: string,
    category: ErrorCategory,
    originalError?: Error,
    retryContext?: RetryContext,
    isRetryable = true,
    code?: string,
    details?: Record<string, unknown>,
    severity: ErrorSeverity = ErrorSeverity.ERROR,
    recoveryStrategies?: ErrorRecoveryStrategy[]
  ) {
    super(message);
    this.name = "HarmonyError";
    this.category = category;
    this.severity = severity;
    this.originalError = originalError;
    this.retryContext = retryContext;
    this.isRetryable = isRetryable;
    this.code = code;
    this.details = details;
    this.recoveryStrategies = recoveryStrategies;
    this.timestamp = Date.now();
    // Maintain proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, HarmonyError);
    }
  }
  /**
   * Create a new error with updated retry context
   */
  public withRetryContext(retryContext: RetryContext): HarmonyError {
    return new HarmonyError(
      this.message,
      this.category,
      this.originalError,
      retryContext,
      this.isRetryable,
      this.code,
      this.details,
      this.severity,
      this.recoveryStrategies
    );
  }
  /**
   * Create a new error with updated recovery strategies
   */
  public withRecoveryStrategies(strategies: ErrorRecoveryStrategy[]): HarmonyError {
    return new HarmonyError(
      this.message,
      this.category,
      this.originalError,
      this.retryContext,
      this.isRetryable,
      this.code,
      this.details,
      this.severity,
      strategies
    );
  }
  /**
   * Check if error should be retried based on category and context
   */
  public shouldRetry(config: RetryConfig): boolean {
    if (!this.isRetryable) return false;
    if (!this.retryContext) return true;
    if (this.retryContext.maxRetriesReached) return false;
    // Don't retry if we've exceeded max attempts
    if (this.retryContext.attempts >= config.maxAttempts) return false;
    // Don't retry if we've exceeded max duration
    if (config.maxRetryDuration && this.retryContext.totalDuration >= config.maxRetryDuration) {
      return false;
    }
    // Don't retry certain error categories
    const nonRetryableCategories = config.nonRetryableCategories || [
      ErrorCategory.VALIDATION,
      ErrorCategory.AUTHENTICATION,
      ErrorCategory.PERMISSION
    ];
    if (nonRetryableCategories.includes(this.category)) return false;
    // Don't retry if success rate is too low
    if (this.retryContext.successRate !== undefined && this.retryContext.successRate < 0.2) {
      return false;
    }
    return true;
  }
  /**
   * Calculate next retry delay using exponential backoff
   */
  public getRetryDelay(config: RetryConfig): number {
    if (!this.retryContext) return config.baseDelay;
    const { attempts } = this.retryContext;
    const { baseDelay, maxDelay, useExponentialBackoff } = config;
    if (!useExponentialBackoff) return baseDelay;
    // Calculate delay with exponential backoff
    const delay = Math.min(
      baseDelay * Math.pow(2, attempts),
      maxDelay
    );
    // Add jitter to prevent thundering herd
    return delay * (0.5 + Math.random());
  }
  /**
   * Get recommended recovery strategy
   */
  public getRecoveryStrategy(): ErrorRecoveryStrategy | null {
    if (!this.recoveryStrategies || this.recoveryStrategies.length === 0) {
      return this.getDefaultRecoveryStrategy();
    }
    // Get highest priority strategy that hasn't exceeded max attempts
    return this.recoveryStrategies
      .sort((a, b) => a.priority - b.priority)
      .find(s => !this.retryContext || this.retryContext.attempts < s.maxAttempts) || null;
  }
  /**
   * Get default recovery strategy based on error category
   */
  private getDefaultRecoveryStrategy(): ErrorRecoveryStrategy | null {
    switch (this.category) {
      case ErrorCategory.CONNECTION:
      case ErrorCategory.WEBSOCKET:
        return {
          actions: [ErrorRecoveryAction.RECONNECT],
          priority: 1,
          automatic: true,
          maxAttempts: 3,
          delayBetweenAttempts: 1000
        };
      case ErrorCategory.CACHE:
        return {
          actions: [ErrorRecoveryAction.CLEAR_CACHE, ErrorRecoveryAction.RETRY],
          priority: 1,
          automatic: true,
          maxAttempts: 2,
          delayBetweenAttempts: 500
        };
      case ErrorCategory.CONFIG:
        return {
          actions: [ErrorRecoveryAction.RESET_CONFIG],
          priority: 2,
          automatic: false,
          maxAttempts: 1,
          delayBetweenAttempts: 0
        };
      case ErrorCategory.ACTIVITY_START:
      case ErrorCategory.ACTIVITY_STOP:
        return {
          actions: [ErrorRecoveryAction.RETRY],
          priority: 1,
          automatic: true,
          maxAttempts: 2,
          delayBetweenAttempts: 500
        };
      default:
        return null;
    }
  }
  /**
   * Get user-friendly error message
   */
  public getUserMessage(): string {
    const baseMessage = this.getBaseUserMessage();
    const recoveryMessage = this.recoveryMessage;
    return recoveryMessage ? `${baseMessage}\n\n${recoveryMessage}` : baseMessage;
  }
  /**
   * Get base user-friendly error message
   */
  private getBaseUserMessage(): string {
    switch (this.category) {
      case ErrorCategory.CONNECTION:
        return "Failed to connect to Harmony Hub. Please check your network connection and try again.";
      case ErrorCategory.DISCOVERY:
        return "Failed to discover Harmony Hubs. Please ensure your hub is powered on and connected to the network.";
      case ErrorCategory.COMMAND:
      case ErrorCategory.COMMAND_EXECUTION:
        return "Failed to execute command. Please try again.";
      case ErrorCategory.STATE:
        return "Failed to update state. Please try reconnecting to the hub.";
      case ErrorCategory.DATA:
        return "Failed to retrieve data from Harmony Hub. Please try again.";
      case ErrorCategory.VALIDATION:
        return "Invalid input provided. Please check your input and try again.";
      case ErrorCategory.AUTHENTICATION:
        return "Authentication failed. Please check your credentials and try again.";
      case ErrorCategory.PERMISSION:
        return "You don't have permission to perform this action.";
      case ErrorCategory.RATE_LIMIT:
        return "Too many requests. Please wait a moment and try again.";
      case ErrorCategory.CONFIG:
        return "Configuration error. Please check your settings.";
      case ErrorCategory.CACHE:
        return "Cache error. Trying to refresh data.";
      case ErrorCategory.CLEANUP:
        return "Failed to clean up resources. You may need to restart the extension.";
      case ErrorCategory.ACTIVITY_START:
        return "Failed to start activity. Please try again.";
      case ErrorCategory.ACTIVITY_STOP:
        return "Failed to stop activity. Please try again.";
      default:
        return this.message;
    }
  }
  public get recoveryMessage(): string | null {
    return this.getRecoveryMessage();
  }
  public getRecoveryMessage(): string | null {
    const strategy = this.getRecoveryStrategy();
    if (!strategy) return null;
    if (!strategy.automatic) {
      switch (strategy.actions[0]) {
        case ErrorRecoveryAction.RESET_CONFIG:
          return "Try resetting your configuration in the extension settings.";
        case ErrorRecoveryAction.RESTART:
          return "Please restart the extension to resolve this issue.";
        case ErrorRecoveryAction.MANUAL:
          return "Manual intervention is required. Please check the documentation.";
        default:
          return null;
      }
    }
    return null;
  }
}
</file>

<file path="src/types/harmony.ts">
/**
 * Types and interfaces for Harmony Hub integration.
 * @module
 */
/**
 * Represents a Logitech Harmony Hub device
 */
export interface HarmonyHub {
  /** Unique identifier for the hub */
  id: string;
  /** User-friendly name of the hub */
  name: string;
  /** Remote ID assigned by Harmony service */
  remoteId?: string;
  /** IP address of the hub on the local network */
  ip: string;
  /** Hub ID from Logitech service */
  hubId?: string;
  /** Version of the hub firmware */
  version?: string;
  /** Port number for hub communication */
  port?: string;
  /** Product ID of the hub */
  productId?: string;
  /** Protocol versions supported by the hub */
  protocolVersion?: string;
}
/**
 * Represents a device controlled by the Harmony Hub
 */
export interface HarmonyDevice {
  /** Unique identifier for the device */
  id: string;
  /** User-friendly name of the device */
  name: string;
  /** Type of device (e.g., TV, Receiver) */
  type: string;
  /** Available commands for this device */
  commands: HarmonyCommand[];
}
/**
 * Represents a command that can be sent to a device
 */
export interface HarmonyCommand {
  /** Command identifier */
  id: string;
  /** Command name */
  name: string;
  /** User-friendly label */
  label: string;
  /** ID of the device this command belongs to */
  deviceId: string;
  /** Optional command group for categorization */
  group?: string;
}
/**
 * Command queue configuration
 */
export interface CommandQueueConfig {
  /** Maximum number of commands that can be queued */
  maxQueueSize?: number;
  /** Maximum number of commands that can run concurrently */
  maxConcurrent?: number;
  /** Default timeout for command execution in milliseconds */
  defaultTimeout?: number;
  /** Default number of retries for failed commands */
  defaultRetries?: number;
  /** Delay between commands in milliseconds */
  commandDelay?: number;
}
/**
 * Represents an activity configured on the Harmony Hub
 */
export interface HarmonyActivity {
  /** Activity identifier */
  id: string;
  /** User-friendly name */
  name: string;
  /** Type of activity */
  type: string;
  /** Whether this is the current activity */
  isCurrent: boolean;
}
/**
 * Stage of the Harmony Hub connection process
 */
export enum HarmonyStage {
  /** Initial state */
  INITIAL = "initial",
  /** Discovering hubs */
  DISCOVERING = "discovering",
  /** Connecting to hub */
  CONNECTING = "connecting",
  /** Loading devices */
  LOADING_DEVICES = "loading_devices",
  /** Loading activities */
  LOADING_ACTIVITIES = "loading_activities",
  /** Starting activity */
  STARTING_ACTIVITY = "starting_activity",
  /** Stopping activity */
  STOPPING_ACTIVITY = "stopping_activity",
  /** Executing command */
  EXECUTING_COMMAND = "executing_command",
  /** Refreshing state */
  REFRESHING = "refreshing",
  /** Connected and ready */
  CONNECTED = "connected",
  /** Error state */
  ERROR = "error"
}
/**
 * Loading state information
 */
export interface LoadingState {
  /** Current stage of the process */
  stage: HarmonyStage;
  /** Progress from 0 to 1 */
  progress: number;
  /** User-friendly message */
  message: string;
}
/**
 * Current state of the Harmony Hub system
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Available devices */
  devices: HarmonyDevice[];
  /** Available activities */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Current error if any */
  error: Error | null;
  /** Current loading state */
  loadingState: LoadingState;
}
/**
 * Error categories for Harmony operations
 */
export enum ErrorCategory {
  /** Network or connectivity errors */
  CONNECTION = "connection",
  /** Hub discovery errors */
  DISCOVERY = "discovery",
  /** Command execution errors */
  COMMAND = "command",
  /** State management errors */
  STATE = "state",
  /** Data retrieval or parsing errors */
  DATA = "data"
}
import { WebSocket } from "ws";
/**
 * WebSocket message format from Harmony Hub
 */
export interface HarmonyMessage {
  type: string;
  data?: {
    id?: string;
    status?: string;
    errorCode?: string;
    errorMessage?: string;
    [key: string]: unknown;
  };
}
/**
 * Message handler type.
 */
export type MessageHandler = (message: HarmonyMessage) => void;
/**
 * Error handler type.
 */
export type ErrorHandler = (error: Error) => void;
/**
 * Hub discovery handler type.
 */
export type HubDiscoveryHandler = (hub: HarmonyHub) => void;
/**
 * Status of a command in the queue
 */
export enum CommandStatus {
  /** Command is queued for execution */
  QUEUED = "QUEUED",
  /** Command is pending execution */
  PENDING = "PENDING",
  /** Command is currently executing */
  EXECUTING = "EXECUTING",
  /** Command has completed successfully */
  COMPLETED = "COMPLETED",
  /** Command has failed */
  FAILED = "FAILED",
  /** Command was cancelled */
  CANCELLED = "CANCELLED"
}
/**
 * Command request for the queue
 */
export interface CommandRequest {
  /** Unique identifier for the command request */
  id: string;
  /** Command to execute */
  command: HarmonyCommand;
  /** Timestamp when the request was created */
  timestamp: number;
  /** Optional timeout in milliseconds */
  timeout?: number;
  /** Optional number of retries */
  retries?: number;
  /** Optional callback when command completes successfully */
  onComplete?: () => void;
  /** Optional callback when command fails */
  onError?: (error: Error) => void;
}
/**
 * Result of a command execution
 */
export interface CommandResult {
  /** Unique identifier matching the request */
  id: string;
  /** Command that was executed */
  command: HarmonyCommand;
  /** Current status of the command */
  status: CommandStatus;
  /** Error if command failed */
  error?: Error;
  /** When the command was queued */
  queuedAt: number;
  /** When the command started executing */
  startedAt?: number;
  /** When the command completed (success or failure) */
  completedAt?: number;
}
</file>

<file path="src/types/logging.ts">
/**
 * Log levels for application logging
 * @enum {number}
 */
export enum LogLevel {
  /** Debug level for detailed troubleshooting */
  DEBUG = 0,
  /** Info level for general operational messages */
  INFO = 1,
  /** Warning level for potentially problematic situations */
  WARN = 2,
  /** Error level for error conditions */
  ERROR = 3
}
/**
 * Interface for logger configuration options
 * @interface LoggerOptions
 */
export interface LoggerOptions {
  /** Minimum log level to record */
  minLevel?: LogLevel;
  /** Maximum number of log entries to keep in memory */
  maxEntries?: number;
  /** Whether to include timestamps in log entries */
  includeTimestamp?: boolean;
  /** Whether to include log level in entries */
  includeLevel?: boolean;
}
/**
 * Structure of a log entry
 * @interface LogEntry
 */
export interface LogEntry {
  /** ISO timestamp of when the entry was created */
  timestamp: string;
  /** Log level of the entry */
  level: LogLevel;
  /** Log message */
  message: string;
  /** Optional additional data */
  data?: unknown;
}
/**
 * Interface for logger implementations
 * @interface ILogger
 */
export interface ILogger {
  /**
   * Log a debug message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  debug(message: string, data?: unknown): void;
  /**
   * Log an info message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  info(message: string, data?: unknown): void;
  /**
   * Log a warning message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  warn(message: string, data?: unknown): void;
  /**
   * Log an error message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  error(message: string, data?: unknown): void;
  /**
   * Log an error with full stack trace
   * @param error - Error to log
   * @param context - Optional context information
   */
  logError(error: Error, context?: string): void;
  /**
   * Get log history
   */
  getHistory(): LogEntry[];
  /**
   * Clear log history
   */
  clearHistory(): void;
  /**
   * Set minimum log level
   */
  setMinLevel(level: LogLevel): void;
}
/**
 * Type for log entry filter functions
 * @type {LogFilter}
 */
export type LogFilter = (entry: LogEntry) => boolean;
/**
 * Type for log entry formatter functions
 * @type {LogFormatter}
 */
export type LogFormatter = (entry: LogEntry) => string;
</file>

<file path="src/types/preferences.ts">
/**
 * Preferences for the Harmony extension.
 */
export interface Preferences {
  /** The default view to display */
  defaultView: "activities" | "devices";
  /** The cache duration in seconds */
  cacheDuration: string;
  /** The network timeout in seconds */
  networkTimeout: string;
  /** Whether to enable debug mode */
  debugMode: boolean;
  /** Whether to auto-retry failed commands */
  autoRetry: boolean;
  /** The maximum number of retries */
  maxRetries: string;
  /** The duration to hold a command in milliseconds */
  commandHoldTime: string;
}
</file>

<file path="src/types/state.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import { HarmonyError } from "./errors";
/**
 * State machine states for Harmony Hub control
 * @enum {string}
 */
export enum MachineState {
  /** Initial state */
  IDLE = "IDLE",
  /** Discovering available hubs */
  DISCOVERING = "DISCOVERING",
  /** Connecting to a hub */
  CONNECTING = "CONNECTING",
  /** Connected to a hub */
  CONNECTED = "CONNECTED",
  /** Error state */
  ERROR = "ERROR",
}
/**
 * Context data for Harmony state machine
 * @interface MachineContext
 */
export interface MachineContext {
  /** List of available hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Available devices on the hub */
  devices: HarmonyDevice[];
  /** Available activities on the hub */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Error state if any */
  error: HarmonyError | null;
}
/**
 * Event payload for hub discovery
 * @interface DiscoverEvent
 */
export interface DiscoverEvent {
  type: "DISCOVER";
}
/**
 * Event payload for hub selection
 * @interface SelectHubEvent
 */
export interface SelectHubEvent {
  type: "SELECT_HUB";
  /** Hub to select */
  hub: HarmonyHub;
}
/**
 * Event payload for state refresh
 * @interface RefreshEvent
 */
export interface RefreshEvent {
  type: "REFRESH";
}
/**
 * Event payload for retrying a failed action
 * @interface RetryEvent
 */
export interface RetryEvent {
  type: "RETRY";
}
/**
 * Event payload for clearing the state
 * @interface ClearEvent
 */
export interface ClearEvent {
  type: "CLEAR";
}
/**
 * Event payload for hub disconnection
 * @interface DisconnectEvent
 */
export interface DisconnectEvent {
  type: "DISCONNECT";
}
/**
 * Event payload for error state
 * @interface ErrorEvent
 */
export interface ErrorEvent {
  type: "error.platform";
  /** Error that occurred */
  data: HarmonyError;
}
/**
 * Event payload for done discovering hubs
 * @interface DoneDiscoverEvent
 */
export interface DoneDiscoverEvent {
  type: "done.invoke.discoverHubs";
  /** List of discovered hubs */
  data: {
    hubs: HarmonyHub[];
  };
}
/**
 * Event payload for done loading hub data
 * @interface DoneLoadHubEvent
 */
export interface DoneLoadHubEvent {
  type: "done.invoke.loadHubData";
  /** Loaded hub data */
  data: {
    devices: HarmonyDevice[];
    activities: HarmonyActivity[];
  };
}
/**
 * Union type of all possible state machine events
 * @type {MachineEvent}
 */
export type MachineEvent =
  | DiscoverEvent
  | SelectHubEvent
  | DisconnectEvent
  | RefreshEvent
  | RetryEvent
  | ClearEvent
  | ErrorEvent
  | DoneDiscoverEvent
  | DoneLoadHubEvent;
/**
 * Service types for XState
 * @interface MachineServices
 */
export interface MachineServices {
  discoverHubs: {
    data: { hubs: HarmonyHub[] };
  };
  loadHubData: {
    data: { devices: HarmonyDevice[]; activities: HarmonyActivity[] };
  };
}
</file>

<file path="src/types/websocket.ts">
/**
 * WebSocket-related types for Harmony Hub communication.
 * @module
 */
import { HarmonyError } from "./errors";
import { HarmonyActivity, HarmonyDevice } from "./harmony";
/**
 * WebSocket connection status
 * @enum {string}
 */
export enum WebSocketConnectionStatus {
  /** The WebSocket connection is closed. */
  DISCONNECTED = "disconnected",
  /** The WebSocket connection is being established. */
  CONNECTING = "connecting",
  /** The WebSocket connection is established. */
  CONNECTED = "connected",
}
/**
 * WebSocket message types for Harmony Hub communication
 * @enum {string}
 */
export enum WebSocketMessageType {
  /** Request to start an activity */
  START_ACTIVITY = "startActivity",
  /** Request to stop an activity */
  STOP_ACTIVITY = "stopActivity",
  /** Request to get activities */
  GET_ACTIVITIES = "getactivities",
  /** Request to get devices */
  GET_DEVICES = "getdevices",
  /** Request to execute a command */
  EXECUTE_COMMAND = "executecommand",
}
/**
 * Base interface for all WebSocket messages
 * @interface WebSocketMessage
 */
export interface WebSocketMessage<T = unknown> {
  /** Type of the message */
  type: WebSocketMessageType;
  /** Payload of the message */
  payload: T;
}
/**
 * Payload for command execution requests
 * @interface CommandPayload
 */
export interface CommandPayload {
  /** Device to send command to */
  deviceId: string;
  /** Command to execute */
  command: string;
}
/**
 * Payload for activity control requests
 * @interface ActivityPayload
 */
export interface ActivityPayload {
  /** Activity to control */
  activityId: string;
  /** Optional timestamp */
  timestamp?: number;
  /** Optional status */
  status?: string;
}
/**
 * Union type of all possible WebSocket messages
 * @type {WebSocketMessageUnion}
 */
export type WebSocketMessageUnion =
  | WebSocketMessage<ActivityPayload>
  | WebSocketMessage<CommandPayload>
  | WebSocketMessage<Record<string, never>>;
/**
 * WebSocket response interface
 * @interface WebSocketResponse
 */
export interface WebSocketResponse<T> {
  /** Unique identifier for the response */
  id: string;
  /** Status of the response */
  status: "success" | "error";
  /** Optional response data */
  data?: T;
  /** Optional error information */
  error?: string;
}
/**
 * Activity response interface
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse extends WebSocketResponse<HarmonyActivity[]> {
  /** List of activities */
  activities: Array<{
    /** Activity ID */
    id: string;
    /** Activity name */
    name: string;
    /** Activity type */
    type: string;
    /** Whether this activity is currently active */
    isCurrent: boolean;
  }>;
}
/**
 * Device response interface
 * @interface DevicesResponse
 */
export interface DevicesResponse extends WebSocketResponse<HarmonyDevice[]> {
  /** List of devices */
  devices: Array<{
    /** Device ID */
    id: string;
    /** Device name */
    name: string;
    /** Device type */
    type: string;
    /** Device commands */
    commands: Array<{
      /** Command ID */
      id: string;
      /** Command name */
      name: string;
      /** Command label */
      label: string;
      /** Command group */
      group?: string;
    }>;
  }>;
}
/**
 * WebSocket event handler type
 * @type {WebSocketEventHandler}
 */
export type WebSocketEventHandler = (message: WebSocketMessageUnion) => void;
/**
 * WebSocket error handler type
 * @type {WebSocketErrorHandler}
 */
export type WebSocketErrorHandler = (error: Error) => void;
/**
 * Queued message interface
 * @interface QueuedMessage
 */
export interface QueuedMessage<T> {
  /** Unique identifier for the message */
  id: string;
  /** Resolve function for the message */
  resolve: (value: WebSocketResponse<T>) => void;
  /** Reject function for the message */
  reject: (error: Error) => void;
  /** Timestamp for the message */
  timestamp: number;
}
</file>

<file path="src/ui/toast-manager.ts">
import { showToast, Toast } from "@raycast/api";
export class ToastManager {
  static success(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  static error(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  static warning(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Failure, // Raycast doesn't have a warning style
      title,
      message,
    });
  }
  static loading(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
}
</file>

<file path="src/utils/validation.ts">
import { HarmonyError, ErrorCategory, RetryConfig, TimeoutConfig, ErrorSeverity } from "../types/errors";
import { HarmonyHub, HarmonyDevice, HarmonyActivity, CommandRequest, HarmonyCommand } from "../types/harmony";
import { Logger } from "../services/logger";
/**
 * Type guard for checking if a value is a non-empty string
 */
export function isNonEmptyString(value: unknown): value is string {
  return typeof value === "string" && value.trim().length > 0;
}
/**
 * Type guard for checking if a value is a positive number
 */
export function isPositiveNumber(value: unknown): value is number {
  return typeof value === "number" && !isNaN(value) && value > 0;
}
/**
 * Type guard for checking if a value is a valid port number
 */
export function isValidPort(value: unknown): value is number {
  return isPositiveNumber(value) && value <= 65535;
}
/**
 * Type guard for checking if a value is a valid IP address
 */
export function isValidIpAddress(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipv4Regex.test(value)) return false;
  return value.split(".").every(num => {
    const n = parseInt(num, 10);
    return n >= 0 && n <= 255;
  });
}
/**
 * Type guard for checking if a value is a valid command group
 */
export function isValidCommandGroup(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const validGroups = ["IRCommand", "HTTPCommand", "BluetoothCommand", "WifiCommand"];
  return validGroups.includes(value);
}
/**
 * Validate Harmony Hub configuration
 */
export function validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub {
  if (!isNonEmptyString(hub.id)) {
    throw new HarmonyError(
      "Hub ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_ID"
    );
  }
  if (!isNonEmptyString(hub.name)) {
    throw new HarmonyError(
      "Hub name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_NAME"
    );
  }
  if (!isValidIpAddress(hub.ip)) {
    throw new HarmonyError(
      "Invalid hub IP address",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_IP"
    );
  }
  if (hub.port !== undefined && !isValidPort(hub.port)) {
    throw new HarmonyError(
      "Invalid hub port",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_PORT"
    );
  }
  Logger.debug("Hub config validation passed", { hub });
}
/**
 * Validate Harmony device configuration
 */
export function validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice {
  if (!isNonEmptyString(device.id)) {
    throw new HarmonyError(
      "Device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_ID"
    );
  }
  if (!isNonEmptyString(device.name)) {
    throw new HarmonyError(
      "Device name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_NAME"
    );
  }
  if (!isNonEmptyString(device.type)) {
    throw new HarmonyError(
      "Device type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_TYPE"
    );
  }
  if (!Array.isArray(device.commands)) {
    throw new HarmonyError(
      "Device commands must be an array",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMANDS_ARRAY"
    );
  }
  device.commands.forEach((command, index) => {
    if (!isNonEmptyString(command.id)) {
      throw new HarmonyError(
        `Invalid command ID at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_ID"
      );
    }
    if (!isNonEmptyString(command.name)) {
      throw new HarmonyError(
        `Invalid command name at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_NAME"
      );
    }
    if (!isNonEmptyString(command.deviceId)) {
      throw new HarmonyError(
        `Invalid device ID for command at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_DEVICE_ID"
      );
    }
    if (command.group && !isValidCommandGroup(command.group)) {
      throw new HarmonyError(
        `Invalid command group at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_GROUP"
      );
    }
  });
  Logger.debug("Device validation passed", { device });
}
/**
 * Validate Harmony activity configuration
 */
export function validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity {
  if (!isNonEmptyString(activity.id)) {
    throw new HarmonyError(
      "Activity ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_ID"
    );
  }
  if (!isNonEmptyString(activity.name)) {
    throw new HarmonyError(
      "Activity name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_NAME"
    );
  }
  if (!isNonEmptyString(activity.type)) {
    throw new HarmonyError(
      "Activity type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_TYPE"
    );
  }
  if (typeof activity.isCurrent !== "boolean") {
    throw new HarmonyError(
      "Activity current status must be a boolean",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_STATUS"
    );
  }
  Logger.debug("Activity validation passed", { activity });
}
/**
 * Validate command request
 */
export function validateCommandRequest(request: Partial<CommandRequest>): asserts request is CommandRequest {
  if (!request) {
    throw new HarmonyError(
      "Command request is required",
      ErrorCategory.VALIDATION
    );
  }
  if (!request.command || !isNonEmptyString(request.command.deviceId)) {
    throw new HarmonyError(
      "Command request must include deviceId",
      ErrorCategory.VALIDATION
    );
  }
  if (!isNonEmptyString(request.command.name)) {
    throw new HarmonyError(
      "Command request must include command name",
      ErrorCategory.VALIDATION
    );
  }
}
/**
 * Validate retry configuration
 */
export function validateRetryConfig(config: Partial<RetryConfig>): asserts config is RetryConfig {
  if (!isPositiveNumber(config.maxAttempts)) {
    throw new HarmonyError(
      "Maximum retry attempts must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_MAX_ATTEMPTS"
    );
  }
  if (!isPositiveNumber(config.baseDelay)) {
    throw new HarmonyError(
      "Base retry delay must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_BASE_DELAY"
    );
  }
  if (!isPositiveNumber(config.maxDelay)) {
    throw new HarmonyError(
      "Maximum retry delay must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_MAX_DELAY"
    );
  }
  if (typeof config.useExponentialBackoff !== "boolean") {
    throw new HarmonyError(
      "Use exponential backoff must be a boolean",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_BACKOFF"
    );
  }
  if (config.maxRetryDuration !== undefined && !isPositiveNumber(config.maxRetryDuration)) {
    throw new HarmonyError(
      "Maximum retry duration must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_DURATION"
    );
  }
  Logger.debug("Retry config validation passed", { config });
}
/**
 * Validate timeout configuration
 */
export function validateTimeoutConfig(config: Partial<TimeoutConfig>): asserts config is TimeoutConfig {
  if (!isPositiveNumber(config.connection)) {
    throw new HarmonyError(
      "Connection timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_CONNECTION"
    );
  }
  if (!isPositiveNumber(config.message)) {
    throw new HarmonyError(
      "Message timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_MESSAGE"
    );
  }
  if (!isPositiveNumber(config.activity)) {
    throw new HarmonyError(
      "Activity timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_ACTIVITY"
    );
  }
  if (!isPositiveNumber(config.command)) {
    throw new HarmonyError(
      "Command timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_COMMAND"
    );
  }
  if (!isPositiveNumber(config.discovery)) {
    throw new HarmonyError(
      "Discovery timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_DISCOVERY"
    );
  }
  if (!isPositiveNumber(config.cache)) {
    throw new HarmonyError(
      "Cache timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_CACHE"
    );
  }
  Logger.debug("Timeout config validation passed", { config });
}
/**
 * Validate Harmony command
 */
export function validateCommand(command: Partial<HarmonyCommand>): asserts command is HarmonyCommand {
  if (!isNonEmptyString(command.id)) {
    throw new HarmonyError(
      "Command ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_ID"
    );
  }
  if (!isNonEmptyString(command.name)) {
    throw new HarmonyError(
      "Command name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_NAME"
    );
  }
  if (!isNonEmptyString(command.deviceId)) {
    throw new HarmonyError(
      "Device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_DEVICE_ID"
    );
  }
  if (command.group && !isValidCommandGroup(command.group)) {
    throw new HarmonyError(
      "Invalid command group",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_GROUP"
    );
  }
  Logger.debug("Command validation passed", { command });
}
</file>

<file path="src/control.tsx">
import React from "react";
import { HarmonyCommand } from "./components/HarmonyCommand";
import { HarmonyProvider } from "./hooks/useHarmony";
export default function Command(): React.ReactElement {
  return (
    <HarmonyProvider>
      <HarmonyCommand />
    </HarmonyProvider>
  );
}
</file>

<file path=".eslintrc.json">
{
  "extends": ["@raycast/eslint-config"],
  "plugins": ["import"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "import/order": [
      "error",
      {
        "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
        "newlines-between": "always",
        "alphabetize": {
          "order": "asc",
          "caseInsensitive": true
        }
      }
    ],
    "@typescript-eslint/explicit-function-return-type": [
      "error",
      {
        "allowExpressions": true,
        "allowTypedFunctionExpressions": true
      }
    ]
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# Raycast specific files
raycast-env.d.ts
.raycast-swift-build
.swiftpm
compiled_raycast_swift

# Windsurf files
.windsurfrules
global_rules.md

# misc
.DS_Store

# Project planning
.Plan
</file>

<file path=".prettierrc">
{
  "printWidth": 120,
  "singleQuote": false
}
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to the Harmony Control extension will be documented in this file.

## [1.0.0] - 2025-02-07

### Added
- Initial release of Harmony Control extension
- Automatic hub discovery on local network
- Device control with command execution
- Activity management (start/stop)
- Local caching of hub configuration
- Secure credential storage
- Error handling and recovery
- Configurable preferences:
  - Default view (Activities/Devices)
  - Command hold time
  - Cache duration
  - Network timeout
  - Debug mode
  - Auto retry settings

### Technical Improvements
- TypeScript strict mode compliance
- Proper error categorization and handling
- WebSocket connection management
- Performance optimizations with caching
- Secure storage implementation

### Documentation
- Comprehensive README with setup guide
- API documentation
- Troubleshooting guide
- Screenshots of key features
</file>

<file path="package.json">
{
  "$schema": "https://www.raycast.com/schemas/extension.json",
  "name": "harmony-control",
  "version": "1.0.0",
  "title": "Harmony Control",
  "description": "Control your Logitech Harmony Hub devices",
  "icon": "command-icon.png",
  "author": "chad_walters",
  "categories": [
    "Media",
    "System"
  ],
  "license": "MIT",
  "commands": [
    {
      "name": "control",
      "title": "Control Harmony Hub",
      "description": "Control your Harmony Hub devices and activities",
      "mode": "view"
    }
  ],
  "preferences": [
    {
      "name": "defaultView",
      "type": "dropdown",
      "required": false,
      "title": "Default View",
      "description": "Choose whether to show Activities or Devices by default",
      "default": "activities",
      "data": [
        {
          "title": "Activities",
          "value": "activities"
        },
        {
          "title": "Devices",
          "value": "devices"
        }
      ]
    },
    {
      "name": "commandHoldTime",
      "type": "textfield",
      "required": false,
      "title": "Command Hold Time",
      "description": "Duration to hold a command in milliseconds",
      "default": "100"
    },
    {
      "name": "cacheDuration",
      "type": "textfield",
      "required": false,
      "title": "Cache Duration",
      "description": "Duration to cache hub data in seconds (default: 3600 = 1 hour)",
      "default": "3600"
    },
    {
      "name": "debugLogging",
      "type": "checkbox",
      "required": false,
      "title": "Debug Logging",
      "description": "Enable debug level logging",
      "default": true
    },
    {
      "name": "networkTimeout",
      "type": "textfield",
      "required": false,
      "title": "Network Timeout",
      "description": "Network request timeout (in milliseconds)",
      "default": "5000"
    },
    {
      "name": "debugMode",
      "type": "checkbox",
      "required": false,
      "title": "Debug Mode",
      "description": "Enable debug logging",
      "default": true,
      "label": "Enable Debug Mode"
    },
    {
      "name": "autoRetry",
      "type": "checkbox",
      "required": false,
      "title": "Auto Retry",
      "description": "Automatically retry failed operations",
      "default": true,
      "label": "Enable Auto Retry"
    },
    {
      "name": "maxRetries",
      "type": "textfield",
      "required": false,
      "title": "Max Retries",
      "description": "Maximum number of retry attempts",
      "default": "3"
    }
  ],
  "dependencies": {
    "@harmonyhub/client-ws": "^1.0.9",
    "@harmonyhub/discover": "^1.0.9",
    "@raycast/api": "^1.91.1",
    "@raycast/utils": "^1.10.1",
    "node-machine-id": "^1.1.12",
    "uuid": "^9.0.1",
    "ws": "^8.16.0",
    "xstate": "^5.19.2"
  },
  "devDependencies": {
    "@raycast/eslint-config": "^1.0.6",
    "@types/node": "^20.8.10",
    "@types/react": "^18.2.27",
    "@types/uuid": "^9.0.7",
    "@types/ws": "^8.5.14",
    "eslint": "^8.51.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "scripts": {
    "build": "ray build -e dist",
    "dev": "ray develop",
    "fix-lint": "ray lint --fix",
    "lint": "ray lint",
    "publish": "npx @raycast/api@latest publish"
  }
}
</file>

<file path="README.md">
# Harmony Control for Raycast

Control your Logitech Harmony Hub devices directly from Raycast with a modern, efficient interface.

![Harmony Control](metadata/harmony-control-1.png)

## Features

- 🔍 **Smart Hub Discovery**: Automatic hub detection on your local network
- 📱 **Universal Control**: Manage all your Harmony devices and activities
- ⚡️ **Quick Commands**: Fast command execution with intelligent caching
- 🎯 **Efficient Navigation**: Keyboard shortcuts for quick access
- 🔄 **Reliable Connection**: Automatic reconnection and error recovery
- 🔒 **Secure Storage**: Safe storage of hub configurations
- 💨 **Performance**: Optimized for speed with command queuing and state caching

## Requirements

- Logitech Harmony Hub connected to your local network
- macOS 11.0 or later
- Raycast v1.50.0 or later
- Network allowing local device discovery (ports 35000-35004)

## Installation

1. Open Raycast
2. Search for "Harmony Control"
3. Click Install

## Usage

### First Launch

1. Launch with `⌘ Space` and type "Harmony"
2. Wait for automatic hub discovery (usually takes 15-30 seconds)
3. Select your hub when found
4. Start controlling your devices!

### Key Features

#### Device Control
- Browse and control all your Harmony-configured devices
- Execute device-specific commands (power, volume, inputs, etc.)
- Quick access to frequently used commands

#### Activity Management
- Start and stop Harmony activities
- View current activity status
- Quick switching between activities

#### Smart Navigation
- `⌘ ⇧ A`: Switch to Activities view
- `⌘ ⇧ D`: Switch to Devices view
- `⌘ ⏎`: Execute selected command
- `⌘ B`: Go back to device list

### Preferences

Configure the extension in Raycast preferences:

#### View Settings
- **Default View**: Choose between 'activities' or 'devices' as your starting view
- **List Style**: Configure how devices and commands are displayed

#### Performance
- **Cache Duration**: Control how long device data is cached
- **Command Queue**: Adjust command execution timing
- **Network Timeout**: Set timeouts for network operations

#### Debug Options
- **Debug Mode**: Enable detailed logging for troubleshooting
- **Auto Retry**: Configure automatic retry behavior for failed commands

## Troubleshooting

### Hub Discovery Issues

If your hub isn't found automatically:
1. Verify the hub is powered on and connected to your network
2. Check that your Mac and hub are on the same network
3. Ensure ports 35000-35004 are not blocked by your firewall
4. Try restarting your Harmony Hub

### Connection Problems

If you experience connection issues:
1. Check your network connectivity
2. Verify the hub's IP hasn't changed
3. Try clearing the extension's cache
4. Restart the extension

### Command Execution Failures

If commands aren't working:
1. Ensure the target device is powered on
2. Check if the hub has line of sight to the device
3. Verify the command is supported by your device
4. Try restarting the current activity

## Technical Details

The extension uses a modern TypeScript/React architecture with:
- WebSocket-based communication for reliable control
- Intelligent command queuing for consistent execution
- Local state caching for improved performance
- Comprehensive error handling and recovery
- Secure storage for hub configurations

For detailed technical information, see [Architecture Documentation](docs/architecture.md).

## Support

If you encounter issues:
1. Check the [Troubleshooting Guide](#troubleshooting)
2. Enable debug mode in preferences for detailed logs
3. File an issue on GitHub with logs and steps to reproduce

## Contributing

Contributions are welcome! Please read our contributing guidelines and code of conduct before submitting pull requests.

## License

MIT License - see LICENSE file for details
</file>

<file path="tsconfig.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Node 16",
  "include": ["src/**/*", "raycast-env.d.ts"],
  "compilerOptions": {
    "lib": ["es2021"],
    "module": "commonjs",
    "target": "es2021",
    "strict": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "noEmit": false,
    "outDir": "dist"
  }
}
</file>

</files>
