This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-19T16:32:12.526Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docs/
  API.md
  Errors.md
src/
  hooks/
    useActivityFiltering.ts
    useCommandExecution.ts
    useHarmony.ts
  services/
    harmony/
      harmonyClient.ts
      harmonyManager.ts
      harmonyState.ts
    errorHandler.ts
    localStorage.ts
    logger.ts
    toast.ts
  stores/
    harmony.ts
    view.ts
  types/
    core/
      command.ts
      errors.ts
      harmony.ts
      index.ts
      logging.ts
      state-mutable.ts
      state.ts
      validation.ts
      views.ts
      websocket.ts
    components.ts
    preferences.ts
  ui/
    components/
      actions/
        ActivityActionPanel.tsx
      views/
        ActivitiesView.tsx
        CommandsView.tsx
        DevicesView.tsx
        HarmonyCommand.tsx
        HubsView.tsx
  utils/
    state.ts
    validation.ts
  control.tsx
.cursorrules
.eslintrc.json
.gitignore
.prettierrc
CHANGELOG.md
package.json
Plan.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/API.md">
# Harmony Extension API Documentation

## Core Services

### HarmonyClient

Primary service for communicating with a Harmony Hub.

```typescript
class HarmonyClient {
  constructor(hub: HarmonyHub);
  
  async connect(): Promise<void>;
  async disconnect(): Promise<void>;
  async getDevices(): Promise<HarmonyDevice[]>;
  async getActivities(): Promise<HarmonyActivity[]>;
  async getCurrentActivity(): Promise<HarmonyActivity | null>;
  async startActivity(activityId: string): Promise<void>;
  async stopActivity(): Promise<void>;
  async executeCommand(command: HarmonyCommand): Promise<void>;
  async clearCache(): Promise<void>;
}
```

### HarmonyManager

Service for discovering and managing Harmony Hubs.

```typescript
class HarmonyManager {
  async startDiscovery(onProgress?: (progress: number, message: string) => void): Promise<HarmonyHub[]>;
  async cleanup(): Promise<void>;
  async clearCache(): Promise<void>;
  async clearAllCaches(): Promise<void>;
}
```

### ErrorHandler

Centralized error handling service.

```typescript
class ErrorHandler {
  static configure(config: Partial<ErrorHandlerConfig>): void;
  static handle(error: Error | unknown, context?: string): void;
  static handleWithCategory(error: Error | unknown, category: ErrorCategory, context?: string): void;
  static handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T>;
  static handleAsyncWithCategory<T>(operation: () => Promise<T>, category: ErrorCategory, context?: string): Promise<T>;
}
```

## Hooks

### useHarmony

Primary hook for Harmony Hub interaction.

```typescript
function useHarmony(): {
  hubs: HarmonyHub[];
  selectedHub: HarmonyHub | null;
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  loadingState: LoadingState | null;
  error: HarmonyError | null;
  connect: (hub: HarmonyHub) => Promise<void>;
  refresh: () => Promise<void>;
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  startActivity: (activityId: string) => Promise<void>;
  stopActivity: () => Promise<void>;
  clearCache: () => Promise<void>;
};
```

### useActivityFiltering

Hook for filtering and managing activities.

```typescript
function useActivityFiltering(activities: HarmonyActivity[]): {
  filteredActivities: HarmonyActivity[];
  activityGroups: Map<string, HarmonyActivity[]>;
  filterActivities: (query: string) => void;
  getActivityStatus: (activity: HarmonyActivity) => ActivityStatus;
};
```

### useDeviceFiltering

Hook for filtering and managing devices.

```typescript
function useDeviceFiltering(devices: HarmonyDevice[]): {
  filteredDevices: HarmonyDevice[];
  deviceGroups: Map<string, HarmonyDevice[]>;
  filterDevices: (query: string) => void;
  getDeviceCommands: (device: HarmonyDevice) => HarmonyCommand[];
};
```

### useCommandExecution

Hook for executing commands with retry logic.

```typescript
function useCommandExecution(): {
  executeCommand: (command: HarmonyCommand, retryOptions?: RetryOptions) => Promise<void>;
  isExecuting: boolean;
  error: HarmonyError | null;
};
```

## Core Types

### HarmonyHub

```typescript
interface HarmonyHub {
  readonly id: string;
  readonly name: string;
  readonly ip: string;
  readonly hubId: string;
  readonly remoteId?: string;
  readonly version?: string;
  readonly port?: string;
  readonly productId?: string;
  readonly protocolVersion?: string;
}
```

### HarmonyDevice

```typescript
interface HarmonyDevice {
  readonly id: string;
  readonly name: string;
  readonly type: string;
  readonly commands: ReadonlyArray<HarmonyCommand>;
}
```

### HarmonyActivity

```typescript
interface HarmonyActivity {
  readonly id: string;
  readonly name: string;
  readonly type: string;
  readonly isCurrent: boolean;
}
```

### HarmonyCommand

```typescript
interface HarmonyCommand {
  readonly id: string;
  readonly name: string;
  readonly label: string;
  readonly deviceId: string;
  readonly group?: string;
}
```

## State Management

### View Store

```typescript
interface ViewState {
  currentView: View;
  selectedDevice: HarmonyDevice | null;
  changeView: (view: View) => void;
  selectDevice: (device: HarmonyDevice | null) => void;
}
```

### Harmony Store

```typescript
interface HarmonyState {
  hubs: HarmonyHub[];
  selectedHub: HarmonyHub | null;
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  loadingState: LoadingState | null;
  error: HarmonyError | null;
}
```

## Usage Examples

### Basic Hub Connection

```typescript
const { hubs, connect } = useHarmony();

// Connect to the first available hub
if (hubs.length > 0) {
  await connect(hubs[0]);
}
```

### Command Execution

```typescript
const { executeCommand } = useCommandExecution();

// Execute a command with retry
await executeCommand(command, {
  maxRetries: 3,
  retryDelay: 1000,
});
```

### Activity Management

```typescript
const { activities, startActivity, stopActivity } = useHarmony();

// Start an activity
const activity = activities.find(a => a.name === "Watch TV");
if (activity) {
  await startActivity(activity.id);
}

// Stop current activity
await stopActivity();
```

### Error Handling

```typescript
try {
  await ErrorHandler.handleAsync(async () => {
    // Your async operation here
  }, "Operation context");
} catch (error) {
  // Error has been properly handled and logged
}
```
</file>

<file path="docs/Errors.md">
# Error Handling Documentation

## Error Categories

The extension uses a categorized error system to provide consistent error handling and recovery strategies.

### Connection Errors
- **Category:** `ErrorCategory.CONNECTION`
- **Description:** Issues with initial hub connection
- **Common Causes:**
  - Hub not found on network
  - Network connectivity issues
  - Firewall blocking connection
- **Recovery Actions:**
  - Retry connection
  - Check network settings
  - Verify hub is powered on
  - Check firewall settings

### Hub Communication Errors
- **Category:** `ErrorCategory.HUB_COMMUNICATION`
- **Description:** Issues during hub communication
- **Common Causes:**
  - Network interruption
  - Hub became unresponsive
  - Command timeout
- **Recovery Actions:**
  - Retry operation
  - Reconnect to hub
  - Check network stability
  - Restart hub if persistent

### Command Execution Errors
- **Category:** `ErrorCategory.COMMAND_EXECUTION`
- **Description:** Issues executing device commands
- **Common Causes:**
  - Device not responding
  - Invalid command
  - Hub busy with another command
- **Recovery Actions:**
  - Retry command
  - Verify device is powered on
  - Check command validity
  - Wait and retry

### State Errors
- **Category:** `ErrorCategory.STATE`
- **Description:** Issues with application state
- **Common Causes:**
  - Invalid state transition
  - Missing required state
  - State corruption
- **Recovery Actions:**
  - Reset configuration
  - Clear cache
  - Reinitialize state
  - Restart extension

### Validation Errors
- **Category:** `ErrorCategory.VALIDATION`
- **Description:** Data validation failures
- **Common Causes:**
  - Invalid configuration
  - Malformed data from hub
  - Type mismatches
- **Recovery Actions:**
  - Verify data format
  - Reset to defaults
  - Clear cache and refresh

### Storage Errors
- **Category:** `ErrorCategory.STORAGE`
- **Description:** Local storage issues
- **Common Causes:**
  - Storage full
  - Permission issues
  - Corrupted data
- **Recovery Actions:**
  - Clear old data
  - Reset storage
  - Verify permissions

### Cache Errors
- **Category:** `ErrorCategory.CACHE`
- **Description:** Cache-related issues
- **Common Causes:**
  - Cache corruption
  - Outdated cache
  - Cache size limits
- **Recovery Actions:**
  - Clear cache
  - Refresh data
  - Adjust cache settings

## Error Recovery Strategies

### Automatic Recovery
The extension implements automatic recovery for common errors:

```typescript
class ErrorHandler {
  static async handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      // Automatic error handling and recovery
      ErrorHandler.handle(error, context);
      throw error;
    }
  }
}
```

### Retry Logic
Commands and operations support configurable retry logic:

```typescript
interface RetryOptions {
  maxRetries: number;
  retryDelay: number;
  shouldRetry?: (error: HarmonyError) => boolean;
}

// Example usage
await executeCommand(command, {
  maxRetries: 3,
  retryDelay: 1000,
  shouldRetry: (error) => error.category === ErrorCategory.COMMAND_EXECUTION
});
```

## Error Codes and Messages

### Format
Error codes follow the format: `[CATEGORY]-[SUBCATEGORY]-[NUMBER]`

Example: `CONN-NET-001` for network connection errors

### Common Error Codes

#### Connection (CONN)
- `CONN-NET-001`: Network connectivity issue
- `CONN-HUB-001`: Hub not found
- `CONN-FW-001`: Firewall blocking connection

#### Command (CMD)
- `CMD-EXE-001`: Command execution failed
- `CMD-DEV-001`: Device not responding
- `CMD-VAL-001`: Invalid command format

#### Activity (ACT)
- `ACT-START-001`: Activity start failed
- `ACT-STOP-001`: Activity stop failed
- `ACT-STATE-001`: Invalid activity state

## User-Friendly Error Messages

### Message Guidelines
1. Clear and concise
2. Action-oriented
3. Technical details in logs only
4. Recovery steps included

### Example Messages
```typescript
// Good
"Unable to connect to hub. Please check if the hub is powered on and connected to your network."

// Better
"Connection to 'Living Room Hub' failed. Check network connection and try again. (CONN-NET-001)"

// Best
"Cannot connect to 'Living Room Hub'. Verify the hub is powered on and connected to your WiFi network. Click 'Retry' to attempt reconnection or 'Help' for troubleshooting steps. (CONN-NET-001)"
```

## Error Logging

### Log Levels
- `ERROR`: Serious issues requiring immediate attention
- `WARN`: Potential issues that don't stop operation
- `INFO`: Important state changes and operations
- `DEBUG`: Detailed debugging information

### Log Format
```typescript
{
  timestamp: string;
  level: LogLevel;
  category: ErrorCategory;
  code: string;
  message: string;
  context?: string;
  details?: unknown;
}
```

### Example Log Usage
```typescript
Logger.error("Command execution failed", {
  command: command.name,
  deviceId: command.deviceId,
  error: error.message,
  code: "CMD-EXE-001",
  context: "Volume Up command on TV"
});
```

## Troubleshooting Steps

### For Developers
1. Enable debug logging
2. Check error category and code
3. Review error context and details
4. Verify recovery action results
5. Check network conditions
6. Verify hub firmware version
7. Test with minimal configuration

### For Users
1. Follow error message instructions
2. Try suggested recovery actions
3. Check basic requirements
4. Clear cache if suggested
5. Contact support with error details

## Error Prevention

### Best Practices
1. Validate input data
2. Check preconditions
3. Use type guards
4. Implement proper cleanup
5. Handle edge cases
6. Log state transitions
7. Monitor performance metrics

### Example Prevention
```typescript
// Input validation
if (!isValidCommand(command)) {
  throw new HarmonyError(
    "Invalid command format",
    ErrorCategory.VALIDATION,
    new Error(`Command validation failed: ${JSON.stringify(command)}`)
  );
}

// Precondition checking
if (!this.isConnected) {
  throw new HarmonyError(
    "Must be connected to hub before executing commands",
    ErrorCategory.STATE
  );
}
```
</file>

<file path="src/hooks/useActivityFiltering.ts">
/**
 * Hook for filtering activities with memoization.
 * Provides filtered activities, grouping, and search functionality.
 * @module
 */
import { useMemo } from "react";
import { useViewStore } from "../stores/view";
import { HarmonyActivity } from "../types/core/harmony";
import { useHarmony } from "./useHarmony";
/**
 * Result interface for activity filtering operations.
 * Contains filtered activities and related metadata.
 * @interface ActivityFilteringResult
 */
interface ActivityFilteringResult {
  /** List of activities after applying filters */
  filteredActivities: HarmonyActivity[];
  /** List of unique activity types */
  activityTypes: string[];
  /** Map of activities grouped by type */
  activitiesByType: Map<string, HarmonyActivity[]>;
  /** Map of activity status (running/stopped) */
  activityStatus: Map<string, boolean>;
  /** Total number of activities before filtering */
  totalActivities: number;
  /** Number of activities after filtering */
  filteredCount: number;
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
}
/**
 * Hook for filtering and searching activities.
 * Provides memoized filtering, grouping, and status tracking.
 * Integrates with view store for search and filter state.
 * @returns ActivityFilteringResult containing filtered activities and metadata
 */
export function useActivityFiltering(): ActivityFilteringResult {
  const { activities, currentActivity } = useHarmony();
  const searchQuery = useViewStore((state) => state.searchQuery);
  const filters = useViewStore((state) => state.filters);
  // Memoize filtered activities
  const filteredActivities = useMemo(() => {
    let result = [...activities];
    // Apply activity type filter
    if (filters.activityType) {
      result = result.filter((activity) => activity.type === filters.activityType);
    }
    // Apply search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (activity) => activity.name.toLowerCase().includes(query) || activity.type.toLowerCase().includes(query),
      );
    }
    return result;
  }, [activities, searchQuery, filters.activityType]);
  // Memoize activity types
  const activityTypes = useMemo(() => {
    const types = new Set(activities.map((activity) => activity.type));
    return Array.from(types).sort();
  }, [activities]);
  // Memoize activities by type
  const activitiesByType = useMemo(() => {
    const byType = new Map<string, HarmonyActivity[]>();
    filteredActivities.forEach((activity) => {
      const activities = byType.get(activity.type) || [];
      activities.push(activity);
      byType.set(activity.type, activities);
    });
    // Sort activities within each type
    byType.forEach((activities) => {
      activities.sort((a, b) => {
        // Put current activity first
        if (a.id === currentActivity?.id) return -1;
        if (b.id === currentActivity?.id) return 1;
        // Then sort by name
        return a.name.localeCompare(b.name);
      });
    });
    return byType;
  }, [filteredActivities, currentActivity]);
  // Memoize activity status
  const activityStatus = useMemo(() => {
    const status = new Map<string, boolean>();
    activities.forEach((activity) => {
      status.set(activity.id, activity.isCurrent);
    });
    return status;
  }, [activities]);
  return {
    filteredActivities,
    activityTypes,
    activitiesByType,
    activityStatus,
    totalActivities: activities.length,
    filteredCount: filteredActivities.length,
    currentActivity,
  };
}
</file>

<file path="src/hooks/useCommandExecution.ts">
/**
 * Hook for executing Harmony commands with memoization.
 * Provides command execution with retry logic and error handling.
 * @module
 */
import { getPreferenceValues } from "@raycast/api";
import { useCallback, useState } from "react";
import { ToastManager } from "../services/toast";
import { HarmonyError, ErrorCategory } from "../types/core/errors";
import { HarmonyCommand } from "../types/core/harmony";
import { Preferences } from "../types/preferences";
import { useHarmony } from "./useHarmony";
/**
 * State interface for command execution.
 * Tracks execution state and statistics.
 * @interface CommandExecutionState
 */
interface CommandExecutionState {
  /** Whether a command is currently executing */
  isExecuting: boolean;
  /** Last executed command */
  lastCommand: HarmonyCommand | null;
  /** Last execution error */
  error: HarmonyError | null;
}
/**
 * Result interface for command execution hook.
 * Contains execution functions and state.
 * @interface CommandExecutionResult
 */
interface CommandExecutionResult {
  /** Execute a command with retry logic
   * @param command - Command to execute
   */
  execute: (command: HarmonyCommand) => Promise<void>;
  /** Retry the last failed command */
  retry: () => Promise<void>;
  /** Whether a command is currently executing */
  isExecuting: boolean;
  /** Last executed command */
  lastCommand: HarmonyCommand | null;
  /** Last execution error */
  error: HarmonyError | null;
}
/**
 * Hook for executing commands with retry and error handling.
 * Provides automatic retry based on preferences.
 * Shows toast notifications for execution status.
 * @returns CommandExecutionResult containing execution functions and state
 */
export function useCommandExecution(): CommandExecutionResult {
  const { executeCommand } = useHarmony();
  const [state, setState] = useState<CommandExecutionState>({
    isExecuting: false,
    lastCommand: null,
    error: null,
  });
  const preferences = getPreferenceValues<Preferences>();
  const holdTime = parseInt(preferences.commandHoldTime, 10);
  const autoRetry = preferences.autoRetry;
  const maxRetries = parseInt(preferences.maxRetries, 10);
  /**
   * Execute a command with retry logic.
   * Retries failed commands based on preferences.
   * Shows toast notifications for status.
   * @param command - Command to execute
   */
  const execute = useCallback(
    async (command: HarmonyCommand) => {
      setState((prev) => ({
        ...prev,
        isExecuting: true,
        lastCommand: command,
        error: null,
      }));
      try {
        let retries = 0;
        let success = false;
        while (!success && retries <= maxRetries) {
          try {
            await executeCommand(command);
            success = true;
          } catch (error) {
            retries++;
            if (!autoRetry || retries > maxRetries) {
              throw error;
            }
            // Wait before retrying
            await new Promise((resolve) => setTimeout(resolve, holdTime));
          }
        }
        setState((prev) => ({
          ...prev,
          isExecuting: false,
        }));
        ToastManager.success(`Executed ${command.label}`);
      } catch (error) {
        const harmonyError = new HarmonyError(
          `Failed to execute ${command.label}`,
          ErrorCategory.COMMAND_EXECUTION,
          error instanceof Error ? error : undefined,
        );
        setState((prev) => ({
          ...prev,
          isExecuting: false,
          error: harmonyError,
        }));
        ToastManager.error(`Failed to execute ${command.label}`, harmonyError.message);
      }
    },
    [executeCommand, holdTime, autoRetry, maxRetries],
  );
  /**
   * Retry the last failed command.
   * Only works if there is a last command.
   */
  const retry = useCallback(async () => {
    if (state.lastCommand) {
      await execute(state.lastCommand);
    }
  }, [execute, state.lastCommand]);
  return {
    execute,
    retry,
    isExecuting: state.isExecuting,
    lastCommand: state.lastCommand,
    error: state.error,
  };
}
</file>

<file path="src/hooks/useHarmony.ts">
/**
 * Core hook for managing Harmony Hub state and operations.
 * Provides centralized access to hub, device, and activity management.
 * @module
 */
import React, { useCallback, useState, createContext, useContext, useRef } from "react";
import { HarmonyClient } from "../services/harmony/harmonyClient";
import { HarmonyManager } from "../services/harmony/harmonyManager";
import { Logger } from "../services/logger";
import { HarmonyError, ErrorCategory } from "../types/core/errors";
import {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  LoadingState,
  HarmonyStage,
} from "../types/core/harmony";
// Create a single manager instance
const manager = new HarmonyManager();
/**
 * Core state and operations for Harmony Hub integration.
 * Provides access to hub state, devices, activities, and operations.
 * @interface HarmonyContextState
 */
interface HarmonyContextState {
  /** List of discovered Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected Harmony Hub */
  selectedHub: HarmonyHub | null;
  /** List of devices available on the selected hub */
  devices: HarmonyDevice[];
  /** List of activities available on the selected hub */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Current error state */
  error: HarmonyError | null;
  /** Current loading state */
  loadingState: LoadingState;
  /** Connect to a specific Harmony Hub */
  connect: (hub: HarmonyHub) => Promise<void>;
  /** Disconnect from the current hub */
  disconnect: () => Promise<void>;
  /** Refresh hub discovery and state */
  refresh: () => Promise<void>;
  /** Execute a command on a device */
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  /** Clear cached hub data */
  clearCache: () => Promise<void>;
  /** Start an activity by ID */
  startActivity: (activityId: string) => Promise<void>;
  /** Stop the current activity */
  stopActivity: () => Promise<void>;
}
/** Context for sharing Harmony state across components */
const HarmonyContext = createContext<HarmonyContextState | null>(null);
/**
 * Props for the HarmonyProvider component
 * @interface HarmonyProviderProps
 */
interface HarmonyProviderProps {
  /** Child components that will have access to Harmony state */
  children: React.ReactNode;
}
/**
 * Provider component for Harmony Hub functionality.
 * Wraps child components with access to Harmony state and operations.
 * @param props - The provider props
 * @returns A provider component
 */
export const HarmonyProvider: React.FC<HarmonyProviderProps> = ({ children }) => {
  const harmony = useHarmonyState();
  return React.createElement(HarmonyContext.Provider, { value: harmony }, children);
};
/**
 * Internal state interface for the Harmony hook.
 * Contains complete state for hub management.
 * @interface HarmonyInternalState
 */
interface HarmonyInternalState {
  /** List of discovered Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected Harmony Hub */
  selectedHub: HarmonyHub | null;
  /** Active client for hub communication */
  client: HarmonyClient | null;
  /** List of devices available on the selected hub */
  devices: HarmonyDevice[];
  /** List of activities available on the selected hub */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Current error state */
  error: HarmonyError | null;
  /** Current loading state */
  loadingState: LoadingState;
}
/**
 * Hook for managing Harmony Hub state and operations.
 * This is the internal implementation used by the provider.
 * Handles hub discovery, connection, device and activity management.
 * @returns The Harmony context state
 */
function useHarmonyState(): HarmonyContextState {
  const [state, setState] = useState<HarmonyInternalState>({
    hubs: [],
    selectedHub: null,
    client: null,
    devices: [],
    activities: [],
    currentActivity: null,
    error: null,
    loadingState: {
      stage: HarmonyStage.INITIAL,
      message: "Starting hub discovery",
      progress: 0,
    },
  });
  // Use ref to track if discovery is in progress
  const isDiscovering = useRef(false);
  /**
   * Update the current loading state
   * @param stage - The current stage of operation
   * @param message - User-friendly message about the current state
   * @param progress - Progress value between 0 and 1
   */
  const setLoadingState = useCallback((stage: HarmonyStage, message: string, progress: number) => {
    setState((prev) => ({
      ...prev,
      loadingState: { stage, message, progress },
    }));
  }, []);
  /**
   * Update the current error state
   * @param error - The current error or null if cleared
   */
  const setError = useCallback((error: HarmonyError | null) => {
    setState((prev) => ({ ...prev, error }));
  }, []);
  // Connect to a hub
  const connect = useCallback(
    async (hub: HarmonyHub) => {
      try {
        Logger.info(`Connecting to hub ${hub.name}`);
        setError(null);
        setLoadingState(HarmonyStage.CONNECTING, `Connecting to ${hub.name}...`, 0);
        // Create and connect to the client
        const newClient = new HarmonyClient(hub);
        await newClient.connect();
        Logger.info("Connected to hub, setting up state");
        setState((prev) => ({
          ...prev,
          client: newClient,
          selectedHub: hub,
        }));
        // Load devices
        setLoadingState(HarmonyStage.LOADING_DEVICES, "Loading devices...", 0.3);
        Logger.info("Loading devices");
        const hubDevices = await newClient.getDevices();
        Logger.info(`Loaded ${hubDevices.length} devices`);
        setState((prev) => ({ ...prev, devices: hubDevices }));
        // Load activities
        setLoadingState(HarmonyStage.LOADING_ACTIVITIES, "Loading activities...", 0.6);
        Logger.info("Loading activities");
        const hubActivities = await newClient.getActivities();
        Logger.info(`Loaded ${hubActivities.length} activities`);
        setState((prev) => ({ ...prev, activities: hubActivities }));
        // Get current activity
        Logger.info("Getting current activity");
        const current = await newClient.getCurrentActivity();
        setState((prev) => ({ ...prev, currentActivity: current }));
        setLoadingState(HarmonyStage.CONNECTED, "Connected successfully", 1);
        Logger.info("Hub setup completed successfully");
      } catch (err) {
        const error = new HarmonyError(
          "Failed to connect to hub",
          ErrorCategory.HUB_COMMUNICATION,
          err instanceof Error ? err : undefined,
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        Logger.error("Hub connection failed", { error: error.getDetailedMessage() });
      }
    },
    [setLoadingState, setError],
  );
  // Discover hubs
  const discover = useCallback(async () => {
    if (isDiscovering.current) {
      Logger.info("Discovery already in progress, skipping");
      return;
    }
    try {
      isDiscovering.current = true;
      setError(null);
      setLoadingState(HarmonyStage.DISCOVERING, "Searching for Harmony Hubs...", 0.1);
      Logger.info("Starting hub discovery");
      const discoveredHubs = await manager.startDiscovery((progress, message) => {
        setLoadingState(HarmonyStage.DISCOVERING, message, Math.max(0.1, progress));
      });
      if (!isDiscovering.current) {
        Logger.info("Discovery was cancelled");
        return;
      }
      Logger.info(`Discovery completed, found ${discoveredHubs.length} hubs`);
      setState((prev) => ({ ...prev, hubs: discoveredHubs }));
      if (discoveredHubs.length === 0) {
        const error = new HarmonyError("No Harmony Hubs found", ErrorCategory.HUB_COMMUNICATION);
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
      setLoadingState(HarmonyStage.CONNECTED, "Hubs discovered successfully", 1);
      // If there's only one hub, automatically select it
      if (discoveredHubs.length === 1) {
        const hub = discoveredHubs[0];
        if (hub) {
          Logger.info("Single hub found, auto-selecting");
          await connect(hub);
        }
      }
    } catch (err) {
      const error = new HarmonyError(
        "Failed to discover hubs",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined,
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      Logger.error("Hub discovery failed", { error: error.getDetailedMessage() });
    } finally {
      isDiscovering.current = false;
    }
  }, [connect, setLoadingState, setError]);
  // Disconnect from hub
  const disconnect = useCallback(async () => {
    if (state.client) {
      try {
        await state.client.disconnect();
        setLoadingState(HarmonyStage.INITIAL, "Disconnected", 0);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to disconnect",
          ErrorCategory.HUB_COMMUNICATION,
          err instanceof Error ? err : undefined,
        );
        Logger.error("Hub disconnection failed", { error: error.getDetailedMessage() });
      } finally {
        setState((prev) => ({
          ...prev,
          client: null,
          selectedHub: null,
          devices: [],
          activities: [],
          currentActivity: null,
          error: null,
        }));
      }
    }
  }, [state.client, setLoadingState]);
  // Execute a command
  const executeCommand = useCallback(
    async (command: HarmonyCommand) => {
      if (!state.client) {
        throw new HarmonyError("No hub selected", ErrorCategory.STATE);
      }
      try {
        Logger.debug("Sending command to hub", { command });
        setLoadingState(HarmonyStage.EXECUTING_COMMAND, `Sending ${command.name}...`, 0.5);
        await state.client.executeCommand(command);
        setLoadingState(HarmonyStage.CONNECTED, "Command sent successfully", 1);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to execute command",
          ErrorCategory.COMMAND_EXECUTION,
          err instanceof Error ? err : undefined,
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
    },
    [state.client, setLoadingState, setError],
  );
  // Start activity
  const startActivity = useCallback(
    async (activityId: string) => {
      if (!state.client) {
        throw new HarmonyError("No hub selected", ErrorCategory.STATE);
      }
      try {
        setLoadingState(HarmonyStage.STARTING_ACTIVITY, `Starting activity ${activityId}...`, 0.5);
        await state.client.startActivity(activityId);
        setLoadingState(HarmonyStage.CONNECTED, "Activity started successfully", 1);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to start activity",
          ErrorCategory.ACTIVITY_START,
          err instanceof Error ? err : undefined,
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
    },
    [state.client, setLoadingState, setError],
  );
  // Stop activity
  const stopActivity = useCallback(async () => {
    if (!state.client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      setLoadingState(HarmonyStage.STOPPING_ACTIVITY, "Stopping activity...", 0.5);
      await state.client.stopActivity();
      setLoadingState(HarmonyStage.CONNECTED, "Activity stopped successfully", 1);
    } catch (err) {
      const error = new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.ACTIVITY_STOP,
        err instanceof Error ? err : undefined,
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      throw error;
    }
  }, [state.client, setLoadingState, setError]);
  // Clear cache and rediscover
  const clearCache = useCallback(async () => {
    await disconnect();
    await manager.clearCache();
    await discover();
  }, [disconnect, discover]);
  // Refresh state
  const refresh = useCallback(async () => {
    await discover();
  }, [discover]);
  return {
    ...state,
    connect,
    disconnect,
    refresh,
    executeCommand,
    clearCache,
    startActivity,
    stopActivity,
  };
}
/**
 * Hook for accessing Harmony Hub functionality.
 * Must be used within a HarmonyProvider component.
 * Provides access to hub state, devices, activities, and operations.
 * @throws {Error} If used outside of a HarmonyProvider
 * @returns The Harmony context state
 */
export function useHarmony(): HarmonyContextState {
  const context = useContext(HarmonyContext);
  if (!context) {
    throw new Error("useHarmony must be used within a HarmonyProvider");
  }
  return context;
}
</file>

<file path="src/services/harmony/harmonyClient.ts">
/**
 * Client for communicating with a Harmony Hub.
 * Handles connection, command execution, activity management, and state caching.
 * @module
 */
import getHarmonyClient from "@harmonyhub/client-ws";
import { getPreferenceValues, LocalStorage } from "@raycast/api";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  isHarmonyDevice,
  isHarmonyActivity,
} from "../../types/core/harmony";
import { Logger } from "../logger";
/** Cache expiration time in milliseconds (24 hours) */
const CACHE_EXPIRY = 24 * 60 * 60 * 1000;
/**
 * Interface for cached hub configuration
 * @interface CachedConfig
 */
interface CachedConfig {
  /** List of devices associated with the hub */
  devices: HarmonyDevice[];
  /** List of activities configured on the hub */
  activities: HarmonyActivity[];
  /** Timestamp when the cache was created */
  timestamp: number;
}
/**
 * Interface for command execution body
 * @interface HarmonyCommandBody
 */
interface HarmonyCommandBody {
  /** Command identifier */
  command: string;
  /** Target device identifier */
  deviceId: string;
  /** Command type (e.g., "IRCommand") */
  type: string;
}
/**
 * Interface for command function configuration
 * @interface CommandFunction
 */
interface CommandFunction {
  /** Function name */
  name: string;
  /** Display label */
  label?: string;
  /** Command action configuration */
  action?: {
    /** Command identifier */
    command?: string;
  };
}
/**
 * Interface for device control group
 * @interface ControlGroup
 */
interface ControlGroup {
  /** Group name */
  name: string;
  /** List of functions in this group */
  function: CommandFunction[];
}
/**
 * Interface for raw device data from hub
 * @interface RawDevice
 */
interface RawDevice {
  /** Device identifier */
  id: string;
  /** Display label */
  label?: string;
  /** Device type */
  type?: string;
  /** List of control groups */
  controlGroup: ControlGroup[];
}
/**
 * Interface for raw hub configuration
 * @interface RawConfig
 */
interface RawConfig {
  /** List of devices */
  device: RawDevice[];
}
/**
 * Interface for raw activity data from hub
 * @interface RawActivity
 */
interface RawActivity {
  /** Activity identifier */
  id: string;
  /** Activity display label */
  label: string;
  /** Activity type */
  type: string;
}
/**
 * Client for communicating with a Harmony Hub
 * Handles connection, command execution, and activity management
 */
export class HarmonyClient {
  /** Connected client instance */
  private client: Awaited<ReturnType<typeof getHarmonyClient>> | null = null;
  /** Connection state */
  private isConnected = false;
  /** The hub this client is connected to */
  public readonly hub: HarmonyHub;
  /** Cache key for this hub's configuration */
  private cacheKey: string;
  /**
   * Creates a new HarmonyClient instance
   * @param hub - The Harmony Hub to connect to
   */
  constructor(hub: HarmonyHub) {
    this.hub = hub;
    this.cacheKey = `harmony-config-${hub.hubId}`;
  }
  /**
   * Connects to the Harmony Hub and retrieves its configuration.
   * Establishes WebSocket connection and verifies connectivity by fetching initial config.
   * Sets up disconnect handler and validates connection state.
   * @throws {HarmonyError} If connection fails or initial config cannot be retrieved
   */
  public async connect(): Promise<void> {
    if (this.isConnected) {
      Logger.info(`Already connected to hub ${this.hub.name}`);
      return;
    }
    try {
      Logger.info(`Initiating connection to hub ${this.hub.name} (${this.hub.ip})`);
      // Create client with remoteId if available for faster connection
      Logger.debug("Creating Harmony client", {
        hubInfo: {
          hubIp: this.hub.ip,
          hubId: this.hub.hubId,
          remoteId: this.hub.remoteId,
        },
      });
      this.client = await getHarmonyClient(this.hub.ip);
      this.isConnected = true;
      Logger.info(`Successfully connected to hub ${this.hub.name}`);
      // Setup disconnect handler
      this.client?.on("disconnected", () => {
        Logger.warn(`Disconnected from hub ${this.hub.name}`);
        this.isConnected = false;
      });
      // Verify connection by attempting to get config
      Logger.debug("Verifying connection by fetching initial config");
      await this.getDevicesFromHub();
      Logger.info("Connection verified successfully");
    } catch (err) {
      this.isConnected = false;
      this.client = null;
      const error = new HarmonyError(
        `Failed to connect to hub ${this.hub.name}`,
        ErrorCategory.CONNECTION,
        err instanceof Error ? err : undefined,
      );
      Logger.error("Connection failed", { error: error.getDetailedMessage() });
      throw error;
    }
  }
  /**
   * Retrieves the list of devices from the hub.
   * Attempts to load from cache first, falls back to hub query if cache is invalid.
   * @returns Promise resolving to list of devices
   * @throws {HarmonyError} If retrieving devices fails or hub is not connected
   */
  public async getDevices(): Promise<HarmonyDevice[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.devices) {
        Logger.info("Using cached devices for hub", this.hub.name);
        return cached.devices;
      }
      // Get from hub if not cached
      const rawDevices = await this.getDevicesFromHub();
      Logger.debug("Mapping raw devices to HarmonyDevice", {
        deviceCount: rawDevices.length,
        firstDevice: rawDevices[0],
      });
      const mappedDevices = rawDevices.map((device) => {
        const mappedDevice = {
          id: device.id,
          name: device.label || device.id,
          type: device.type || "Unknown",
          commands: device.controlGroup.flatMap((group) =>
            group.function.map((fn) => ({
              id: fn.name,
              name: fn.name,
              label: fn.label || fn.name,
              deviceId: device.id,
              group: fn.action?.command || "IRCommand",
            })),
          ),
        } as HarmonyDevice;
        // Validate mapped device
        if (!isHarmonyDevice(mappedDevice)) {
          Logger.error("Invalid device mapping", { device, mappedDevice });
          throw new HarmonyError(`Invalid device mapping for ${device.id}`, ErrorCategory.VALIDATION);
        }
        return mappedDevice;
      });
      Logger.debug("Successfully mapped devices", {
        deviceCount: mappedDevices.length,
        commandCounts: mappedDevices.map((d) => ({
          deviceId: d.id,
          commandCount: d.commands.length,
        })),
      });
      // Cache the new devices along with current activities
      await this.updateConfigCache(mappedDevices, await this.getActivitiesFromHub());
      return mappedDevices;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Gets devices directly from the hub via WebSocket.
   * @returns Promise resolving to list of raw device data
   * @throws {HarmonyError} If client not initialized or hub communication fails
   * @private
   */
  private async getDevicesFromHub(): Promise<RawDevice[]> {
    if (!this.client) {
      throw new HarmonyError("Client not initialized", ErrorCategory.CONNECTION);
    }
    try {
      Logger.info("Fetching devices from hub", this.hub.name);
      const rawConfig = (await this.client.getAvailableCommands()) as RawConfig;
      if (!rawConfig.device || rawConfig.device.length === 0) {
        Logger.warn("No devices found in hub config");
        return [];
      }
      Logger.info(`Found ${rawConfig.device.length} devices`);
      // Log raw config structure for first device
      if (rawConfig.device[0]) {
        Logger.info("First device raw config:", JSON.stringify(rawConfig.device[0], null, 2));
      }
      return rawConfig.device;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err)),
      );
    }
  }
  /**
   * Retrieves the list of activities from the hub.
   * Attempts to load from cache first, falls back to hub query if cache is invalid.
   * @returns Promise resolving to list of activities
   * @throws {HarmonyError} If retrieving activities fails or hub is not connected
   */
  public async getActivities(): Promise<HarmonyActivity[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.activities) {
        Logger.info("Using cached activities for hub", this.hub.name);
        return cached.activities;
      }
      // Get from hub if not cached
      const activities = await this.getActivitiesFromHub();
      // Cache the new activities along with current devices
      await this.updateConfigCache(await this.getDevices(), activities);
      return activities;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get activities",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Gets the currently running activity.
   * Queries the hub for current activity and matches it against known activities.
   * @returns Promise resolving to current activity or null if none
   * @throws {HarmonyError} If retrieving current activity fails or hub is not connected
   */
  public async getCurrentActivity(): Promise<HarmonyActivity | null> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const rawActivity = await this.client.getCurrentActivity();
      Logger.debug("Got current activity from hub", { rawActivity });
      if (!rawActivity) {
        return null;
      }
      // Convert raw activity string to proper type
      const currentActivityId = String(rawActivity);
      // Get all activities to find the current one
      const activities = await this.getActivities();
      const activity = activities.find((a) => a.id === currentActivityId);
      if (!activity) {
        Logger.warn("Current activity not found in activity list", {
          currentActivityId,
          availableActivities: activities.map((a) => a.id),
        });
        return null;
      }
      const currentActivity = {
        ...activity,
        isCurrent: true,
      };
      // Validate current activity
      if (!isHarmonyActivity(currentActivity)) {
        Logger.error("Invalid current activity", { currentActivity });
        throw new HarmonyError("Invalid current activity data", ErrorCategory.VALIDATION);
      }
      return currentActivity;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get current activity",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err)),
      );
    }
  }
  /**
   * Starts an activity by ID.
   * Initiates the activity and waits for confirmation of successful start.
   * @param activityId - ID of the activity to start
   * @throws {HarmonyError} If starting activity fails or hub is not connected
   */
  public async startActivity(activityId: string): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Starting activity", { activityId });
      await this.client.startActivity(activityId);
      // Wait for activity to start and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const currentActivity = await this.getCurrentActivity();
        if (currentActivity?.id === activityId) {
          Logger.debug("Activity started successfully", { activityId });
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to start");
    } catch (err) {
      throw new HarmonyError(
        `Failed to start activity ${activityId}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Stops the current activity.
   * Sends stop command and waits for confirmation of successful stop.
   * @throws {HarmonyError} If stopping activity fails or hub is not connected
   */
  public async stopActivity(): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Stopping current activity");
      const currentActivity = await this.getCurrentActivity();
      if (!currentActivity) {
        Logger.debug("No activity running");
        return;
      }
      await this.client.turnOff();
      // Wait for activity to stop and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const activity = await this.getCurrentActivity();
        if (!activity) {
          Logger.debug("Activity stopped successfully");
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to stop");
    } catch (err) {
      throw new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Gets cached configuration if available.
   * Checks cache validity and expiration.
   * @returns Promise resolving to cached configuration or null
   * @throws {HarmonyError} If reading cache fails
   * @private
   */
  private async getCachedConfig(): Promise<CachedConfig | null> {
    try {
      const cached = await LocalStorage.getItem<string>(this.cacheKey);
      if (!cached) {
        return null;
      }
      const config = JSON.parse(cached) as CachedConfig;
      // Check if cache is expired
      if (Date.now() - config.timestamp > CACHE_EXPIRY) {
        Logger.info("Config cache expired for hub", this.hub.name);
        await LocalStorage.removeItem(this.cacheKey);
        return null;
      }
      return config;
    } catch (err) {
      Logger.warn("Failed to get cached config:", err);
      return null;
    }
  }
  /**
   * Update the config cache with new devices and activities.
   * @param devices - List of devices to cache
   * @param activities - List of activities to cache
   * @private
   */
  private async updateConfigCache(devices: HarmonyDevice[], activities: HarmonyActivity[]): Promise<void> {
    try {
      const cache: CachedConfig = {
        devices,
        activities,
        timestamp: Date.now(),
      };
      await LocalStorage.setItem(this.cacheKey, JSON.stringify(cache));
      Logger.info("Cached config for hub", this.hub.name);
    } catch (err) {
      Logger.warn("Failed to cache config:", err);
    }
  }
  /**
   * Executes a command on a device.
   * Sends press and release actions with configurable hold time.
   * @param command - The command to execute
   * @throws {HarmonyError} If command execution fails or hub is not connected
   */
  public async executeCommand(command: HarmonyCommand): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const preferences = getPreferenceValues<{ commandHoldTime: string }>();
      const holdTime = parseInt(preferences.commandHoldTime || "100", 10);
      Logger.debug("Sending command to hub", { command });
      const commandBody: HarmonyCommandBody = {
        command: command.id,
        deviceId: command.deviceId,
        type: command.group || "IRCommand",
      };
      Logger.debug("Command body:", commandBody);
      // Send press action
      await this.client.send("holdAction", commandBody);
      // Wait for hold time
      await new Promise((resolve) => setTimeout(resolve, holdTime));
      // Send release action
      await this.client.send("releaseAction", commandBody);
    } catch (err) {
      throw new HarmonyError(
        `Failed to execute command ${command.name}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Disconnects from the Harmony Hub.
   * Cleans up resources and closes the connection.
   * @throws {HarmonyError} If disconnection fails
   */
  public async disconnect(): Promise<void> {
    try {
      if (this.client && this.isConnected) {
        await this.client.end();
        this.isConnected = false;
        this.client = null;
      }
    } catch (err) {
      throw new HarmonyError(
        "Failed to disconnect from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err)),
      );
    }
  }
  /**
   * Type guard for raw activity data from hub
   * @param data - Data to check
   * @returns True if data matches RawActivity structure
   * @private
   */
  private isRawActivity(data: unknown): data is RawActivity {
    return (
      typeof data === "object" &&
      data !== null &&
      typeof (data as RawActivity).id === "string" &&
      typeof (data as RawActivity).label === "string" &&
      typeof (data as RawActivity).type === "string"
    );
  }
  /**
   * Maps raw activity data to HarmonyActivity format
   * @param raw - Raw activity data from hub
   * @returns Mapped HarmonyActivity
   * @private
   */
  private mapRawActivityToHarmonyActivity = (raw: RawActivity): HarmonyActivity => {
    const mappedActivity: HarmonyActivity = {
      id: String(raw.id),
      name: raw.label,
      type: raw.type,
      isCurrent: false,
    };
    if (!isHarmonyActivity(mappedActivity)) {
      Logger.error("Invalid activity mapping", { raw, mappedActivity });
      throw new HarmonyError(`Invalid activity mapping for ${raw.id}`, ErrorCategory.VALIDATION);
    }
    return mappedActivity;
  };
  private async getActivitiesFromHub(): Promise<HarmonyActivity[]> {
    if (!this.client) {
      throw new HarmonyError("Client not initialized", ErrorCategory.CONNECTION);
    }
    const response = await this.client.getActivities();
    const rawData = Array.isArray(response) ? response : [];
    // Convert raw data to activities
    const activities: HarmonyActivity[] = [];
    for (const item of rawData) {
      if (this.isRawActivity(item)) {
        activities.push(this.mapRawActivityToHarmonyActivity(item));
      } else {
        Logger.error("Invalid raw activity data:", item);
        continue;
      }
    }
    Logger.debug("Got activities from hub", {
      activityCount: activities.length,
      firstActivity: activities[0],
    });
    return activities;
  }
  /**
   * Clears cached configuration for this hub.
   * @throws {HarmonyError} If clearing cache fails
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info(`Clearing cache for hub ${this.hub.name}`);
      await LocalStorage.removeItem(this.cacheKey);
    } catch (err) {
      throw new HarmonyError("Failed to clear cache", ErrorCategory.CACHE, err instanceof Error ? err : undefined);
    }
  }
}
</file>

<file path="src/services/harmony/harmonyManager.ts">
/**
 * Manager class for discovering and managing Harmony Hubs on the network.
 * Handles hub discovery, caching, and validation of hub data.
 * @module
 */
import { Explorer } from "@harmonyhub/discover";
import { LocalStorage, showToast, Toast } from "@raycast/api";
import { HarmonyClient } from "../../services/harmony/harmonyClient";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import { HarmonyHub } from "../../types/core/harmony";
import { Logger } from "../logger";
/** Discovery timeout in milliseconds */
const DISCOVERY_TIMEOUT = 5000;
/** Delay after finding a hub before completing discovery */
const DISCOVERY_COMPLETE_DELAY = 500;
/** Key for storing hub cache */
const CACHE_KEY = "harmony-hubs";
/** Cache time-to-live in milliseconds (24 hours) */
const CACHE_TTL = 24 * 60 * 60 * 1000;
/**
 * Interface for cached hub data
 * @interface CachedHubs
 */
interface CachedHubs {
  /** List of discovered hubs */
  hubs: HarmonyHub[];
  /** Timestamp when cache was created */
  timestamp: number;
}
/**
 * Interface for raw hub data received from discovery process
 * @interface HubDiscoveryData
 */
interface HubDiscoveryData {
  /** Unique identifier for the hub */
  uuid: string;
  /** IP address of the hub */
  ip: string;
  /** User-friendly name of the hub */
  friendlyName: string;
  /** Additional hub information */
  fullHubInfo: {
    /** Hub ID from Logitech service */
    hubId: string;
    /** Product ID of the hub */
    productId: string;
    /** Current firmware version */
    current_fw_version: string;
    /** Protocol version supported by the hub */
    protocolVersion: string;
    /** Port number for hub communication */
    port: string;
    /** Remote ID assigned by Harmony service */
    remoteId: string;
  };
}
/**
 * Manager class for discovering and managing Harmony Hubs.
 * Handles network discovery, caching, and hub validation.
 */
export class HarmonyManager {
  /** Hub discovery explorer instance */
  private explorer: Explorer | null = null;
  /** Whether discovery is currently in progress */
  private isDiscovering = false;
  /** Promise for current discovery operation */
  private discoveryPromise: Promise<HarmonyHub[]> | null = null;
  /** Timeout for discovery completion */
  private completeTimeout: NodeJS.Timeout | null = null;
  /** Map of discovered hubs by IP */
  private readonly discoveredHubs = new Map<string, HarmonyHub>();
  /**
   * Creates a validated HarmonyHub instance from discovery data
   * @param data - Raw hub data from discovery process
   * @returns Validated HarmonyHub instance
   * @throws {HarmonyError} If hub data is invalid
   */
  private createHub(data: HubDiscoveryData): HarmonyHub {
    // Validate required fields
    if (!data.friendlyName || !data.ip || !data.uuid || !data.fullHubInfo?.hubId) {
      throw new HarmonyError(
        "Invalid hub data received",
        ErrorCategory.VALIDATION,
        new Error(`Missing required fields: ${JSON.stringify(data)}`),
      );
    }
    return {
      id: data.uuid,
      name: data.friendlyName,
      ip: data.ip,
      hubId: data.fullHubInfo.hubId,
      remoteId: data.fullHubInfo.remoteId,
      version: data.fullHubInfo.current_fw_version,
      port: data.fullHubInfo.port,
      productId: data.fullHubInfo.productId,
      protocolVersion: data.fullHubInfo.protocolVersion,
    };
  }
  /**
   * Starts discovery of Harmony Hubs on the network.
   * Checks cache first, then performs network discovery if needed.
   * @param onProgress - Optional callback for progress updates
   * @returns Promise resolving to list of discovered hubs
   * @throws {HarmonyError} If discovery fails
   */
  public async startDiscovery(onProgress?: (progress: number, message: string) => void): Promise<HarmonyHub[]> {
    // Check cache first
    try {
      const cached = await this.getCachedHubs();
      if (cached) {
        Logger.info(`Found ${cached.length} cached hubs`);
        onProgress?.(1, `Found ${cached.length} cached hub(s)`);
        // Verify each cached hub is still accessible
        Logger.debug("Verifying cached hubs are accessible");
        const verifiedHubs: HarmonyHub[] = [];
        for (const hub of cached) {
          try {
            const client = new HarmonyClient(hub);
            await client.connect();
            await client.disconnect();
            verifiedHubs.push(hub);
            Logger.info(`Verified hub ${hub.name} is accessible`);
          } catch (err) {
            Logger.warn(`Cached hub ${hub.name} is no longer accessible, will be removed from cache`, err);
          }
        }
        if (verifiedHubs.length > 0) {
          Logger.info(`${verifiedHubs.length} of ${cached.length} cached hubs verified`);
          if (verifiedHubs.length !== cached.length) {
            // Update cache with only verified hubs
            await this.cacheHubs(verifiedHubs);
          }
          if (verifiedHubs.length === 1) {
            const hub = verifiedHubs[0];
            if (hub) {
              await showToast({
                style: Toast.Style.Success,
                title: "Auto-connecting to Hub",
                message: `Found single Harmony Hub: ${hub.name}`,
              });
            }
          }
          return verifiedHubs;
        }
        Logger.info("No cached hubs are accessible, proceeding with discovery");
      }
    } catch (error) {
      Logger.warn("Failed to read cache:", error);
      // Continue with discovery even if cache read fails
    }
    // If discovery is already in progress, return the existing promise
    if (this.discoveryPromise) {
      Logger.info("Discovery already in progress, returning existing promise");
      return this.discoveryPromise;
    }
    try {
      // Ensure cleanup of any previous explorer
      await this.cleanup();
      this.isDiscovering = true;
      onProgress?.(0, "Starting discovery process");
      Logger.info("Starting hub discovery process");
      this.explorer = new Explorer();
      // Create and store the discovery promise
      this.discoveryPromise = new Promise<HarmonyHub[]>((resolve, reject) => {
        if (!this.explorer) {
          const error = new HarmonyError("Explorer not initialized", ErrorCategory.STATE);
          Logger.error("Discovery failed - explorer not initialized");
          reject(error);
          return;
        }
        const hubs: HarmonyHub[] = [];
        // Function to complete discovery
        const completeDiscovery = async (): Promise<HarmonyHub[]> => {
          await this.cleanup();
          if (hubs.length > 0) {
            Logger.info(`Discovery completed successfully, found ${hubs.length} hubs`);
            await this.cacheHubs(hubs);
          } else {
            Logger.warn("Discovery completed but no hubs were found");
          }
          resolve(hubs);
          return hubs;
        };
        // Set timeout to stop discovery after DISCOVERY_TIMEOUT
        const timeout = setTimeout(async () => {
          Logger.info("Discovery timeout reached");
          await completeDiscovery();
        }, DISCOVERY_TIMEOUT);
        this.explorer.on("online", (data: HubDiscoveryData) => {
          try {
            Logger.debug("Received hub data", { data });
            const hub = this.createHub(data);
            // Check for duplicate hubs
            if (!hubs.some((h) => h.hubId === hub.hubId)) {
              hubs.push(hub);
              Logger.info(`Found hub: ${hub.name} (${hub.ip})`);
              onProgress?.(0.5, `Found hub: ${hub.name}`);
              // Clear any existing completion timeout
              if (this.completeTimeout) {
                clearTimeout(this.completeTimeout);
              }
              // Set a new completion timeout
              this.completeTimeout = setTimeout(async () => {
                clearTimeout(timeout);
                await completeDiscovery();
              }, DISCOVERY_COMPLETE_DELAY);
            } else {
              Logger.info(`Skipping duplicate hub: ${hub.name} (${hub.ip})`);
            }
          } catch (error) {
            Logger.error("Failed to process hub data:", error);
            // Don't reject here, just log and continue discovery
          }
        });
        this.explorer.on("error", async (error: Error) => {
          Logger.error("Discovery error:", error);
          clearTimeout(timeout);
          if (this.completeTimeout) {
            clearTimeout(this.completeTimeout);
          }
          await this.cleanup();
          reject(new HarmonyError("Hub discovery failed", ErrorCategory.HUB_COMMUNICATION, error));
        });
        // Start discovery
        Logger.debug("Starting explorer");
        this.explorer.start();
      });
      // Return the discovery promise
      return await this.discoveryPromise;
    } catch (error) {
      Logger.error("Failed to start discovery:", error);
      throw new HarmonyError("Failed to start hub discovery", ErrorCategory.HUB_COMMUNICATION, error as Error);
    } finally {
      this.isDiscovering = false;
      this.discoveryPromise = null;
    }
  }
  /**
   * Performs network discovery of Harmony Hubs.
   * Uses the Harmony discovery protocol to find hubs on the local network.
   * @returns Promise resolving to list of discovered hubs
   * @throws {HarmonyError} If discovery fails
   * @private
   */
  private async discoverHubs(): Promise<HarmonyHub[]> {
    return [];
  }
  /**
   * Caches discovered hubs in local storage.
   * @param hubs - List of hubs to cache
   * @throws {HarmonyError} If caching fails
   * @private
   */
  private async cacheHubs(hubs: HarmonyHub[]): Promise<void> {
    try {
      const cache: CachedHubs = {
        hubs,
        timestamp: Date.now(),
      };
      await LocalStorage.setItem(CACHE_KEY, JSON.stringify(cache));
      Logger.info(`Cached ${hubs.length} hubs`);
    } catch (error) {
      Logger.warn("Failed to cache hubs:", error);
      throw new HarmonyError("Failed to cache hubs", ErrorCategory.STORAGE, error as Error);
    }
  }
  /**
   * Retrieves cached hubs if available and not expired.
   * @returns Promise resolving to cached hubs or null if no valid cache exists
   * @throws {HarmonyError} If reading cache fails
   * @private
   */
  private async getCachedHubs(): Promise<HarmonyHub[] | null> {
    try {
      const cached = await LocalStorage.getItem<string>(CACHE_KEY);
      if (!cached) return null;
      const { hubs, timestamp } = JSON.parse(cached) as CachedHubs;
      // Check if cache is expired
      if (Date.now() - timestamp > CACHE_TTL) {
        Logger.info("Cache expired");
        await LocalStorage.removeItem(CACHE_KEY);
        return null;
      }
      // Validate cached hub data
      for (const hub of hubs) {
        if (!hub.id || !hub.name || !hub.ip || !hub.hubId) {
          Logger.warn("Invalid hub data in cache, clearing cache");
          await LocalStorage.removeItem(CACHE_KEY);
          return null;
        }
      }
      return hubs;
    } catch (error) {
      Logger.warn("Failed to get cached hubs:", error);
      throw new HarmonyError("Failed to read hub cache", ErrorCategory.STORAGE, error as Error);
    }
  }
  /**
   * Cleans up discovery resources.
   * Stops the explorer and clears timeouts.
   */
  public async cleanup(): Promise<void> {
    if (this.explorer) {
      try {
        this.explorer.stop();
        this.explorer.removeAllListeners();
      } catch (error) {
        Logger.error("Error stopping explorer:", error);
      }
      this.explorer = null;
    }
    if (this.completeTimeout) {
      clearTimeout(this.completeTimeout);
      this.completeTimeout = null;
    }
    this.isDiscovering = false;
    this.discoveryPromise = null;
  }
  /**
   * Clears all caches including hub discovery and configs.
   * @throws {HarmonyError} If clearing caches fails
   */
  public async clearAllCaches(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub discovery cache
      await this.clearCache();
      // Clear all hub config caches
      const keys = await LocalStorage.allItems();
      for (const key of Object.keys(keys)) {
        if (key.startsWith("harmony-config-")) {
          await LocalStorage.removeItem(key);
        }
      }
    } catch (err) {
      throw new HarmonyError("Failed to clear caches", ErrorCategory.CACHE, err instanceof Error ? err : undefined);
    }
  }
  /**
   * Clears all cached data.
   * Removes hub cache and all hub-specific config caches.
   * @throws {HarmonyError} If clearing cache fails
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub cache
      await LocalStorage.removeItem(CACHE_KEY);
      // Clear all hub-specific config caches
      const allKeys = await LocalStorage.allItems();
      for (const key of Object.keys(allKeys)) {
        if (key.startsWith("harmony-config-")) {
          await LocalStorage.removeItem(key);
        }
      }
      Logger.info("All caches cleared");
    } catch (error) {
      Logger.error("Failed to clear caches:", error);
      throw new HarmonyError("Failed to clear caches", ErrorCategory.STORAGE, error as Error);
    }
  }
}
</file>

<file path="src/services/harmony/harmonyState.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "../../types/core/harmony";
/**
 * State machine stages for Harmony operations
 */
export enum HarmonyStage {
  DISCOVERING = "discovering",
  CONNECTING = "connecting",
  LOADING_ACTIVITIES = "loading-activities",
  LOADING_DEVICES = "loading-devices",
  COMPLETE = "complete",
}
/**
 * Loading state information
 */
export interface LoadingState {
  stage: HarmonyStage;
  progress: number;
  message: string;
}
/**
 * Core state for Harmony operations
 */
export interface HarmonyState {
  hubs: HarmonyHub[];
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  selectedHub: HarmonyHub | null;
  error: Error | null;
}
/**
 * Initial loading state
 */
export const initialLoadingState: LoadingState = {
  stage: HarmonyStage.DISCOVERING,
  progress: 0,
  message: "Initializing...",
};
/**
 * Initial harmony state
 */
export const initialHarmonyState: HarmonyState = {
  hubs: [],
  devices: [],
  activities: [],
  currentActivity: null,
  selectedHub: null,
  error: null,
};
</file>

<file path="src/services/errorHandler.ts">
/**
 * Error handling service for Harmony Hub integration.
 * Provides centralized error handling, logging, and user feedback.
 * @module
 */
import { showToast, Toast } from "@raycast/api";
import { HarmonyError, ErrorCategory, ErrorSeverity, ErrorRecoveryAction } from "../types/core/errors";
import { Logger } from "./logger";
/**
 * Configuration for error handling
 * @interface ErrorHandlerConfig
 */
interface ErrorHandlerConfig {
  /** Whether to show toasts for errors */
  showToasts: boolean;
  /** Whether to log errors */
  logErrors: boolean;
  /** Default error category if none is specified */
  defaultCategory: ErrorCategory;
  /** Default error severity if none is specified */
  defaultSeverity: ErrorSeverity;
}
/**
 * Default configuration for error handling
 */
const DEFAULT_CONFIG: ErrorHandlerConfig = {
  showToasts: true,
  logErrors: true,
  defaultCategory: ErrorCategory.UNKNOWN,
  defaultSeverity: ErrorSeverity.ERROR,
};
/**
 * Service for handling errors in the Harmony extension.
 * Provides centralized error handling with logging and user feedback.
 */
export class ErrorHandler {
  /** Current error handler configuration */
  private static config: ErrorHandlerConfig = DEFAULT_CONFIG;
  /**
   * Configure the error handler
   * @param config - Partial configuration to merge with defaults
   */
  static configure(config: Partial<ErrorHandlerConfig>): void {
    ErrorHandler.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Handle any type of error, converting it to a HarmonyError if needed.
   * Logs the error and shows user feedback based on configuration.
   * @param error - The error to handle
   * @param context - Optional context information
   */
  static handle(error: Error | unknown, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error);
    // Log the error if enabled
    if (ErrorHandler.config.logErrors) {
      Logger.logError(harmonyError, context);
    }
    // Show user feedback if enabled
    if (ErrorHandler.config.showToasts) {
      ErrorHandler.showErrorToast(harmonyError);
    }
  }
  /**
   * Handle a specific error with a category.
   * Logs the error and shows user feedback based on configuration.
   * @param error - The error to handle
   * @param category - The error category
   * @param context - Optional context information
   */
  static handleWithCategory(error: Error | unknown, category: ErrorCategory, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error, category);
    // Log the error if enabled
    if (ErrorHandler.config.logErrors) {
      Logger.logError(harmonyError, context);
    }
    // Show user feedback if enabled
    if (ErrorHandler.config.showToasts) {
      ErrorHandler.showErrorToast(harmonyError);
    }
  }
  /**
   * Convert any error to a HarmonyError.
   * Ensures consistent error handling throughout the application.
   * @param error - The error to convert
   * @param category - Optional error category
   * @returns A HarmonyError instance
   * @private
   */
  private static toHarmonyError(error: Error | unknown, category?: ErrorCategory): HarmonyError {
    if (error instanceof HarmonyError) {
      return error;
    }
    const message = error instanceof Error ? error.message : String(error);
    return new HarmonyError(
      message,
      category || ErrorHandler.config.defaultCategory,
      error instanceof Error ? error : undefined,
    );
  }
  /**
   * Show an error toast to the user.
   * Displays user-friendly error information.
   * @param error - The error to display
   * @private
   */
  private static showErrorToast(error: HarmonyError): void {
    const title = ErrorHandler.getCategoryTitle(error.category);
    showToast({
      style: Toast.Style.Failure,
      title,
      message: error.message,
    });
  }
  /**
   * Get a user-friendly title for an error category.
   * @param category - The error category
   * @returns A user-friendly title
   * @private
   */
  private static getCategoryTitle(category: ErrorCategory): string {
    switch (category) {
      case ErrorCategory.CONNECTION:
        return "Connection Error";
      case ErrorCategory.HUB_COMMUNICATION:
        return "Hub Communication Error";
      case ErrorCategory.COMMAND_EXECUTION:
        return "Command Execution Error";
      case ErrorCategory.STATE:
        return "State Error";
      case ErrorCategory.VALIDATION:
        return "Validation Error";
      case ErrorCategory.STORAGE:
        return "Storage Error";
      case ErrorCategory.CACHE:
        return "Cache Error";
      default:
        return "Error";
    }
  }
  /**
   * Handle an async operation with proper error handling
   */
  static async handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handle(error, context);
      throw error;
    }
  }
  /**
   * Handle an async operation with a specific error category
   */
  static async handleAsyncWithCategory<T>(
    operation: () => Promise<T>,
    category: ErrorCategory,
    context?: string,
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handleWithCategory(error, category, context);
      throw error;
    }
  }
  /**
   * Get recovery actions for an error.
   * Determines appropriate recovery actions based on error category.
   * @param error - The error to get recovery actions for
   * @returns Array of recovery actions
   * @private
   */
  private static getRecoveryActions(error: HarmonyError): ErrorRecoveryAction[] {
    switch (error.category) {
      case ErrorCategory.CONNECTION:
      case ErrorCategory.HUB_COMMUNICATION:
        return [ErrorRecoveryAction.RETRY, ErrorRecoveryAction.RECONNECT];
      case ErrorCategory.COMMAND_EXECUTION:
        return [ErrorRecoveryAction.RETRY];
      case ErrorCategory.STATE:
        return [ErrorRecoveryAction.RESET_CONFIG];
      case ErrorCategory.CACHE:
        return [ErrorRecoveryAction.CLEAR_CACHE];
      default:
        return [ErrorRecoveryAction.RETRY];
    }
  }
  /**
   * Show a success toast
   */
  static showSuccess(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  /**
   * Show a warning toast
   */
  static showWarning(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Show a loading toast
   */
  static showLoading(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
}
</file>

<file path="src/services/localStorage.ts">
import { LocalStorage as RaycastLocalStorage } from "@raycast/api";
import { Logger } from "./logger";
export class LocalStorage {
  public static async getItem(key: string): Promise<string | null> {
    try {
      const value = await RaycastLocalStorage.getItem(key);
      return typeof value === "string" ? value : null;
    } catch (error) {
      Logger.error(`Failed to get item from storage: ${key}`, error);
      return null;
    }
  }
  public static async setItem(key: string, value: string): Promise<void> {
    try {
      await RaycastLocalStorage.setItem(key, value);
    } catch (error) {
      Logger.error(`Failed to set item in storage: ${key}`, error);
      throw error;
    }
  }
  public static async removeItem(key: string): Promise<void> {
    try {
      await RaycastLocalStorage.removeItem(key);
    } catch (error) {
      Logger.error(`Failed to remove item from storage: ${key}`, error);
      throw error;
    }
  }
  public static async clear(): Promise<void> {
    try {
      await RaycastLocalStorage.clear();
    } catch (error) {
      Logger.error("Failed to clear storage", error);
      throw error;
    }
  }
}
</file>

<file path="src/services/logger.ts">
/**
 * Logging service for Harmony Hub integration.
 * Provides structured logging with levels, history, and formatting.
 * @module
 */
import { LogLevel, LogEntry, LoggerOptions, ILogger } from "../types/core/logging";
/**
 * Default logger configuration
 */
const DEFAULT_OPTIONS: LoggerOptions = {
  minLevel: LogLevel.INFO,
  maxEntries: 1000,
  includeTimestamp: true,
  includeLevel: true,
};
/**
 * Service for structured logging in the Harmony extension.
 * Supports multiple log levels, history tracking, and configurable formatting.
 */
export class Logger implements ILogger {
  /** Current logger configuration */
  private static options: LoggerOptions = DEFAULT_OPTIONS;
  /** Log history */
  private static history: LogEntry[] = [];
  /**
   * Configure the logger.
   * Updates logger settings while preserving existing log history.
   * @param options - New logger options
   */
  static configure(options: Partial<LoggerOptions>): void {
    Logger.options = { ...DEFAULT_OPTIONS, ...options };
  }
  /**
   * Log a debug message.
   * Only logs if minimum level is DEBUG.
   * @param message - Message to log
   * @param data - Optional data to include
   */
  static debug(message: string, data?: unknown): void {
    Logger.log(LogLevel.DEBUG, message, data);
  }
  /**
   * Log an info message.
   * Only logs if minimum level is INFO or lower.
   * @param message - Message to log
   * @param data - Optional data to include
   */
  static info(message: string, data?: unknown): void {
    Logger.log(LogLevel.INFO, message, data);
  }
  /**
   * Log a warning message.
   * Only logs if minimum level is WARN or lower.
   * @param message - Message to log
   * @param data - Optional data to include
   */
  static warn(message: string, data?: unknown): void {
    Logger.log(LogLevel.WARN, message, data);
  }
  /**
   * Log an error message.
   * Only logs if minimum level is ERROR or lower.
   * @param message - Message to log
   * @param data - Optional data to include
   */
  static error(message: string, data?: unknown): void {
    Logger.log(LogLevel.ERROR, message, data);
  }
  /**
   * Log an error with full stack trace.
   * Includes error details and optional context.
   * @param error - Error to log
   * @param context - Optional context information
   */
  static logError(error: Error, context?: string): void {
    const message = context ? `${context}: ${error.message}` : error.message;
    Logger.error(message, {
      name: error.name,
      stack: error.stack,
      context,
    });
  }
  /**
   * Get the current log history.
   * Returns a copy of the log entries.
   * @returns Array of log entries
   */
  static getHistory(): LogEntry[] {
    return [...Logger.history];
  }
  /**
   * Clear the log history.
   * Removes all stored log entries.
   */
  static clearHistory(): void {
    Logger.history = [];
  }
  /**
   * Set the minimum log level.
   * Updates which messages will be logged.
   * @param level - New minimum log level
   */
  static setMinLevel(level: LogLevel): void {
    Logger.options.minLevel = level;
  }
  /**
   * Internal method to create a log entry.
   * Formats and stores the log entry based on configuration.
   * @param level - Log level
   * @param message - Log message
   * @param data - Optional data to include
   * @private
   */
  private static log(level: LogLevel, message: string, data?: unknown): void {
    if (level < (Logger.options.minLevel ?? LogLevel.INFO)) {
      return;
    }
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      data,
    };
    Logger.history.push(entry);
    // Trim history if it exceeds max entries
    if (Logger.options.maxEntries && Logger.history.length > Logger.options.maxEntries) {
      Logger.history = Logger.history.slice(-Logger.options.maxEntries);
    }
    // Log to console in development
    if (process.env.NODE_ENV === "development") {
      const prefix = Logger.formatPrefix(entry);
      console.log(prefix, message, data ? data : "");
    }
  }
  /**
   * Format the prefix for a log entry.
   * Includes timestamp and level based on configuration.
   * @param entry - Log entry to format
   * @returns Formatted prefix string
   * @private
   */
  private static formatPrefix(entry: LogEntry): string {
    const parts: string[] = [];
    if (Logger.options.includeTimestamp) {
      parts.push(entry.timestamp);
    }
    if (Logger.options.includeLevel) {
      parts.push(`[${LogLevel[entry.level]}]`);
    }
    return parts.join(" ");
  }
}
export type LoggerType = typeof Logger;
</file>

<file path="src/services/toast.ts">
/**
 * Toast notification service for Harmony Hub integration.
 * Provides consistent user feedback through Raycast toasts.
 * @module
 */
import { showToast, Toast } from "@raycast/api";
import { Logger } from "./logger";
/**
 * Configuration for toast notifications
 * @interface ToastConfig
 */
interface ToastConfig {
  /** Whether to log toast messages */
  logToasts: boolean;
}
/**
 * Default configuration for toast notifications
 */
const DEFAULT_CONFIG: ToastConfig = {
  logToasts: true,
};
/**
 * Service for managing toast notifications.
 * Provides consistent user feedback with optional logging.
 */
export class ToastManager {
  /** Current toast configuration */
  private static config: ToastConfig = DEFAULT_CONFIG;
  /**
   * Configure toast notifications.
   * Updates toast settings while preserving defaults.
   * @param config - New toast configuration
   */
  static configure(config: Partial<ToastConfig>): void {
    ToastManager.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Show a success toast.
   * Displays a success message with optional details.
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async success(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(`Success: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  /**
   * Show an error toast.
   * Displays an error message with optional details.
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async error(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.error(`Error: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Show a loading toast.
   * Displays a loading indicator with optional message.
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async loading(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(`Loading: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
  /**
   * Show a progress toast
   * @param title - Toast title
   * @param message - Optional toast message
   * @param progress - Progress value between 0 and 1
   */
  static async progress(title: string, message?: string, progress?: number): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(
        `Progress: ${title}${message ? ` - ${message}` : ""}${
          progress !== undefined ? ` (${Math.round(progress * 100)}%)` : ""
        }`,
      );
    }
    await showToast({
      style: Toast.Style.Animated,
      title,
      message: message ? (progress !== undefined ? `${message} (${Math.round(progress * 100)}%)` : message) : undefined,
    });
  }
}
</file>

<file path="src/stores/harmony.ts">
/**
 * Harmony Hub state management store
 * @module
 */
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { ErrorHandler } from "../services/errorHandler";
import { LocalStorage } from "../services/localStorage";
import { Logger } from "../services/logger";
import { ToastManager } from "../services/toast";
import {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  HarmonyError,
  ErrorCategory,
  LoadingState,
  HarmonyStage,
} from "../types/core";
import {
  MutableHarmonyState,
  toMutableHub,
  toMutableDevice,
  toMutableActivity,
  toMutableLoadingState,
} from "../types/core/state-mutable";
/**
 * Actions that can be performed on the store
 */
interface HarmonyActions {
  // Hub Management
  discoverHubs: () => Promise<void>;
  selectHub: (hub: HarmonyHub) => Promise<void>;
  disconnectHub: () => Promise<void>;
  // Device Management
  loadDevices: () => Promise<void>;
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  // Activity Management
  loadActivities: () => Promise<void>;
  startActivity: (activity: HarmonyActivity) => Promise<void>;
  stopActivity: (activity: HarmonyActivity) => Promise<void>;
  // State Management
  setError: (error: HarmonyError | null) => void;
  clearError: () => void;
  setLoadingState: (state: LoadingState) => void;
  reset: () => void;
}
/**
 * Combined store type with state and actions
 */
type HarmonyStore = MutableHarmonyState & HarmonyActions;
/**
 * Create the Harmony store with Zustand and Immer
 */
export const useHarmonyStore = create<HarmonyStore>()(
  immer((set, get) => {
    // Load persisted state
    const loadPersistedState = async (): Promise<void> => {
      try {
        const persistedJSON = await LocalStorage.getItem("harmony-hub-state");
        if (persistedJSON) {
          const { state } = JSON.parse(persistedJSON);
          set((draft) => {
            if (state.selectedHub) {
              draft.selectedHub = toMutableHub(state.selectedHub);
            }
            if (state.hubs) {
              draft.hubs = state.hubs.map(toMutableHub);
            }
          });
          Logger.info("Loaded persisted hub state");
        }
      } catch (err) {
        Logger.error("Failed to load persisted hub state", err);
      }
    };
    // Save state changes
    const saveState = async (state: HarmonyStore): Promise<void> => {
      try {
        const persistedState = {
          selectedHub: state.selectedHub,
          hubs: state.hubs,
        };
        await LocalStorage.setItem("harmony-hub-state", JSON.stringify({ state: persistedState, version: 1 }));
        Logger.info("Saved hub state");
      } catch (err) {
        Logger.error("Failed to save hub state", err);
      }
    };
    // Initialize state
    loadPersistedState();
    return {
      // Initial State
      hubs: [],
      selectedHub: null,
      devices: [],
      activities: [],
      currentActivity: null,
      error: null,
      loadingState: {
        stage: HarmonyStage.INITIAL,
        progress: 0,
        message: "Ready",
      },
      // Hub Management Actions
      discoverHubs: async () => {
        try {
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.DISCOVERING,
              progress: 0,
              message: "Discovering Harmony Hubs...",
            });
            state.error = null;
          });
          // TODO: Implement hub discovery
          const hubs: HarmonyHub[] = [];
          set((state) => {
            state.hubs = hubs.map(toMutableHub);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 1,
              message: `Found ${hubs.length} hub(s)`,
            });
          });
          saveState(get());
          ToastManager.success(`Found ${hubs.length} Harmony Hub(s)`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to discover hubs",
                  ErrorCategory.DISCOVERY,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Hub discovery failed");
          set((state) => {
            state.error = harmonyError;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.ERROR,
              progress: 1,
              message: "Hub discovery failed",
            });
          });
        }
      },
      selectHub: async (hub) => {
        try {
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTING,
              progress: 0,
              message: `Connecting to ${hub.name}...`,
            });
            state.error = null;
          });
          // TODO: Implement hub connection
          set((state) => {
            state.selectedHub = toMutableHub(hub);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Connected to ${hub.name}`,
            });
          });
          saveState(get());
          // Load devices and activities
          await get().loadDevices();
          await get().loadActivities();
          ToastManager.success(`Connected to ${hub.name}`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to connect to hub",
                  ErrorCategory.CONNECTION,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Hub connection failed");
          set((state) => {
            state.error = harmonyError;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.ERROR,
              progress: 1,
              message: "Connection failed",
            });
          });
        }
      },
      disconnectHub: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) return;
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 0,
              message: "Disconnecting...",
            });
          });
          // TODO: Implement hub disconnection
          set((state) => {
            state.selectedHub = null;
            state.devices = [];
            state.activities = [];
            state.currentActivity = null;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 1,
              message: "Disconnected",
            });
          });
          saveState(get());
          ToastManager.success("Disconnected from Harmony Hub");
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to disconnect",
                  ErrorCategory.CONNECTION,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Hub disconnection failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      // Device Management Actions
      loadDevices: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.LOADING_DEVICES,
              progress: 0,
              message: "Loading devices...",
            });
          });
          // TODO: Implement device loading
          const devices: HarmonyDevice[] = [];
          set((state) => {
            state.devices = devices.map(toMutableDevice);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Loaded ${devices.length} devices`,
            });
          });
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to load devices",
                  ErrorCategory.DATA,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Device loading failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      executeCommand: async (command) => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.EXECUTING_COMMAND,
              progress: 0,
              message: `Executing command: ${command.label}`,
            });
          });
          // TODO: Implement command execution
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Executed command: ${command.label}`,
            });
          });
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to execute command",
                  ErrorCategory.COMMAND,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Command execution failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      // Activity Management Actions
      loadActivities: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.LOADING_ACTIVITIES,
              progress: 0,
              message: "Loading activities...",
            });
          });
          // TODO: Implement activity loading
          const activities: HarmonyActivity[] = [];
          set((state) => {
            state.activities = activities.map(toMutableActivity);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Loaded ${activities.length} activities`,
            });
          });
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to load activities",
                  ErrorCategory.DATA,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Activity loading failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      startActivity: async (activity) => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.STARTING_ACTIVITY,
              progress: 0,
              message: `Starting activity: ${activity.name}`,
            });
          });
          // TODO: Implement activity start
          set((state) => {
            state.currentActivity = toMutableActivity(activity);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Started activity: ${activity.name}`,
            });
          });
          ToastManager.success(`Started activity: ${activity.name}`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to start activity",
                  ErrorCategory.COMMAND,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Activity start failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      stopActivity: async (activity) => {
        try {
          const { selectedHub, currentActivity } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          if (!currentActivity) {
            throw new HarmonyError("No activity is running", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.STOPPING_ACTIVITY,
              progress: 0,
              message: `Stopping activity: ${activity.name}`,
            });
          });
          // TODO: Implement activity stop
          set((state) => {
            state.currentActivity = null;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Stopped activity: ${activity.name}`,
            });
          });
          ToastManager.success(`Stopped activity: ${activity.name}`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to stop activity",
                  ErrorCategory.COMMAND,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Activity stop failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      // State Management Actions
      setError: (error) => {
        set((state) => {
          state.error = error;
        });
      },
      clearError: () => {
        set((state) => {
          state.error = null;
        });
      },
      setLoadingState: (loadingState) => {
        set((state) => {
          state.loadingState = toMutableLoadingState(loadingState);
        });
      },
      reset: () => {
        set((state) => {
          state.hubs = [];
          state.selectedHub = null;
          state.devices = [];
          state.activities = [];
          state.currentActivity = null;
          state.error = null;
          state.loadingState = toMutableLoadingState({
            stage: HarmonyStage.INITIAL,
            progress: 0,
            message: "Ready",
          });
        });
        saveState(get());
      },
    };
  }),
);
// Export selectors for common state derivations
export const selectHubs = (state: HarmonyStore): readonly HarmonyHub[] => state.hubs;
export const selectSelectedHub = (state: HarmonyStore): HarmonyHub | null => state.selectedHub;
export const selectDevices = (state: HarmonyStore): readonly HarmonyDevice[] => state.devices;
export const selectActivities = (state: HarmonyStore): readonly HarmonyActivity[] => state.activities;
export const selectCurrentActivity = (state: HarmonyStore): HarmonyActivity | null => state.currentActivity;
export const selectError = (state: HarmonyStore): HarmonyError | null => state.error as HarmonyError | null;
export const selectLoadingState = (state: HarmonyStore): LoadingState => ({
  stage: state.loadingState.stage as HarmonyStage,
  progress: state.loadingState.progress,
  message: state.loadingState.message,
});
export const selectIsLoading = (state: HarmonyStore): boolean =>
  state.loadingState.stage !== HarmonyStage.INITIAL &&
  state.loadingState.stage !== HarmonyStage.CONNECTED &&
  state.loadingState.stage !== HarmonyStage.ERROR;
</file>

<file path="src/stores/view.ts">
/**
 * View state management store
 * @module
 */
import { getPreferenceValues } from "@raycast/api";
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { LocalStorage } from "../services/localStorage";
import { Logger } from "../services/logger";
import { HarmonyDevice, HarmonyActivity } from "../types/core/harmony";
import { View, ViewFilters, ViewActions, MutableViewState } from "../types/core/views";
import { Preferences } from "../types/preferences";
import { toMutableDevice, toMutableActivity } from "../utils/state";
/**
 * Combined store type with state and actions
 */
type ViewStore = MutableViewState & ViewActions;
/**
 * Create the view store with Zustand and Immer
 */
export const useViewStore = create<ViewStore>()(
  immer((set, get) => {
    const preferences = getPreferenceValues<Preferences>();
    Logger.debug("Initializing view store with preferences", { defaultView: preferences.defaultView });
    // Load persisted state
    const loadPersistedState = async (): Promise<void> => {
      try {
        const persistedJSON = await LocalStorage.getItem("harmony-view-state");
        if (persistedJSON) {
          const { state } = JSON.parse(persistedJSON);
          set((draft) => {
            // Don't override the default view from preferences
            draft.filters = state.filters;
          });
          Logger.info("Loaded persisted view state");
        }
      } catch (err) {
        Logger.error("Failed to load persisted view state", err);
      }
    };
    // Save state changes
    const saveState = async (state: ViewStore): Promise<void> => {
      try {
        const persistedState = {
          filters: state.filters,
        };
        await LocalStorage.setItem("harmony-view-state", JSON.stringify({ state: persistedState, version: 1 }));
        Logger.info("Saved view state");
      } catch (err) {
        Logger.error("Failed to save view state", err);
      }
    };
    // Initialize state
    loadPersistedState();
    const initialView = preferences.defaultView === "activities" ? View.ACTIVITIES : View.DEVICES;
    Logger.debug("Setting initial view", { initialView });
    return {
      // Initial State
      currentView: initialView,
      selectedDevice: null,
      selectedActivity: null,
      searchQuery: "",
      filters: {
        deviceType: undefined,
        activityType: undefined,
        showFavorites: false,
      },
      // View Actions
      changeView: (view: View) => {
        set((state: MutableViewState) => {
          // If transitioning from hubs view after connection, use the preferred view
          if (state.currentView === View.HUBS && view === View.DEVICES) {
            const preferences = getPreferenceValues<Preferences>();
            state.currentView = preferences.defaultView === "activities" ? View.ACTIVITIES : View.DEVICES;
          } else {
            state.currentView = view;
          }
          // Clear selection when changing views
          if (view !== View.DEVICE_DETAIL) {
            state.selectedDevice = null;
          }
          if (view !== View.ACTIVITY_DETAIL) {
            state.selectedActivity = null;
          }
          // Clear search and filters
          state.searchQuery = "";
          state.filters = {
            deviceType: undefined,
            activityType: undefined,
            showFavorites: false,
          };
        });
        saveState(get());
      },
      selectDevice: (device: HarmonyDevice) => {
        Logger.debug("Selecting device in store", { device });
        set((state: MutableViewState) => {
          state.selectedDevice = toMutableDevice(device);
          state.currentView = View.DEVICE_DETAIL;
        });
        saveState(get());
      },
      selectActivity: (activity: HarmonyActivity) => {
        set((state: MutableViewState) => {
          state.selectedActivity = toMutableActivity(activity);
          state.currentView = View.ACTIVITY_DETAIL;
        });
        saveState(get());
      },
      clearSelection: () => {
        set((state: MutableViewState) => {
          if (state.currentView === View.DEVICE_DETAIL) {
            state.currentView = View.DEVICES;
            state.selectedDevice = null;
          } else if (state.currentView === View.ACTIVITY_DETAIL) {
            state.currentView = View.ACTIVITIES;
            state.selectedActivity = null;
          }
        });
        saveState(get());
      },
      setSearch: (query: string) => {
        set((state: MutableViewState) => {
          state.searchQuery = query;
        });
      },
      setFilters: (filters: Partial<ViewFilters>) => {
        set((state: MutableViewState) => {
          state.filters = {
            ...state.filters,
            ...filters,
          };
        });
        saveState(get());
      },
    };
  }),
);
// Selectors
export const selectCurrentView = (state: ViewStore): View => state.currentView;
export const selectSelectedDevice = (state: ViewStore): HarmonyDevice | null => state.selectedDevice;
export const selectSelectedActivity = (state: ViewStore): HarmonyActivity | null => state.selectedActivity;
export const selectSearchQuery = (state: ViewStore): string => state.searchQuery;
export const selectFilters = (state: ViewStore): ViewFilters => state.filters;
// Derived selectors
export const selectIsDetailView = (state: ViewStore): boolean =>
  state.currentView === View.DEVICE_DETAIL || state.currentView === View.ACTIVITY_DETAIL;
export const selectCanGoBack = (state: ViewStore): boolean =>
  state.currentView === View.DEVICE_DETAIL || state.currentView === View.ACTIVITY_DETAIL;
</file>

<file path="src/types/core/command.ts">
/**
 * Command-related type definitions for Harmony Hub integration
 * @module
 */
import { ErrorCategory } from "./harmony";
/**
 * Status of a command in the queue
 * @enum {string}
 */
export enum CommandStatus {
  /** Command is queued for execution */
  QUEUED = "QUEUED",
  /** Command is pending execution */
  PENDING = "PENDING",
  /** Command is currently executing */
  EXECUTING = "EXECUTING",
  /** Command has completed successfully */
  COMPLETED = "COMPLETED",
  /** Command has failed */
  FAILED = "FAILED",
  /** Command was cancelled */
  CANCELLED = "CANCELLED",
}
/**
 * Command queue configuration
 * @interface CommandQueueConfig
 */
export interface CommandQueueConfig {
  /** Maximum number of commands that can be queued */
  readonly maxQueueSize?: number;
  /** Maximum number of commands that can run concurrently */
  readonly maxConcurrent?: number;
  /** Default timeout for command execution in milliseconds */
  readonly defaultTimeout?: number;
  /** Default number of retries for failed commands */
  readonly defaultRetries?: number;
  /** Delay between commands in milliseconds */
  readonly commandDelay?: number;
}
/**
 * Command request for the queue
 * @interface CommandRequest
 */
export interface CommandRequest {
  /** Unique identifier for the command request */
  readonly id: string;
  /** Command to execute */
  readonly command: import("./harmony").HarmonyCommand;
  /** Timestamp when the request was created */
  readonly timestamp: number;
  /** Optional timeout in milliseconds */
  readonly timeout?: number;
  /** Optional number of retries */
  readonly retries?: number;
  /** Optional callback when command completes successfully */
  readonly onComplete?: () => void;
  /** Optional callback when command fails */
  readonly onError?: (error: Error) => void;
}
/**
 * Result of a command execution
 * @interface CommandResult
 */
export interface CommandResult {
  /** Unique identifier matching the request */
  readonly id: string;
  /** Command that was executed */
  readonly command: import("./harmony").HarmonyCommand;
  /** Current status of the command */
  readonly status: CommandStatus;
  /** Error if command failed */
  readonly error?: Error;
  /** When the command was queued */
  readonly queuedAt: number;
  /** When the command started executing */
  readonly startedAt?: number;
  /** When the command completed (success or failure) */
  readonly completedAt?: number;
}
/**
 * Retry configuration for error handling
 * @interface RetryConfig
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  readonly maxAttempts: number;
  /** Base delay between retries in milliseconds */
  readonly baseDelay: number;
  /** Maximum delay between retries in milliseconds */
  readonly maxDelay: number;
  /** Whether to use exponential backoff */
  readonly useExponentialBackoff: boolean;
  /** Categories to never retry */
  readonly nonRetryableCategories?: ErrorCategory[];
  /** Maximum total retry duration in milliseconds */
  readonly maxRetryDuration?: number;
}
/**
 * Timeout configuration for operations
 * @interface TimeoutConfig
 */
export interface TimeoutConfig {
  /** Connection timeout in milliseconds */
  readonly connection: number;
  /** Message timeout in milliseconds */
  readonly message: number;
  /** Activity timeout in milliseconds */
  readonly activity: number;
  /** Command timeout in milliseconds */
  readonly command: number;
  /** Discovery timeout in milliseconds */
  readonly discovery: number;
  /** Cache timeout in milliseconds */
  readonly cache: number;
}
</file>

<file path="src/types/core/errors.ts">
/**
 * Custom error types for Harmony Hub integration
 * @module
 */
/**
 * Categories of errors that can occur
 */
export enum ErrorCategory {
  /** Network or connection errors */
  CONNECTION = "CONNECTION",
  /** Network-specific errors */
  NETWORK = "NETWORK",
  /** WebSocket-specific errors */
  WEBSOCKET = "WEBSOCKET",
  /** Hub communication errors */
  HUB_COMMUNICATION = "HUB_COMMUNICATION",
  /** Command-related errors */
  COMMAND = "COMMAND",
  /** Command execution errors */
  COMMAND_EXECUTION = "COMMAND_EXECUTION",
  /** Activity start errors */
  ACTIVITY_START = "ACTIVITY_START",
  /** Activity stop errors */
  ACTIVITY_STOP = "ACTIVITY_STOP",
  /** Cache-related errors */
  CACHE = "CACHE",
  /** Storage-related errors */
  STORAGE = "STORAGE",
  /** State validation errors */
  STATE = "STATE",
  /** Data validation errors */
  DATA = "DATA",
  /** Validation errors */
  VALIDATION = "VALIDATION",
  /** Discovery errors */
  DISCOVERY = "DISCOVERY",
  /** Queue-related errors */
  QUEUE = "QUEUE",
  /** Harmony-specific errors */
  HARMONY = "HARMONY",
  /** Authentication errors */
  AUTHENTICATION = "AUTHENTICATION",
  /** System-level errors */
  SYSTEM = "SYSTEM",
  /** Unknown errors */
  UNKNOWN = "UNKNOWN",
}
/**
 * Severity levels for errors
 */
export enum ErrorSeverity {
  /** Warning level - operation can continue */
  WARNING = "WARNING",
  /** Error level - operation cannot continue */
  ERROR = "ERROR",
  /** Fatal level - application cannot continue */
  FATAL = "FATAL",
}
/**
 * Context for retryable operations
 */
export interface RetryContext {
  /** Number of attempts made */
  readonly attempts: number;
  /** Maximum number of attempts allowed */
  readonly maxAttempts: number;
  /** Time of first attempt */
  readonly firstAttempt: number;
  /** Timestamp of the last attempt */
  readonly lastAttemptTimestamp: number;
  /** Next scheduled retry time */
  readonly nextRetry: number | null;
  /** Whether maximum retries have been reached */
  readonly maxRetriesReached: boolean;
  /** Total retry duration in milliseconds */
  readonly totalDuration: number;
  /** Success rate of previous attempts */
  readonly successRate?: number;
  /** Delay between attempts in milliseconds */
  readonly delayMs: number;
}
/**
 * Strategy for recovering from errors
 */
export interface ErrorRecoveryStrategy {
  /** Name of the recovery strategy */
  readonly name: string;
  /** Description of what the strategy does */
  readonly description: string;
  /** Whether the strategy can be automated */
  readonly isAutomatic: boolean;
  /** Recovery actions to attempt */
  readonly actions: ErrorRecoveryAction[];
}
/**
 * Details that can be included with errors
 */
export interface ErrorDetails {
  /** Type of the invalid value */
  type?: string;
  /** Minimum allowed value */
  min?: number;
  /** Maximum allowed value */
  max?: number;
  /** List of allowed values */
  allowedValues?: readonly string[];
  /** Additional context */
  [key: string]: unknown;
}
/**
 * Recovery actions available for different error types
 */
export enum ErrorRecoveryAction {
  /** Retry the failed operation */
  RETRY = "RETRY",
  /** Reconnect to the hub */
  RECONNECT = "RECONNECT",
  /** Clear local cache */
  CLEAR_CACHE = "CLEAR_CACHE",
  /** Reset configuration */
  RESET_CONFIG = "RESET_CONFIG",
  /** Restart the hub */
  RESTART = "RESTART",
  /** Manual intervention required */
  MANUAL = "MANUAL",
}
/**
 * Custom error class for Harmony Hub operations
 * Provides detailed error information and categorization
 */
export class HarmonyError extends Error {
  /** The category of the error */
  readonly category: ErrorCategory;
  /** Error severity level */
  readonly severity: ErrorSeverity;
  /** The original error that caused this error, if any */
  readonly cause?: Error;
  /** Retry context if applicable */
  readonly retryContext?: RetryContext;
  /** Whether the error is retryable */
  readonly isRetryable: boolean;
  /** Error code if any */
  readonly code?: string;
  /** Additional error details */
  readonly details?: ErrorDetails;
  /** Recovery strategies */
  readonly recoveryStrategies?: ErrorRecoveryStrategy[];
  /** Timestamp when error occurred */
  readonly timestamp: number;
  /**
   * Creates a new HarmonyError instance
   * @param message - User-friendly error message
   * @param category - Category of the error
   * @param cause - Original error that caused this error
   * @param retryContext - Context for retryable operations
   * @param isRetryable - Whether the operation can be retried
   * @param code - Error code for specific error types
   * @param details - Additional error details
   * @param severity - Severity level of the error
   * @param recoveryStrategies - Strategies for recovering from the error
   */
  constructor(
    message: string,
    category: ErrorCategory,
    cause?: Error,
    retryContext?: RetryContext,
    isRetryable = true,
    code?: string,
    details?: ErrorDetails,
    severity: ErrorSeverity = ErrorSeverity.ERROR,
    recoveryStrategies?: ErrorRecoveryStrategy[],
  ) {
    super(message);
    this.name = "HarmonyError";
    this.category = category;
    this.severity = severity;
    this.cause = cause;
    this.retryContext = retryContext;
    this.isRetryable = isRetryable;
    this.code = code;
    this.details = details;
    this.recoveryStrategies = recoveryStrategies;
    this.timestamp = Date.now();
    // Maintains proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, HarmonyError);
    }
  }
  /**
   * Gets a user-friendly error message suitable for display
   * @returns User-friendly error message with severity prefix
   */
  getUserMessage(): string {
    const prefix = this.severity === ErrorSeverity.WARNING ? "Warning" : "Error";
    return `${prefix}: ${this.message}`;
  }
  /**
   * Gets a detailed error message including all error information
   * Useful for logging and debugging
   * @returns Detailed multi-line error message
   */
  getDetailedMessage(): string {
    const details: string[] = [
      `Error: ${this.message}`,
      `Category: ${this.category}`,
      `Severity: ${this.severity}`,
      `Timestamp: ${new Date(this.timestamp).toISOString()}`,
      `Retryable: ${this.isRetryable}`,
    ];
    if (this.code) {
      details.push(`Code: ${this.code}`);
    }
    if (this.retryContext) {
      details.push(
        `Retry Attempts: ${this.retryContext.attempts}/${this.retryContext.maxAttempts}`,
        `Last Attempt: ${new Date(this.retryContext.lastAttemptTimestamp).toISOString()}`,
      );
    }
    if (this.cause) {
      details.push(`Cause: ${this.cause.message}`);
      if (this.cause.stack) {
        details.push(`Stack: ${this.cause.stack}`);
      }
    }
    if (this.details) {
      details.push(`Additional Details: ${JSON.stringify(this.details, null, 2)}`);
    }
    return details.join("\n");
  }
  /**
   * Gets the default recovery strategy for this error
   * @returns The default recovery strategy for this error type
   */
  getDefaultRecoveryStrategy(): ErrorRecoveryStrategy {
    switch (this.category) {
      case ErrorCategory.CONNECTION:
      case ErrorCategory.NETWORK:
      case ErrorCategory.WEBSOCKET:
      case ErrorCategory.HUB_COMMUNICATION:
        return {
          name: "Connection Recovery",
          description: "Attempt to restore connection to the hub",
          isAutomatic: true,
          actions: [ErrorRecoveryAction.RECONNECT],
        };
      case ErrorCategory.COMMAND:
      case ErrorCategory.COMMAND_EXECUTION:
        return {
          name: "Command Recovery",
          description: "Attempt to re-execute the command",
          isAutomatic: true,
          actions: [ErrorRecoveryAction.RETRY],
        };
      case ErrorCategory.ACTIVITY_START:
      case ErrorCategory.ACTIVITY_STOP:
        return {
          name: "Activity Recovery",
          description: "Attempt to retry the activity operation",
          isAutomatic: true,
          actions: [ErrorRecoveryAction.RETRY],
        };
      case ErrorCategory.CACHE:
      case ErrorCategory.STORAGE:
        return {
          name: "Storage Recovery",
          description: "Clear and rebuild cache data",
          isAutomatic: true,
          actions: [ErrorRecoveryAction.CLEAR_CACHE],
        };
      case ErrorCategory.STATE:
        return {
          name: "State Recovery",
          description: "Reset application state",
          isAutomatic: false,
          actions: [ErrorRecoveryAction.RESET_CONFIG, ErrorRecoveryAction.CLEAR_CACHE, ErrorRecoveryAction.RECONNECT],
        };
      case ErrorCategory.DATA:
      case ErrorCategory.VALIDATION:
        return {
          name: "Data Recovery",
          description: "Refresh data from hub",
          isAutomatic: true,
          actions: [ErrorRecoveryAction.RETRY, ErrorRecoveryAction.CLEAR_CACHE],
        };
      case ErrorCategory.DISCOVERY:
        return {
          name: "Discovery Recovery",
          description: "Retry hub discovery",
          isAutomatic: true,
          actions: [ErrorRecoveryAction.RETRY],
        };
      default:
        return {
          name: "Manual Recovery",
          description: "Manual intervention required",
          isAutomatic: false,
          actions: [ErrorRecoveryAction.MANUAL],
        };
    }
  }
}
</file>

<file path="src/types/core/harmony.ts">
/**
 * Core type definitions for Harmony Hub integration
 * @module
 */
import { Logger } from "../../services/logger";
/** Re-export ErrorCategory for backwards compatibility */
export { ErrorCategory } from "./errors";
/**
 * Represents a Logitech Harmony Hub device on the network
 * @interface HarmonyHub
 */
export interface HarmonyHub {
  /** Unique identifier for the hub */
  readonly id: string;
  /** User-friendly name of the hub */
  readonly name: string;
  /** IP address of the hub on the local network */
  readonly ip: string;
  /** Remote ID assigned by Harmony service */
  readonly remoteId: string;
  /** Hub ID from Logitech service */
  readonly hubId: string;
  /** Version of the hub firmware */
  readonly version: string;
  /** Port number for hub communication */
  readonly port: string;
  /** Product ID of the hub */
  readonly productId: string;
  /** Protocol versions supported by the hub */
  readonly protocolVersion: string;
}
/**
 * Represents a device that can be controlled by the Harmony Hub
 * @interface HarmonyDevice
 */
export interface HarmonyDevice {
  /** Unique identifier for the device */
  readonly id: string;
  /** User-friendly name of the device */
  readonly name: string;
  /** Type of device (e.g., TV, Receiver, etc.) */
  readonly type: string;
  /** Available commands for this device */
  readonly commands: readonly HarmonyCommand[];
}
/**
 * Represents a command that can be sent to a device
 * @interface HarmonyCommand
 */
export interface HarmonyCommand {
  /** Unique identifier for the command */
  readonly id: string;
  /** Internal name of the command */
  readonly name: string;
  /** User-friendly label for display */
  readonly label: string;
  /** ID of the device this command belongs to */
  readonly deviceId: string;
  /** Command group for categorization (e.g., "IRCommand", "PowerToggle", etc.) */
  readonly group?: string;
}
/**
 * Represents an activity configured on the Harmony Hub
 * @interface HarmonyActivity
 */
export interface HarmonyActivity {
  /** Unique identifier for the activity */
  readonly id: string;
  /** User-friendly name of the activity */
  readonly name: string;
  /** Type of activity (e.g., "WatchTV", "ListenToMusic", etc.) */
  readonly type: string;
  /** Whether this is the currently running activity */
  readonly isCurrent: boolean;
}
/**
 * Represents the stage of the Harmony Hub connection process
 * @enum {string}
 */
export enum HarmonyStage {
  /** Initial state before any connection attempt */
  INITIAL = "initial",
  /** Actively discovering hubs on the network */
  DISCOVERING = "discovering",
  /** Establishing connection to a specific hub */
  CONNECTING = "connecting",
  /** Loading device information from the hub */
  LOADING_DEVICES = "loading_devices",
  /** Loading activity information from the hub */
  LOADING_ACTIVITIES = "loading_activities",
  /** Starting a new activity */
  STARTING_ACTIVITY = "starting_activity",
  /** Stopping the current activity */
  STOPPING_ACTIVITY = "stopping_activity",
  /** Executing a device command */
  EXECUTING_COMMAND = "executing_command",
  /** Refreshing hub state */
  REFRESHING = "refreshing",
  /** Successfully connected and ready */
  CONNECTED = "connected",
  /** Error state */
  ERROR = "error",
}
/**
 * Represents the loading state during operations
 * @interface LoadingState
 */
export interface LoadingState {
  /** Current stage of the process */
  readonly stage: HarmonyStage;
  /** Progress from 0 to 1 */
  readonly progress: number;
  /** User-friendly message about the current state */
  readonly message: string;
}
/**
 * Configuration for operation timeouts
 */
export interface TimeoutConfig {
  /** Timeout for network operations in milliseconds */
  connection: number;
  /** Timeout for message operations in milliseconds */
  message: number;
  /** Timeout for activity operations in milliseconds */
  activity: number;
  /** Timeout for command operations in milliseconds */
  command: number;
  /** Timeout for discovery operations in milliseconds */
  discovery: number;
  /** Timeout for cache operations in milliseconds */
  cache: number;
}
/**
 * Type guard to check if an object is a HarmonyHub.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyHub
 */
export function isHarmonyHub(obj: unknown): obj is HarmonyHub {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyHub validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj,
    });
    return false;
  }
  const hub = obj as Partial<HarmonyHub>;
  const validations = [
    { field: "id", valid: typeof hub.id === "string" && hub.id.length > 0, value: hub.id },
    { field: "name", valid: typeof hub.name === "string" && hub.name.length > 0, value: hub.name },
    { field: "ip", valid: typeof hub.ip === "string" && hub.ip.length > 0, value: hub.ip },
    { field: "hubId", valid: typeof hub.hubId === "string" && hub.hubId.length > 0, value: hub.hubId },
    { field: "remoteId", valid: typeof hub.remoteId === "string", value: hub.remoteId },
    { field: "version", valid: typeof hub.version === "string", value: hub.version },
    { field: "port", valid: typeof hub.port === "string", value: hub.port },
    { field: "productId", valid: typeof hub.productId === "string", value: hub.productId },
    { field: "protocolVersion", valid: typeof hub.protocolVersion === "string", value: hub.protocolVersion },
  ];
  const failures = validations.filter((v) => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyHub validation failed", {
      failures: failures.map((f) => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value,
      })),
    });
    return false;
  }
  return true;
}
/**
 * Type guard to check if an object is a HarmonyDevice.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyDevice
 */
export function isHarmonyDevice(obj: unknown): obj is HarmonyDevice {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyDevice validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj,
    });
    return false;
  }
  const device = obj as Partial<HarmonyDevice>;
  const validations = [
    { field: "id", valid: typeof device.id === "string" && device.id.length > 0, value: device.id },
    { field: "name", valid: typeof device.name === "string" && device.name.length > 0, value: device.name },
    { field: "type", valid: typeof device.type === "string" && device.type.length > 0, value: device.type },
    { field: "commands", valid: Array.isArray(device.commands), value: device.commands },
  ];
  const failures = validations.filter((v) => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyDevice validation failed", {
      failures: failures.map((f) => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value,
      })),
    });
    return false;
  }
  // Validate each command
  if (device.commands) {
    const invalidCommands = device.commands
      .map((cmd, index) => ({
        index,
        command: cmd,
        valid: isHarmonyCommand(cmd),
      }))
      .filter((result) => !result.valid);
    if (invalidCommands.length > 0) {
      Logger.debug("isHarmonyDevice validation failed", {
        reason: "Invalid commands",
        invalidCommands: invalidCommands.map((ic) => ({
          index: ic.index,
          command: ic.command,
        })),
      });
      return false;
    }
  }
  return true;
}
/**
 * Type guard to check if an object is a HarmonyCommand.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyCommand
 */
export function isHarmonyCommand(obj: unknown): obj is HarmonyCommand {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyCommand validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj,
    });
    return false;
  }
  const command = obj as Partial<HarmonyCommand>;
  const validations = [
    { field: "id", valid: typeof command.id === "string" && command.id.length > 0, value: command.id },
    { field: "name", valid: typeof command.name === "string" && command.name.length > 0, value: command.name },
    { field: "label", valid: typeof command.label === "string" && command.label.length > 0, value: command.label },
    {
      field: "deviceId",
      valid: typeof command.deviceId === "string" && command.deviceId.length > 0,
      value: command.deviceId,
    },
  ];
  const failures = validations.filter((v) => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyCommand validation failed", {
      failures: failures.map((f) => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value,
      })),
    });
    return false;
  }
  // Optional group validation
  if (command.group !== undefined && typeof command.group !== "string") {
    Logger.debug("isHarmonyCommand validation failed", {
      reason: "Invalid group type",
      receivedType: typeof command.group,
      receivedValue: command.group,
    });
    return false;
  }
  return true;
}
/**
 * Type guard to check if an object is a HarmonyActivity.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyActivity
 */
export function isHarmonyActivity(obj: unknown): obj is HarmonyActivity {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyActivity validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj,
    });
    return false;
  }
  const activity = obj as Partial<HarmonyActivity>;
  const validations = [
    { field: "id", valid: typeof activity.id === "string" && activity.id.length > 0, value: activity.id },
    { field: "name", valid: typeof activity.name === "string" && activity.name.length > 0, value: activity.name },
    { field: "type", valid: typeof activity.type === "string" && activity.type.length > 0, value: activity.type },
    { field: "isCurrent", valid: typeof activity.isCurrent === "boolean", value: activity.isCurrent },
  ];
  const failures = validations.filter((v) => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyActivity validation failed", {
      failures: failures.map((f) => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value,
      })),
    });
    return false;
  }
  return true;
}
/**
 * Validation utility to ensure a HarmonyHub object is valid
 * @param hub The hub object to validate
 * @throws {Error} If the hub object is invalid
 */
export function validateHarmonyHub(hub: HarmonyHub): void {
  if (!isHarmonyHub(hub)) {
    throw new Error("Invalid HarmonyHub object");
  }
}
/**
 * Validation utility to ensure a HarmonyDevice object is valid
 * @param device The device object to validate
 * @throws {Error} If the device object is invalid
 */
export function validateHarmonyDevice(device: HarmonyDevice): void {
  if (!isHarmonyDevice(device)) {
    throw new Error("Invalid HarmonyDevice object");
  }
  device.commands.forEach(validateHarmonyCommand);
}
/**
 * Validation utility to ensure a HarmonyCommand object is valid
 * @param command The command object to validate
 * @throws {Error} If the command object is invalid
 */
export function validateHarmonyCommand(command: HarmonyCommand): void {
  if (!isHarmonyCommand(command)) {
    throw new Error("Invalid HarmonyCommand object");
  }
}
/**
 * Validation utility to ensure a HarmonyActivity object is valid
 * @param activity The activity object to validate
 * @throws {Error} If the activity object is invalid
 */
export function validateHarmonyActivity(activity: HarmonyActivity): void {
  if (!isHarmonyActivity(activity)) {
    throw new Error("Invalid HarmonyActivity object");
  }
}
/**
 * Current state of the Harmony Hub system
 * @interface HarmonyState
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Current error if any */
  readonly error: Error | null;
  /** Current loading state */
  readonly loadingState: LoadingState;
}
/**
 * WebSocket message format from Harmony Hub
 * @interface HarmonyMessage
 */
export interface HarmonyMessage {
  /** Message type */
  readonly type: string;
  /** Message data */
  readonly data?: {
    /** Message ID */
    readonly id?: string;
    /** Message status */
    readonly status?: string;
    /** Error code if any */
    readonly errorCode?: string;
    /** Error message if any */
    readonly errorMessage?: string;
    /** Additional data fields */
    readonly [key: string]: unknown;
  };
}
/**
 * Message handler type
 */
export type MessageHandler = (message: HarmonyMessage) => void;
/**
 * Hub discovery handler type
 */
export type HubDiscoveryHandler = (hub: HarmonyHub) => void;
</file>

<file path="src/types/core/index.ts">
/**
 * Core types and utilities for Harmony Hub integration
 * @module
 */
// Base types
export * from "./harmony";
export * from "./errors";
export * from "./validation";
export * from "./command";
export * from "./logging";
export * from "./websocket";
export * from "./state";
// Re-export commonly used types for convenience
export type {
  // Harmony types
  HarmonyHub,
  HarmonyDevice,
  HarmonyCommand,
  HarmonyActivity,
  LoadingState,
} from "./harmony";
// Re-export commonly used enums
export {
  // Harmony enums
  HarmonyStage,
  ErrorCategory,
} from "./harmony";
// Re-export error types
export { HarmonyError, ErrorSeverity, ErrorRecoveryAction } from "./errors";
export type { RetryContext } from "./errors";
// Re-export validation functions
export { validateHub, validateDevice, validateCommand, validateActivity, validateLoadingState } from "./validation";
// Re-export command types
export type { CommandQueueConfig, CommandRequest, CommandResult, RetryConfig, TimeoutConfig } from "./command";
export { CommandStatus } from "./command";
// Re-export logging types
export type { LoggerOptions, LogEntry, ILogger, LogFilter, LogFormatter } from "./logging";
export { LogLevel } from "./logging";
// Re-export WebSocket types
export type {
  WebSocketMessage,
  CommandPayload,
  ActivityPayload,
  WebSocketMessageUnion,
  WebSocketResponse,
  ActivitiesResponse,
  DevicesResponse,
  WebSocketEventHandler,
  WebSocketErrorHandler,
  QueuedMessage,
} from "./websocket";
export { WebSocketConnectionStatus, WebSocketMessageType } from "./websocket";
// Re-export state types
export type {
  MachineContext,
  DiscoverEvent,
  SelectHubEvent,
  RefreshEvent,
  RetryEvent,
  ClearEvent,
  DisconnectEvent,
  ErrorEvent,
  DoneDiscoverEvent,
  DoneLoadHubEvent,
  MachineEvent,
  MachineServices,
  HarmonyState,
} from "./state";
export { MachineState } from "./state";
</file>

<file path="src/types/core/logging.ts">
/**
 * Logging type definitions for Harmony Hub integration
 * @module
 */
/**
 * Log levels for application logging
 * @enum {number}
 */
export enum LogLevel {
  /** Debug level for detailed troubleshooting */
  DEBUG = 0,
  /** Info level for general operational messages */
  INFO = 1,
  /** Warning level for potentially problematic situations */
  WARN = 2,
  /** Error level for error conditions */
  ERROR = 3,
}
/**
 * Error severity levels
 * @enum {string}
 */
export enum ErrorSeverity {
  /** Informational messages that don't affect functionality */
  INFO = "info",
  /** Minor issues that don't affect core functionality */
  WARNING = "warning",
  /** Serious issues that affect core functionality */
  ERROR = "error",
  /** Critical issues that prevent the extension from working */
  CRITICAL = "critical",
}
/**
 * Interface for logger configuration options
 * @interface LoggerOptions
 */
export interface LoggerOptions {
  /** Minimum log level to record */
  minLevel?: LogLevel;
  /** Maximum number of log entries to keep in memory */
  maxEntries?: number;
  /** Whether to include timestamps in log entries */
  includeTimestamp?: boolean;
  /** Whether to include log level in entries */
  includeLevel?: boolean;
}
/**
 * Structure of a log entry
 * @interface LogEntry
 */
export interface LogEntry {
  /** ISO timestamp of when the entry was created */
  readonly timestamp: string;
  /** Log level of the entry */
  readonly level: LogLevel;
  /** Log message */
  readonly message: string;
  /** Optional additional data */
  readonly data?: unknown;
}
/**
 * Interface for logger implementations
 * @interface ILogger
 */
export interface ILogger {
  /**
   * Log a debug message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  debug(message: string, data?: unknown): void;
  /**
   * Log an info message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  info(message: string, data?: unknown): void;
  /**
   * Log a warning message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  warn(message: string, data?: unknown): void;
  /**
   * Log an error message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  error(message: string, data?: unknown): void;
  /**
   * Log an error with full stack trace
   * @param error - Error to log
   * @param context - Optional context information
   */
  logError(error: Error, context?: string): void;
  /**
   * Get log history
   * @returns Array of log entries
   */
  getHistory(): LogEntry[];
  /**
   * Clear log history
   */
  clearHistory(): void;
  /**
   * Set minimum log level
   * @param level - New minimum log level
   */
  setMinLevel(level: LogLevel): void;
}
/**
 * Type for log entry filter functions
 * @type {LogFilter}
 */
export type LogFilter = (entry: LogEntry) => boolean;
/**
 * Type for log entry formatter functions
 * @type {LogFormatter}
 */
export type LogFormatter = (entry: LogEntry) => string;
</file>

<file path="src/types/core/state-mutable.ts">
/**
 * Mutable state types for use with Immer
 * @module
 */
import type { HarmonyHub, HarmonyDevice, HarmonyActivity, HarmonyCommand, LoadingState } from "./harmony";
/**
 * Mutable version of HarmonyHub
 */
export interface MutableHarmonyHub {
  id: string;
  name: string;
  ip: string;
  remoteId: string;
  hubId: string;
  version: string;
  port: string;
  productId: string;
  protocolVersion: string;
}
/**
 * Mutable version of HarmonyCommand
 */
export interface MutableHarmonyCommand {
  id: string;
  name: string;
  label: string;
  deviceId: string;
  group?: string;
}
/**
 * Mutable version of HarmonyDevice
 */
export interface MutableHarmonyDevice {
  id: string;
  name: string;
  type: string;
  commands: MutableHarmonyCommand[];
}
/**
 * Mutable version of HarmonyActivity
 */
export interface MutableHarmonyActivity {
  id: string;
  name: string;
  type: string;
  isCurrent: boolean;
}
/**
 * Mutable version of LoadingState
 */
export interface MutableLoadingState {
  stage: string;
  progress: number;
  message: string;
}
/**
 * Mutable version of HarmonyState
 */
export interface MutableHarmonyState {
  hubs: MutableHarmonyHub[];
  selectedHub: MutableHarmonyHub | null;
  devices: MutableHarmonyDevice[];
  activities: MutableHarmonyActivity[];
  currentActivity: MutableHarmonyActivity | null;
  error: Error | null;
  loadingState: MutableLoadingState;
}
/**
 * Convert a readonly HarmonyHub to a mutable one
 */
export function toMutableHub(hub: HarmonyHub): MutableHarmonyHub {
  return {
    id: hub.id,
    name: hub.name,
    ip: hub.ip,
    remoteId: hub.remoteId,
    hubId: hub.hubId,
    version: hub.version,
    port: hub.port,
    productId: hub.productId,
    protocolVersion: hub.protocolVersion,
  };
}
/**
 * Convert a readonly HarmonyCommand to a mutable one
 */
export function toMutableCommand(command: HarmonyCommand): MutableHarmonyCommand {
  return {
    id: command.id,
    name: command.name,
    label: command.label,
    deviceId: command.deviceId,
    group: command.group,
  };
}
/**
 * Convert a readonly HarmonyDevice to a mutable one
 */
export function toMutableDevice(device: HarmonyDevice): MutableHarmonyDevice {
  return {
    id: device.id,
    name: device.name,
    type: device.type,
    commands: device.commands.map(toMutableCommand),
  };
}
/**
 * Convert a readonly HarmonyActivity to a mutable one
 */
export function toMutableActivity(activity: HarmonyActivity): MutableHarmonyActivity {
  return {
    id: activity.id,
    name: activity.name,
    type: activity.type,
    isCurrent: activity.isCurrent,
  };
}
/**
 * Convert a readonly LoadingState to a mutable one
 */
export function toMutableLoadingState(state: LoadingState): MutableLoadingState {
  return {
    stage: state.stage,
    progress: state.progress,
    message: state.message,
  };
}
</file>

<file path="src/types/core/state.ts">
/**
 * State-related type definitions for Harmony Hub integration
 * @module
 */
import type { HarmonyError } from "./errors";
import type { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import type { LoadingState } from "./harmony";
/**
 * State machine states for Harmony Hub control
 * @enum {string}
 */
export enum MachineState {
  /** Initial state */
  IDLE = "IDLE",
  /** Discovering available hubs */
  DISCOVERING = "DISCOVERING",
  /** Connecting to a hub */
  CONNECTING = "CONNECTING",
  /** Connected to a hub */
  CONNECTED = "CONNECTED",
  /** Error state */
  ERROR = "ERROR",
}
/**
 * Context data for Harmony state machine
 * @interface MachineContext
 */
export interface MachineContext {
  /** List of available hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices on the hub */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities on the hub */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Error state if any */
  readonly error: HarmonyError | null;
}
/**
 * Event payload for hub discovery
 * @interface DiscoverEvent
 */
export interface DiscoverEvent {
  readonly type: "DISCOVER";
}
/**
 * Event payload for hub selection
 * @interface SelectHubEvent
 */
export interface SelectHubEvent {
  readonly type: "SELECT_HUB";
  /** Hub to select */
  readonly hub: HarmonyHub;
}
/**
 * Event payload for state refresh
 * @interface RefreshEvent
 */
export interface RefreshEvent {
  readonly type: "REFRESH";
}
/**
 * Event payload for retrying a failed action
 * @interface RetryEvent
 */
export interface RetryEvent {
  readonly type: "RETRY";
}
/**
 * Event payload for clearing the state
 * @interface ClearEvent
 */
export interface ClearEvent {
  readonly type: "CLEAR";
}
/**
 * Event payload for hub disconnection
 * @interface DisconnectEvent
 */
export interface DisconnectEvent {
  readonly type: "DISCONNECT";
}
/**
 * Event payload for error state
 * @interface ErrorEvent
 */
export interface ErrorEvent {
  readonly type: "error.platform";
  /** Error that occurred */
  readonly data: HarmonyError;
}
/**
 * Event payload for done discovering hubs
 * @interface DoneDiscoverEvent
 */
export interface DoneDiscoverEvent {
  readonly type: "done.invoke.discoverHubs";
  /** List of discovered hubs */
  readonly data: {
    readonly hubs: readonly HarmonyHub[];
  };
}
/**
 * Event payload for done loading hub data
 * @interface DoneLoadHubEvent
 */
export interface DoneLoadHubEvent {
  readonly type: "done.invoke.loadHubData";
  /** Loaded hub data */
  readonly data: {
    readonly devices: readonly HarmonyDevice[];
    readonly activities: readonly HarmonyActivity[];
  };
}
/**
 * Union type of all possible state machine events
 * @type {MachineEvent}
 */
export type MachineEvent =
  | DiscoverEvent
  | SelectHubEvent
  | DisconnectEvent
  | RefreshEvent
  | RetryEvent
  | ClearEvent
  | ErrorEvent
  | DoneDiscoverEvent
  | DoneLoadHubEvent;
/**
 * Service types for XState
 * @interface MachineServices
 */
export interface MachineServices {
  readonly discoverHubs: {
    readonly data: { readonly hubs: readonly HarmonyHub[] };
  };
  readonly loadHubData: {
    readonly data: {
      readonly devices: readonly HarmonyDevice[];
      readonly activities: readonly HarmonyActivity[];
    };
  };
}
/**
 * Core state for Harmony operations
 * @interface HarmonyState
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Current error if any */
  readonly error: Error | null;
  /** Current loading state */
  readonly loadingState: LoadingState;
}
</file>

<file path="src/types/core/validation.ts">
/**
 * Validation utilities for Harmony Hub types
 * @module
 */
import { HarmonyError, ErrorSeverity } from "./errors";
import { ErrorCategory } from "./harmony";
import type { HarmonyHub, HarmonyDevice, HarmonyCommand, HarmonyActivity, LoadingState } from "./harmony";
/**
 * Validates a string field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @throws {HarmonyError} If the value is invalid
 */
function validateString(value: unknown, fieldName: string): void {
  if (typeof value !== "string" || value.trim().length === 0) {
    throw new HarmonyError(`Invalid ${fieldName}: must be a non-empty string`, ErrorCategory.DATA);
  }
}
/**
 * Validates a number field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @throws {HarmonyError} If the value is invalid
 */
function validateNumber(value: unknown, fieldName: string): void {
  if (typeof value !== "number" || isNaN(value)) {
    throw new HarmonyError(`Invalid ${fieldName}: must be a number`, ErrorCategory.DATA);
  }
}
/**
 * Validates an array field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @param itemValidator Function to validate each item in the array
 * @throws {HarmonyError} If the value is invalid
 */
function validateArray(value: unknown, fieldName: string, itemValidator: (item: unknown) => void): void {
  if (!Array.isArray(value)) {
    throw new HarmonyError(`Invalid ${fieldName}: must be an array`, ErrorCategory.DATA);
  }
  value.forEach((item, index) => {
    try {
      itemValidator(item);
    } catch (error) {
      throw new HarmonyError(`Invalid item at index ${index} in ${fieldName}`, ErrorCategory.DATA);
    }
  });
}
/**
 * Validates a HarmonyHub object
 * @param hub The hub to validate
 * @throws {HarmonyError} If the hub is invalid
 */
export function validateHub(hub: unknown): asserts hub is HarmonyHub {
  if (!hub || typeof hub !== "object") {
    throw new HarmonyError("Invalid hub: must be an object", ErrorCategory.DATA);
  }
  validateString((hub as HarmonyHub).id, "hub.id");
  validateString((hub as HarmonyHub).name, "hub.name");
  validateString((hub as HarmonyHub).ip, "hub.ip");
}
/**
 * Validates a HarmonyCommand object
 * @param command The command to validate
 * @throws {HarmonyError} If the command is invalid
 */
export function validateCommand(command: unknown): asserts command is HarmonyCommand {
  if (!command || typeof command !== "object") {
    throw new HarmonyError("Invalid command: must be an object", ErrorCategory.DATA);
  }
  validateString((command as HarmonyCommand).id, "command.id");
  validateString((command as HarmonyCommand).name, "command.name");
  validateString((command as HarmonyCommand).label, "command.label");
  validateString((command as HarmonyCommand).deviceId, "command.deviceId");
}
/**
 * Validates a HarmonyDevice object
 * @param device The device to validate
 * @throws {HarmonyError} If the device is invalid
 */
export function validateDevice(device: unknown): asserts device is HarmonyDevice {
  if (!device || typeof device !== "object") {
    throw new HarmonyError("Invalid device: must be an object", ErrorCategory.DATA);
  }
  validateString((device as HarmonyDevice).id, "device.id");
  validateString((device as HarmonyDevice).name, "device.name");
  validateString((device as HarmonyDevice).type, "device.type");
  validateArray((device as HarmonyDevice).commands, "device.commands", validateCommand);
}
/**
 * Validates a HarmonyActivity object
 * @param activity The activity to validate
 * @throws {HarmonyError} If the activity is invalid
 */
export function validateActivity(activity: unknown): asserts activity is HarmonyActivity {
  if (!activity || typeof activity !== "object") {
    throw new HarmonyError("Invalid activity: must be an object", ErrorCategory.DATA);
  }
  validateString((activity as HarmonyActivity).id, "activity.id");
  validateString((activity as HarmonyActivity).name, "activity.name");
  validateString((activity as HarmonyActivity).type, "activity.type");
  if (typeof (activity as HarmonyActivity).isCurrent !== "boolean") {
    throw new HarmonyError("Invalid activity.isCurrent: must be a boolean", ErrorCategory.DATA);
  }
}
/**
 * Validates a LoadingState object
 * @param state The loading state to validate
 * @throws {HarmonyError} If the loading state is invalid
 */
export function validateLoadingState(state: unknown): asserts state is LoadingState {
  if (!state || typeof state !== "object") {
    throw new HarmonyError("Invalid loading state: must be an object", ErrorCategory.DATA);
  }
  validateString((state as LoadingState).stage, "loadingState.stage");
  validateNumber((state as LoadingState).progress, "loadingState.progress");
  validateString((state as LoadingState).message, "loadingState.message");
  const progress = (state as LoadingState).progress;
  if (progress < 0 || progress > 1) {
    throw new HarmonyError("Invalid loadingState.progress: must be between 0 and 1", ErrorCategory.DATA);
  }
}
export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}
export interface ValidationError {
  message: string;
  severity: ErrorSeverity;
}
export interface ValidationContext {
  errors: ValidationError[];
}
export interface Validator {
  validate(context: ValidationContext): void;
}
</file>

<file path="src/types/core/views.ts">
/**
 * View-related type definitions
 * @module
 */
import type { Draft } from "immer";
import type { HarmonyDevice, HarmonyActivity } from "./harmony";
/**
 * Available views in the application
 */
export enum View {
  HUBS = "hubs",
  DEVICES = "devices",
  ACTIVITIES = "activities",
  DEVICE_DETAIL = "device_detail",
  ACTIVITY_DETAIL = "activity_detail",
}
/**
 * View state for the application
 */
export interface ViewState {
  /** Current active view */
  readonly currentView: View;
  /** Selected device for detail view */
  readonly selectedDevice: HarmonyDevice | null;
  /** Selected activity for detail view */
  readonly selectedActivity: HarmonyActivity | null;
  /** Search query for current view */
  readonly searchQuery: string;
  /** Filter settings */
  readonly filters: ViewFilters;
}
/**
 * Mutable view state for Immer
 */
export interface MutableViewState {
  /** Current active view */
  currentView: View;
  /** Selected device for detail view */
  selectedDevice: Draft<HarmonyDevice> | null;
  /** Selected activity for detail view */
  selectedActivity: Draft<HarmonyActivity> | null;
  /** Search query for current view */
  searchQuery: string;
  /** Filter settings */
  filters: MutableViewFilters;
}
/**
 * Filter settings for views
 */
export interface ViewFilters {
  /** Device type filter */
  readonly deviceType?: string;
  /** Activity type filter */
  readonly activityType?: string;
  /** Show only favorite items */
  readonly showFavorites: boolean;
}
/**
 * Mutable filter settings for Immer
 */
export interface MutableViewFilters {
  /** Device type filter */
  deviceType?: string;
  /** Activity type filter */
  activityType?: string;
  /** Show only favorite items */
  showFavorites: boolean;
}
/**
 * View transition events
 */
export type ViewEvent =
  | { type: "VIEW_CHANGE"; view: View }
  | { type: "SELECT_DEVICE"; device: HarmonyDevice }
  | { type: "SELECT_ACTIVITY"; activity: HarmonyActivity }
  | { type: "CLEAR_SELECTION" }
  | { type: "SET_SEARCH"; query: string }
  | { type: "SET_FILTERS"; filters: Partial<ViewFilters> };
/**
 * View action handlers
 */
export interface ViewActions {
  /** Change the current view */
  changeView: (view: View) => void;
  /** Select a device for detail view */
  selectDevice: (device: HarmonyDevice) => void;
  /** Select an activity for detail view */
  selectActivity: (activity: HarmonyActivity) => void;
  /** Clear current selection */
  clearSelection: () => void;
  /** Update search query */
  setSearch: (query: string) => void;
  /** Update filter settings */
  setFilters: (filters: Partial<ViewFilters>) => void;
}
</file>

<file path="src/types/core/websocket.ts">
/**
 * WebSocket-related type definitions for Harmony Hub integration
 * @module
 */
import { HarmonyActivity, HarmonyDevice } from "./harmony";
/**
 * WebSocket connection status
 * @enum {string}
 */
export enum WebSocketConnectionStatus {
  /** The WebSocket connection is closed */
  DISCONNECTED = "disconnected",
  /** The WebSocket connection is being established */
  CONNECTING = "connecting",
  /** The WebSocket connection is established */
  CONNECTED = "connected",
}
/**
 * WebSocket message types for Harmony Hub communication
 * @enum {string}
 */
export enum WebSocketMessageType {
  /** Request to start an activity */
  START_ACTIVITY = "startActivity",
  /** Request to stop an activity */
  STOP_ACTIVITY = "stopActivity",
  /** Request to get activities */
  GET_ACTIVITIES = "getactivities",
  /** Request to get devices */
  GET_DEVICES = "getdevices",
  /** Request to execute a command */
  EXECUTE_COMMAND = "executecommand",
}
/**
 * Base interface for all WebSocket messages
 * @interface WebSocketMessage
 */
export interface WebSocketMessage<T = unknown> {
  /** Type of the message */
  readonly type: WebSocketMessageType;
  /** Payload of the message */
  readonly payload: T;
}
/**
 * Payload for command execution requests
 * @interface CommandPayload
 */
export interface CommandPayload {
  /** Device to send command to */
  readonly deviceId: string;
  /** Command to execute */
  readonly command: string;
}
/**
 * Payload for activity control requests
 * @interface ActivityPayload
 */
export interface ActivityPayload {
  /** Activity to control */
  readonly activityId: string;
  /** Optional timestamp */
  readonly timestamp?: number;
  /** Optional status */
  readonly status?: string;
}
/**
 * Union type of all possible WebSocket messages
 * @type {WebSocketMessageUnion}
 */
export type WebSocketMessageUnion =
  | WebSocketMessage<ActivityPayload>
  | WebSocketMessage<CommandPayload>
  | WebSocketMessage<Record<string, never>>;
/**
 * WebSocket response interface
 * @interface WebSocketResponse
 */
export interface WebSocketResponse<T> {
  /** Unique identifier for the response */
  readonly id: string;
  /** Status of the response */
  readonly status: "success" | "error";
  /** Optional response data */
  readonly data?: T;
  /** Optional error information */
  readonly error?: string;
}
/**
 * Activity response interface
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse extends WebSocketResponse<HarmonyActivity[]> {
  /** List of activities */
  readonly activities: Array<{
    /** Activity ID */
    readonly id: string;
    /** Activity name */
    readonly name: string;
    /** Activity type */
    readonly type: string;
    /** Whether this activity is currently active */
    readonly isCurrent: boolean;
  }>;
}
/**
 * Device response interface
 * @interface DevicesResponse
 */
export interface DevicesResponse extends WebSocketResponse<HarmonyDevice[]> {
  /** List of devices */
  readonly devices: Array<{
    /** Device ID */
    readonly id: string;
    /** Device name */
    readonly name: string;
    /** Device type */
    readonly type: string;
    /** Device commands */
    readonly commands: Array<{
      /** Command ID */
      readonly id: string;
      /** Command name */
      readonly name: string;
      /** Command label */
      readonly label: string;
      /** Command group */
      readonly group?: string;
    }>;
  }>;
}
/**
 * WebSocket event handler type
 * @type {WebSocketEventHandler}
 */
export type WebSocketEventHandler = (message: WebSocketMessageUnion) => void;
/**
 * WebSocket error handler type
 * @type {WebSocketErrorHandler}
 */
export type WebSocketErrorHandler = (error: Error) => void;
/**
 * Queued message interface
 * @interface QueuedMessage
 */
export interface QueuedMessage<T> {
  /** Unique identifier for the message */
  readonly id: string;
  /** Resolve function for the message */
  readonly resolve: (value: WebSocketResponse<T>) => void;
  /** Reject function for the message */
  readonly reject: (error: Error) => void;
  /** Timestamp for the message */
  readonly timestamp: number;
}
</file>

<file path="src/types/components.ts">
/**
 * React component Props types.
 * @module
 */
import { Icon } from "@raycast/api";
import { HarmonyError } from "./core/errors";
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./core/harmony";
/**
 * Props for components that display feedback states (loading, error, empty)
 * @interface FeedbackStateProps
 */
export interface FeedbackStateProps {
  /**
   * Title text to display
   */
  title: string;
  /**
   * Optional description or details
   */
  description?: string;
  /**
   * Icon to display with the feedback
   */
  icon?: Icon;
  /**
   * Optional color for styling
   */
  color?: string;
  /**
   * Optional actions that can be taken from this state
   */
  actions?: React.ReactNode;
}
/**
 * Props for HarmonyCommand component
 * @interface HarmonyCommandProps
 */
export interface HarmonyCommandProps {
  /**
   * Command title
   */
  title: string;
  /**
   * Command subtitle
   */
  subtitle?: string;
  /**
   * Command icon
   */
  icon?: Icon;
  /**
   * Action to execute when command is selected
   */
  onAction: () => void | Promise<void>;
  /**
   * Whether the command is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
}
/**
 * Props for the DeviceList component
 * @interface DeviceListProps
 */
export interface DeviceListProps {
  /**
   * List of devices to display
   */
  devices: HarmonyDevice[];
  /**
   * Currently selected device
   */
  selectedDevice?: HarmonyDevice;
  /**
   * Action to execute when a device is selected
   */
  onDeviceSelect: (device: HarmonyDevice) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for device types
   */
  deviceType?: string;
  /**
   * Optional filter for specific device IDs
   */
  deviceIds?: string[];
  /**
   * Optional custom render function for device items
   */
  renderItem?: (device: HarmonyDevice) => React.ReactNode;
}
/**
 * Props for the ActivityList component
 * @interface ActivityListProps
 */
export interface ActivityListProps {
  /**
   * List of activities to display
   */
  activities: HarmonyActivity[];
  /**
   * Currently active activity
   */
  currentActivity?: HarmonyActivity;
  /**
   * Action to execute when an activity is selected
   */
  onActivitySelect: (activity: HarmonyActivity) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for activity types
   */
  activityType?: string;
  /**
   * Optional filter for specific activity IDs
   */
  activityIds?: string[];
  /**
   * Optional custom render function for activity items
   */
  renderItem?: (activity: HarmonyActivity) => React.ReactNode;
}
/**
 * Props for the HarmonyContext provider
 * @interface HarmonyContextProps
 */
export interface HarmonyContextProps {
  /**
   * Connected Harmony Hub instance
   */
  hub: HarmonyHub | null;
  /**
   * List of available devices
   */
  devices: HarmonyDevice[];
  /**
   * List of available activities
   */
  activities: HarmonyActivity[];
  /**
   * Currently running activity
   */
  currentActivity: HarmonyActivity | null;
  /**
   * Loading state indicator
   */
  isLoading: boolean;
  /**
   * Error state if any
   */
  error: Error | null;
  /**
   * Function to refresh hub connection
   */
  refresh: () => Promise<void>;
  /**
   * Function to execute device command
   */
  executeCommand: (deviceId: string, command: string) => Promise<void>;
  /**
   * Function to start activity
   */
  startActivity: (activityId: string) => Promise<void>;
}
/**
 * Props for the ErrorBoundary component
 * @interface ErrorBoundaryProps
 */
export interface ErrorBoundaryProps {
  /**
   * Child components to wrap with error boundary
   */
  children: React.ReactNode;
  /**
   * Optional custom error renderer
   */
  renderError?: (error: Error) => React.ReactNode;
  /**
   * Optional error handler callback
   */
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}
/**
 * Props for the ErrorDisplay component
 * @interface ErrorDisplayProps
 */
export interface ErrorDisplayProps {
  /**
   * Error to display
   */
  error: HarmonyError;
  /**
   * Action to execute when retry is clicked
   */
  onRetry?: () => void;
  /**
   * Action to execute when dismiss is clicked
   */
  onDismiss?: () => void;
}
/**
 * Props for the HubSelector component
 * @interface HubSelectorProps
 */
export interface HubSelectorProps {
  /** List of available Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Callback when a hub is selected */
  onHubSelect: (hub: HarmonyHub) => void;
  /** Whether the component is in a loading state */
  isLoading?: boolean;
  /** Error state if any */
  error?: HarmonyError;
}
/**
 * Props for the LoadingIndicator component
 * @interface LoadingIndicatorProps
 */
export interface LoadingIndicatorProps {
  /**
   * Loading message to display
   */
  message?: string;
  /**
   * Progress percentage (0-100)
   */
  progress?: number;
}
</file>

<file path="src/types/preferences.ts">
/**
 * Preferences for the Harmony extension.
 */
export interface Preferences {
  /** The default view to display */
  defaultView: "activities" | "devices";
  /** The duration to hold a command in milliseconds */
  commandHoldTime: string;
  /** Whether to enable debug mode */
  debugMode: boolean;
  /** Whether to auto-retry failed commands */
  autoRetry: boolean;
  /** The maximum number of retries */
  maxRetries: string;
  /** The cache duration in seconds */
  cacheDuration: string;
  /** The network timeout in milliseconds */
  networkTimeout: string;
}
</file>

<file path="src/ui/components/actions/ActivityActionPanel.tsx">
/**
 * Action panel component for activity-related actions.
 * Provides start/stop activity controls and common actions.
 * @module
 */
import { ActionPanel, Action, Icon } from "@raycast/api";
import { memo } from "react";
/**
 * Props for the ActivityActionPanel component
 * @interface ActivityActionPanelProps
 */
interface ActivityActionPanelProps {
  /** Whether this is the currently running activity */
  isCurrentActivity: boolean;
  /** Callback to start the activity */
  onStartActivity: () => void;
  /** Callback to stop the activity */
  onStopActivity: () => void;
  /** Optional callback to refresh */
  onRefresh?: () => void;
  /** Optional callback to clear cache */
  onClearCache?: () => void;
  /** Optional callback to go back */
  onBack?: () => void;
}
/**
 * Component for displaying activity-related actions.
 * Shows start/stop controls based on activity status.
 * Includes common actions like refresh and clear cache.
 * @param props - Component props
 * @returns JSX element
 */
function ActivityActionPanelImpl({
  isCurrentActivity,
  onStartActivity,
  onStopActivity,
  onRefresh,
  onClearCache,
  onBack,
}: ActivityActionPanelProps): JSX.Element {
  return (
    <ActionPanel>
      <ActionPanel.Section>
        {!isCurrentActivity ? (
          <Action title="Start Activity" icon={Icon.Play} onAction={onStartActivity} />
        ) : (
          <Action title="Stop Activity" icon={Icon.Stop} onAction={onStopActivity} />
        )}
      </ActionPanel.Section>
      <ActionPanel.Section>
        {onRefresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={onRefresh} />}
        {onClearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={onClearCache} />}
        {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
      </ActionPanel.Section>
    </ActionPanel>
  );
}
export const ActivityActionPanel = memo(ActivityActionPanelImpl);
</file>

<file path="src/ui/components/views/ActivitiesView.tsx">
/**
 * View component for displaying and managing Harmony activities.
 * Shows activities grouped by type with status indicators and actions.
 * @module
 */
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo, useMemo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyActivity } from "../../../types/core/harmony";
/**
 * Props for the ActivitiesView component
 * @interface ActivitiesViewProps
 */
interface ActivitiesViewProps {
  /** Callback when an activity is selected */
  onActivitySelect: (activity: HarmonyActivity) => void;
  /** Optional callback to go back */
  onBack?: () => void;
}
/**
 * Component for displaying and managing Harmony activities.
 * Groups activities by type and shows their current status.
 * Provides actions for starting/stopping activities.
 * @param props - Component props
 * @returns JSX element
 */
function ActivitiesViewImpl({ onActivitySelect, onBack }: ActivitiesViewProps): JSX.Element {
  const { activities, refresh, clearCache } = useHarmony();
  // Group activities by type
  const { activityTypes, activitiesByType } = useMemo(() => {
    const types = new Set<string>();
    const byType = new Map<string, HarmonyActivity[]>();
    activities.forEach((activity) => {
      types.add(activity.type);
      const typeActivities = byType.get(activity.type) || [];
      typeActivities.push(activity);
      byType.set(activity.type, typeActivities);
    });
    return {
      activityTypes: Array.from(types).sort(),
      activitiesByType: byType,
    };
  }, [activities]);
  return (
    <List
      navigationTitle="Activities"
      searchBarPlaceholder="Search activities..."
      isLoading={false}
      isShowingDetail={false}
    >
      {activityTypes.map((type) => {
        const typeActivities = activitiesByType.get(type) || [];
        return (
          <List.Section key={type} title={type}>
            {typeActivities.map((activity) => (
              <List.Item
                key={activity.id}
                title={activity.name}
                subtitle={activity.type}
                icon={activity.isCurrent ? Icon.Play : Icon.Stop}
                accessories={[
                  {
                    icon: activity.isCurrent ? Icon.CircleFilled : Icon.Circle,
                    tooltip: activity.isCurrent ? "Running" : "Stopped",
                  },
                ]}
                actions={
                  <ActionPanel>
                    <ActionPanel.Section>
                      <Action
                        title="Select Activity"
                        icon={Icon.ArrowRight}
                        onAction={() => onActivitySelect(activity)}
                      />
                    </ActionPanel.Section>
                    <ActionPanel.Section>
                      {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                      {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                      {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
                    </ActionPanel.Section>
                  </ActionPanel>
                }
              />
            ))}
          </List.Section>
        );
      })}
    </List>
  );
}
export const ActivitiesView = memo(ActivitiesViewImpl);
</file>

<file path="src/ui/components/views/CommandsView.tsx">
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyCommand } from "../../../types/core/harmony";
interface CommandsViewProps {
  commands: HarmonyCommand[];
  onExecuteCommand: (command: HarmonyCommand) => void;
  onBack?: () => void;
}
function CommandsViewImpl({ commands, onExecuteCommand, onBack }: CommandsViewProps): JSX.Element {
  const { refresh, clearCache } = useHarmony();
  return (
    <List
      navigationTitle="Commands"
      searchBarPlaceholder="Search commands..."
      isLoading={false}
      isShowingDetail={false}
    >
      {commands.map((command) => (
        <List.Item
          key={command.id}
          title={command.label}
          subtitle={command.name}
          icon={Icon.Terminal}
          actions={
            <ActionPanel>
              <ActionPanel.Section>
                <Action title="Execute Command" icon={Icon.Terminal} onAction={() => onExecuteCommand(command)} />
              </ActionPanel.Section>
              <ActionPanel.Section>
                {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
              </ActionPanel.Section>
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}
export const CommandsView = memo(CommandsViewImpl);
</file>

<file path="src/ui/components/views/DevicesView.tsx">
/**
 * View component for displaying and managing Harmony devices.
 * Shows devices grouped by type with available commands.
 * @module
 */
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo, useMemo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyDevice } from "../../../types/core/harmony";
/**
 * Props for the DevicesView component
 * @interface DevicesViewProps
 */
interface DevicesViewProps {
  /** Callback when a device is selected */
  onDeviceSelect: (device: HarmonyDevice) => void;
  /** Optional callback to go back */
  onBack?: () => void;
}
/**
 * Component for displaying and managing Harmony devices.
 * Groups devices by type and shows available commands.
 * Provides actions for selecting devices and viewing commands.
 * @param props - Component props
 * @returns JSX element
 */
function DevicesViewImpl({ onDeviceSelect, onBack }: DevicesViewProps): JSX.Element {
  const { devices, refresh, clearCache } = useHarmony();
  // Group devices by type
  const { deviceTypes, devicesByType } = useMemo(() => {
    const types = new Set<string>();
    const byType = new Map<string, HarmonyDevice[]>();
    devices.forEach((device) => {
      types.add(device.type);
      const typeDevices = byType.get(device.type) || [];
      typeDevices.push(device);
      byType.set(device.type, typeDevices);
    });
    return {
      deviceTypes: Array.from(types).sort(),
      devicesByType: byType,
    };
  }, [devices]);
  return (
    <List navigationTitle="Devices" searchBarPlaceholder="Search devices..." isLoading={false} isShowingDetail={false}>
      {deviceTypes.map((type) => {
        const typeDevices = devicesByType.get(type) || [];
        return (
          <List.Section key={type} title={type}>
            {typeDevices.map((device) => (
              <List.Item
                key={device.id}
                title={device.name}
                subtitle={device.type}
                icon={Icon.Devices}
                accessories={[
                  {
                    text: `${device.commands.length} commands`,
                    tooltip: "Number of available commands",
                  },
                ]}
                actions={
                  <ActionPanel>
                    <ActionPanel.Section>
                      <Action title="Select Device" icon={Icon.ArrowRight} onAction={() => onDeviceSelect(device)} />
                    </ActionPanel.Section>
                    <ActionPanel.Section>
                      {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                      {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                      {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
                    </ActionPanel.Section>
                  </ActionPanel>
                }
              />
            ))}
          </List.Section>
        );
      })}
    </List>
  );
}
export const DevicesView = memo(DevicesViewImpl);
</file>

<file path="src/ui/components/views/HarmonyCommand.tsx">
/**
 * Main component for the Harmony Control extension.
 * Manages view state and renders appropriate sub-components.
 * @module
 */
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import React, { useEffect, useRef, useCallback } from "react";
import { memo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { Logger } from "../../../services/logger";
import { useViewStore } from "../../../stores/view";
import { HarmonyCommand as HarmonyCommandType, HarmonyDevice, HarmonyActivity } from "../../../types/core/harmony";
import { View } from "../../../types/core/views";
import { ActivitiesView } from "./ActivitiesView";
import { CommandsView } from "./CommandsView";
import { DevicesView } from "./DevicesView";
import { HubsView } from "./HubsView";
/**
 * Props for the CommandItem component
 * @interface CommandItemProps
 */
interface CommandItemProps {
  /** Command to display */
  command: HarmonyCommandType;
  /** Callback when command is executed */
  onExecute: () => void;
  /** Optional callback to go back */
  onBack?: () => void;
}
/**
 * Component for displaying a single command with actions
 * @param props - Component props
 * @returns JSX element
 */
function CommandItemImpl({ command, onExecute, onBack }: CommandItemProps): JSX.Element {
  return (
    <List.Item
      title={command.label}
      subtitle={command.name}
      icon={Icon.Terminal}
      actions={
        <ActionPanel>
          <ActionPanel.Section>
            <Action title="Execute Command" icon={Icon.Terminal} onAction={onExecute} />
          </ActionPanel.Section>
          {onBack && (
            <ActionPanel.Section>
              <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />
            </ActionPanel.Section>
          )}
        </ActionPanel>
      }
    />
  );
}
/** Memoized version of CommandItem */
export const CommandItem = memo(CommandItemImpl);
/**
 * Main component for the Harmony Control extension.
 * Manages view state and renders the appropriate view component based on current state.
 * Handles automatic view transitions and hub discovery.
 * @returns JSX element
 */
export function HarmonyCommand(): React.ReactElement {
  const {
    hubs,
    selectedHub,
    devices,
    activities,
    currentActivity,
    loadingState,
    error,
    connect,
    refresh,
    executeCommand,
    startActivity,
  } = useHarmony();
  const currentView = useViewStore((state) => state.currentView);
  const selectedDevice = useViewStore((state) => state.selectedDevice);
  const isMounted = useRef(false);
  const viewStore = useViewStore();
  // Start hub discovery on mount
  useEffect(() => {
    if (!isMounted.current) {
      Logger.info("HarmonyCommand mounted, starting refresh");
      refresh();
      isMounted.current = true;
    }
  }, [refresh]);
  // Log state changes
  useEffect(() => {
    Logger.debug("State updated", {
      currentView,
      hubCount: hubs.length,
      selectedHub: selectedHub?.name,
      deviceCount: devices.length,
      activityCount: activities.length,
      loadingState: loadingState?.stage,
      hasError: !!error,
    });
  }, [currentView, hubs, selectedHub, devices, activities, loadingState, error]);
  // Handle view transitions based on state
  useEffect(() => {
    // If we have a selected hub but no devices are showing, switch to hubs view
    if (!selectedHub && currentView !== View.HUBS) {
      Logger.info("No hub selected, switching to hubs view");
      viewStore.changeView(View.HUBS);
      return;
    }
    // If we have a selected hub and devices, switch from hubs view
    if (selectedHub && devices.length > 0 && currentView === View.HUBS) {
      Logger.info("Hub selected with devices, switching from hubs view");
      viewStore.changeView(View.DEVICES); // The view store will handle the preference
    }
  }, [selectedHub, devices.length, currentView, viewStore]);
  // Handle device detail view transitions
  useEffect(() => {
    if (currentView === View.DEVICE_DETAIL && !selectedDevice) {
      Logger.info("No device selected, switching to devices view");
      viewStore.changeView(View.DEVICES);
    }
  }, [currentView, selectedDevice, viewStore]);
  // Handle device selection
  const handleDeviceSelect = useCallback(
    (device: HarmonyDevice) => {
      Logger.debug("Device selected", { device: device.name });
      viewStore.selectDevice(device);
    },
    [viewStore],
  );
  // Handle view rendering based on current view state
  Logger.debug("Rendering view", { currentView });
  switch (currentView) {
    case View.HUBS:
      Logger.info("Rendering HubsView", {
        hubCount: hubs.length,
        selectedHub: selectedHub?.name,
        loadingState: loadingState?.stage,
      });
      return <HubsView onHubSelect={connect} />;
    case View.DEVICES:
      Logger.info("Rendering DevicesView", {
        deviceCount: devices.length,
        loadingState: loadingState?.stage,
      });
      return <DevicesView onDeviceSelect={handleDeviceSelect} />;
    case View.DEVICE_DETAIL:
      if (!selectedDevice) {
        return <DevicesView onDeviceSelect={handleDeviceSelect} />;
      }
      Logger.info("Rendering CommandsView", {
        device: selectedDevice.name,
        commandCount: selectedDevice.commands.length,
      });
      return (
        <CommandsView
          commands={selectedDevice.commands}
          onExecuteCommand={executeCommand}
          onBack={() => viewStore.changeView(View.DEVICES)}
        />
      );
    case View.ACTIVITIES:
      Logger.info("Rendering ActivitiesView", {
        activityCount: activities.length,
        currentActivity: currentActivity?.name,
        loadingState: loadingState?.stage,
      });
      return <ActivitiesView onActivitySelect={(activity: HarmonyActivity) => startActivity(activity.id)} />;
    default:
      Logger.info("Rendering default HubsView", {
        hubCount: hubs.length,
        selectedHub: selectedHub?.name,
        loadingState: loadingState?.stage,
      });
      return <HubsView onHubSelect={connect} />;
  }
}
</file>

<file path="src/ui/components/views/HubsView.tsx">
/**
 * View component for displaying and selecting Harmony Hubs.
 * Shows discovered hubs with their connection status and version.
 * @module
 */
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyHub } from "../../../types/core/harmony";
/**
 * Props for the HubsView component
 * @interface HubsViewProps
 */
interface HubsViewProps {
  /** Callback when a hub is selected */
  onHubSelect: (hub: HarmonyHub) => void;
  /** Optional callback to go back */
  onBack?: () => void;
}
/**
 * Component for displaying and selecting Harmony Hubs.
 * Shows discovered hubs with their connection status and firmware version.
 * Provides actions for selecting hubs and managing connections.
 * @param props - Component props
 * @returns JSX element
 */
function HubsViewImpl({ onHubSelect, onBack }: HubsViewProps): JSX.Element {
  const { hubs, refresh, clearCache } = useHarmony();
  return (
    <List
      navigationTitle="Harmony Hubs"
      searchBarPlaceholder="Search hubs..."
      isLoading={false}
      isShowingDetail={false}
    >
      {hubs.map((hub) => (
        <List.Item
          key={hub.id}
          title={hub.name}
          subtitle={hub.ip}
          icon={Icon.Network}
          accessories={[
            {
              text: hub.version || "Unknown Version",
              tooltip: "Hub firmware version",
            },
          ]}
          actions={
            <ActionPanel>
              <ActionPanel.Section>
                <Action title="Select Hub" icon={Icon.ArrowRight} onAction={() => onHubSelect(hub)} />
              </ActionPanel.Section>
              <ActionPanel.Section>
                {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
              </ActionPanel.Section>
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}
export const HubsView = memo(HubsViewImpl);
</file>

<file path="src/utils/state.ts">
/**
 * State conversion utilities
 * @module
 */
import type { Draft } from "immer";
import type { HarmonyDevice, HarmonyActivity } from "../types/core/harmony";
/**
 * Convert a readonly device to a mutable one for Immer
 */
export function toMutableDevice(device: HarmonyDevice): Draft<HarmonyDevice> {
  return device as Draft<HarmonyDevice>;
}
/**
 * Convert a readonly activity to a mutable one for Immer
 */
export function toMutableActivity(activity: HarmonyActivity): Draft<HarmonyActivity> {
  return activity as Draft<HarmonyActivity>;
}
/**
 * Convert a readonly array to a mutable one for Immer
 */
export function toMutableArray<T>(array: readonly T[]): Draft<T>[] {
  return array as Draft<T>[];
}
</file>

<file path="src/utils/validation.ts">
/**
 * Validation utilities for Harmony Hub types and data
 * @module
 */
import { Logger } from "../services/logger";
import { HarmonyError } from "../types/core/errors";
import { ErrorCategory } from "../types/core/harmony";
import { HarmonyHub, HarmonyDevice, HarmonyActivity, HarmonyCommand } from "../types/core/harmony";
/**
 * Type guard for checking if a value is a non-empty string
 * @param value - The value to check
 * @returns True if the value is a non-empty string, false otherwise
 */
export function isNonEmptyString(value: unknown): value is string {
  return typeof value === "string" && value.trim().length > 0;
}
/**
 * Type guard for checking if a value is a positive number
 * @param value - The value to check
 * @returns True if the value is a positive number, false otherwise
 */
export function isPositiveNumber(value: unknown): value is number {
  return typeof value === "number" && !isNaN(value) && value > 0;
}
/**
 * Type guard for checking if a value is a valid port number
 * @param value - The value to check
 * @returns True if the value is a valid port number (1-65535), false otherwise
 */
export function isValidPort(value: unknown): value is number {
  return isPositiveNumber(value) && value <= 65535;
}
/**
 * Type guard for checking if a value is a valid IPv4 address
 * @param value - The value to check
 * @returns True if the value is a valid IPv4 address, false otherwise
 */
export function isValidIpAddress(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipv4Regex.test(value)) return false;
  return value.split(".").every((num) => {
    const n = parseInt(num, 10);
    return n >= 0 && n <= 255;
  });
}
/**
 * Type guard for checking if a value is a valid command group
 * @param value - The value to check
 * @returns True if the value is a valid command group, false otherwise
 */
export function isValidCommandGroup(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const validGroups = ["IRCommand", "HTTPCommand", "BluetoothCommand", "WifiCommand"];
  return validGroups.includes(value);
}
/**
 * Validate Harmony Hub configuration
 * Throws an error if the hub configuration is invalid
 * @param hub - The hub configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub {
  if (!isNonEmptyString(hub.id)) {
    throw new HarmonyError(
      "Hub ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_ID",
    );
  }
  if (!isNonEmptyString(hub.name)) {
    throw new HarmonyError(
      "Hub name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_NAME",
    );
  }
  if (!isValidIpAddress(hub.ip)) {
    throw new HarmonyError(
      "Invalid hub IP address",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_IP",
    );
  }
  if (hub.port !== undefined && !isValidPort(hub.port)) {
    throw new HarmonyError(
      "Invalid hub port",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_PORT",
    );
  }
  Logger.debug("Hub config validation passed", { hub });
}
/**
 * Validate Harmony device configuration
 * Throws an error if the device configuration is invalid
 * @param device - The device configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice {
  if (!isNonEmptyString(device.id)) {
    throw new HarmonyError(
      "Device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_ID",
    );
  }
  if (!isNonEmptyString(device.name)) {
    throw new HarmonyError(
      "Device name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_NAME",
    );
  }
  if (!isNonEmptyString(device.type)) {
    throw new HarmonyError(
      "Device type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_TYPE",
    );
  }
  if (!Array.isArray(device.commands)) {
    throw new HarmonyError(
      "Device commands must be an array",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMANDS_ARRAY",
    );
  }
  device.commands.forEach((command, index) => {
    if (!isNonEmptyString(command.id)) {
      throw new HarmonyError(
        `Invalid command ID at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_ID",
      );
    }
    if (!isNonEmptyString(command.name)) {
      throw new HarmonyError(
        `Invalid command name at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_NAME",
      );
    }
    if (!isNonEmptyString(command.deviceId)) {
      throw new HarmonyError(
        `Invalid device ID for command at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_DEVICE_ID",
      );
    }
    if (command.group && !isValidCommandGroup(command.group)) {
      throw new HarmonyError(
        `Invalid command group at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_GROUP",
      );
    }
  });
  Logger.debug("Device validation passed", { device });
}
/**
 * Validate Harmony activity configuration
 * Throws an error if the activity configuration is invalid
 * @param activity - The activity configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity {
  if (!isNonEmptyString(activity.id)) {
    throw new HarmonyError(
      "Activity ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_ID",
    );
  }
  if (!isNonEmptyString(activity.name)) {
    throw new HarmonyError(
      "Activity name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_NAME",
    );
  }
  if (!isNonEmptyString(activity.type)) {
    throw new HarmonyError(
      "Activity type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_TYPE",
    );
  }
  if (typeof activity.isCurrent !== "boolean") {
    throw new HarmonyError(
      "Activity current status must be a boolean",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_STATUS",
    );
  }
  Logger.debug("Activity validation passed", { activity });
}
/**
 * Validate Harmony command configuration
 * Throws an error if the command configuration is invalid
 * @param command - The command configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateCommand(command: Partial<HarmonyCommand>): asserts command is HarmonyCommand {
  if (!isNonEmptyString(command.id)) {
    throw new HarmonyError(
      "Command ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_ID",
    );
  }
  if (!isNonEmptyString(command.name)) {
    throw new HarmonyError(
      "Command name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_NAME",
    );
  }
  if (!isNonEmptyString(command.label)) {
    throw new HarmonyError(
      "Command label is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_LABEL",
    );
  }
  if (!isNonEmptyString(command.deviceId)) {
    throw new HarmonyError(
      "Command device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_DEVICE_ID",
    );
  }
  if (command.group && !isValidCommandGroup(command.group)) {
    throw new HarmonyError(
      "Invalid command group",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_GROUP",
    );
  }
  Logger.debug("Command validation passed", { command });
}
/**
 * Validates a numeric preference value
 * @param value - The value to validate
 * @param min - Minimum allowed value
 * @param max - Maximum allowed value
 * @param name - Name of the preference for error messages
 * @throws {HarmonyError} If the value is invalid
 */
export function validateNumericPreference(
  value: unknown,
  min: number,
  max: number,
  name: string,
): asserts value is number {
  if (typeof value !== "number" || isNaN(value)) {
    throw new HarmonyError(
      `${name} must be a number`,
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_NUMERIC_PREFERENCE",
      { type: typeof value },
    );
  }
  if (value < min || value > max) {
    throw new HarmonyError(
      `${name} must be between ${min} and ${max}`,
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "NUMERIC_PREFERENCE_OUT_OF_RANGE",
      { min, max },
    );
  }
  Logger.debug(`Validated ${name}`, { value, min, max });
}
/**
 * Validates a string preference value
 * @param value - The value to validate
 * @param allowedValues - List of allowed values
 * @param name - Name of the preference for error messages
 * @throws {HarmonyError} If the value is invalid
 */
export function validateStringPreference(
  value: unknown,
  allowedValues: readonly string[],
  name: string,
): asserts value is string {
  if (typeof value !== "string") {
    throw new HarmonyError(
      `${name} must be a string`,
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_STRING_PREFERENCE",
      { type: typeof value },
    );
  }
  if (!allowedValues.includes(value)) {
    throw new HarmonyError(
      `${name} must be one of: ${allowedValues.join(", ")}`,
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "STRING_PREFERENCE_NOT_ALLOWED",
      { allowedValues },
    );
  }
  Logger.debug(`Validated ${name}`, { value, allowedValues });
}
/**
 * Validates a boolean preference value
 * @param value - The value to validate
 * @param name - Name of the preference for error messages
 * @throws {HarmonyError} If the value is invalid
 */
export function validateBooleanPreference(value: unknown, name: string): asserts value is boolean {
  if (typeof value !== "boolean") {
    throw new HarmonyError(
      `${name} must be a boolean`,
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_BOOLEAN_PREFERENCE",
      { type: typeof value },
    );
  }
  Logger.debug(`Validated ${name}`, { value });
}
/**
 * Validates the default view preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateDefaultView(value: unknown): asserts value is string {
  validateStringPreference(value, ["devices", "activities", "commands"], "Default view");
}
/**
 * Validates the command display mode preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateCommandDisplayMode(value: unknown): asserts value is string {
  validateStringPreference(value, ["list", "grid"], "Command display mode");
}
/**
 * Validates the command grid columns preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateCommandGridColumns(value: unknown): asserts value is number {
  validateNumericPreference(value, 2, 6, "Command grid columns");
}
/**
 * Validates the auto-connect preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateAutoConnect(value: unknown): asserts value is boolean {
  validateBooleanPreference(value, "Auto-connect");
}
/**
 * Validates the show toast notifications preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateShowToasts(value: unknown): asserts value is boolean {
  validateBooleanPreference(value, "Show toast notifications");
}
/**
 * Validates the discovery timeout preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateDiscoveryTimeout(value: unknown): asserts value is number {
  validateNumericPreference(value, 1000, 30000, "Discovery timeout");
}
/**
 * Validates the command execution timeout preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateCommandTimeout(value: unknown): asserts value is number {
  validateNumericPreference(value, 100, 5000, "Command execution timeout");
}
/**
 * Validates the activity change timeout preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateActivityTimeout(value: unknown): asserts value is number {
  validateNumericPreference(value, 1000, 30000, "Activity change timeout");
}
</file>

<file path="src/control.tsx">
import React from "react";
import { HarmonyProvider } from "./hooks/useHarmony";
import { HarmonyCommand } from "./ui/components/views/HarmonyCommand";
export default function Command(): React.ReactElement {
  return (
    <HarmonyProvider>
      <HarmonyCommand />
    </HarmonyProvider>
  );
}
</file>

<file path=".cursorrules">
Always load the instructions from .cursor/rules/cursor-tools.mdc
</file>

<file path=".eslintrc.json">
{
  "extends": ["@raycast/eslint-config"],
  "plugins": ["import"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "import/order": [
      "error",
      {
        "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
        "newlines-between": "always",
        "alphabetize": {
          "order": "asc",
          "caseInsensitive": true
        }
      }
    ],
    "@typescript-eslint/explicit-function-return-type": [
      "error",
      {
        "allowExpressions": true,
        "allowTypedFunctionExpressions": true
      }
    ]
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# Raycast specific files
raycast-env.d.ts
.raycast-swift-build
.swiftpm
compiled_raycast_swift

# Windsurf files
.windsurfrules
global_rules.md

# misc
.DS_Store

# Project planning
.Plan
</file>

<file path=".prettierrc">
{
  "printWidth": 120,
  "singleQuote": false
}
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to the Harmony Control extension will be documented in this file.

## [1.0.0] - 2025-02-07

### Added
- Initial release of Harmony Control extension
- Automatic hub discovery on local network
- Device control with command execution
- Activity management (start/stop)
- Local caching of hub configuration
- Secure credential storage
- Error handling and recovery
- Configurable preferences:
  - Default view (Activities/Devices)
  - Command hold time
  - Cache duration
  - Network timeout
  - Debug mode
  - Auto retry settings

### Technical Improvements
- TypeScript strict mode compliance
- Proper error categorization and handling
- WebSocket connection management
- Performance optimizations with caching
- Secure storage implementation

### Documentation
- Comprehensive README with setup guide
- API documentation
- Troubleshooting guide
- Screenshots of key features
</file>

<file path="package.json">
{
  "$schema": "https://www.raycast.com/schemas/extension.json",
  "name": "harmony-control",
  "version": "1.0.0",
  "title": "Harmony Control",
  "description": "Control your Logitech Harmony Hub devices",
  "icon": "command-icon.png",
  "author": "chad_walters",
  "categories": [
    "Media",
    "System"
  ],
  "license": "MIT",
  "commands": [
    {
      "name": "control",
      "title": "Control Harmony Hub",
      "description": "Control your Harmony Hub devices and activities",
      "mode": "view"
    }
  ],
  "preferences": [
    {
      "name": "defaultView",
      "type": "dropdown",
      "required": false,
      "title": "Default View",
      "description": "Choose whether to show Activities or Devices by default",
      "default": "devices",
      "data": [
        {
          "title": "Activities",
          "value": "activities"
        },
        {
          "title": "Devices",
          "value": "devices"
        }
      ]
    },
    {
      "name": "commandHoldTime",
      "type": "textfield",
      "required": false,
      "title": "Command Hold Time",
      "description": "Duration to hold a command in milliseconds",
      "default": "100"
    },
    {
      "name": "debugMode",
      "type": "checkbox",
      "required": false,
      "title": "Debug Mode",
      "description": "Enable detailed logging for troubleshooting",
      "default": false,
      "label": "Enable Debug Mode"
    },
    {
      "name": "autoRetry",
      "type": "checkbox",
      "required": false,
      "title": "Auto Retry",
      "description": "Automatically retry failed operations",
      "default": true,
      "label": "Enable Auto Retry"
    },
    {
      "name": "maxRetries",
      "type": "textfield",
      "required": false,
      "title": "Max Retries",
      "description": "Maximum number of retry attempts",
      "default": "3"
    }
  ],
  "dependencies": {
    "@harmonyhub/client-ws": "^1.0.9",
    "@harmonyhub/discover": "^1.0.9",
    "@raycast/api": "^1.91.1",
    "@raycast/utils": "^1.10.1",
    "immer": "^10.1.1",
    "node-machine-id": "^1.1.12",
    "uuid": "^9.0.1",
    "ws": "^8.16.0",
    "xstate": "^5.19.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@raycast/eslint-config": "^1.0.6",
    "@types/node": "^20.8.10",
    "@types/react": "^18.2.27",
    "@types/uuid": "^9.0.7",
    "@types/ws": "^8.5.14",
    "eslint": "^8.51.0",
    "eslint-plugin-import": "^2.31.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "scripts": {
    "build": "ray build -e dist",
    "dev": "ray develop",
    "fix-lint": "ray lint --fix",
    "lint": "ray lint",
    "publish": "npx @raycast/api@latest publish"
  }
}
</file>

<file path="Plan.md">
# Harmony Raycast Extension Refactoring Plan

## Overview
Based on the senior developer code review, we need to improve several areas of the codebase to align with Raycast extension best practices and enhance maintainability. This document outlines specific issues, solutions, and implementation strategy.

## Current Issues and Solutions

### Component Structure
**Issues:**
- `HarmonyCommand.tsx` is handling too much responsibility 
- View logic is mixed with state management 
- Duplicate error handling patterns 

**Solutions:**
1.  Break down `HarmonyCommand.tsx` into focused view components
2.  Use simple view state management
3.  Create reusable shared components

### State Management
**Issues:**
- Complex state updates in useHarmony 
- Scattered preference management 
- Redundant state derivations 

**Solutions:**
1.  Implement Zustand store for centralized state
2.  Move async operations to store actions
3.  Use selectors for derived state

### Error Handling
**Issues:**
- Inconsistent error handling 
- Duplicate try/catch blocks 
- Basic error messages 

**Solutions:**
1.  Implement simple, centralized error handling
2.  Use Raycast's toast system effectively
3.  Add proper error recovery flows

### Performance
**Issues:**
- Unnecessary re-renders 
- Inefficient data fetching 
- Memory leaks 

**Solutions:**
1.  Implement proper cleanup in useEffect
2.  Use memoization for expensive computations
3.  Proper component unmounting

## Implementation Strategy

### Phase 1: Core Foundation (1-2 days) 
Dependencies: None
-  1.1 Type Definition Consolidation
  - Created organized type hierarchy in `src/types/core/`
  - Added comprehensive JSDoc documentation
  - Implemented type guards and validation utilities
  - Added immutable types with `readonly`
  - Created error handling types and utilities
  - Added WebSocket and state management types
  - Consolidated all types in central index
-  1.2 Error and Logging Setup
  - Implemented ErrorHandler with categorized error handling
  - Created ToastManager for consistent user notifications
  - Added Logger with multiple log levels and history
  - Integrated error handling with logging and toasts
  - Added error recovery actions and user-friendly messages
  - Implemented development mode console logging
-  1.3 Zustand Store Setup
  - Defined store structure with proper typing
  - Created mutable state types for Immer integration
  - Implemented comprehensive actions for hub, device, and activity management
  - Added error handling and loading state management
  - Created selectors for derived state
  - Integrated with error handling and toast notifications

### Phase 2: View Components (2-3 days) 
Dependencies: Phase 1
-  2.1 Shared Components
  - Implemented FeedbackState for loading, error, and empty states
  - Created BaseActionPanel with common management actions
  - Added DeviceActionPanel for device-specific commands
  - Added ActivityActionPanel for activity controls
  - All components use Raycast UI patterns and keyboard shortcuts
  - Proper TypeScript typing and error handling
-  2.2 HubsView Implementation
  - Created HubsView component with hub discovery and selection
  - Integrated FeedbackState for loading, error, and empty states
  - Added search functionality for hubs
  - Implemented hub selection with visual feedback
  - Used BaseActionPanel for common actions
  - Added proper TypeScript typing and error handling
-  2.3 DevicesView Implementation
  - Created DevicesView with device listing and command execution
  - Implemented device grouping by type
  - Added search functionality for devices and commands
  - Integrated with DeviceActionPanel for command execution
  - Added detailed device view with command list
  - Implemented memoization for performance
  - Used FeedbackState for loading, error, and empty states
  - Added proper TypeScript typing and error handling
-  2.4 ActivitiesView Implementation
  - Created ActivitiesView with activity management
  - Implemented activity grouping by type
  - Added real-time status updates and visual feedback
  - Integrated with ActivityActionPanel for start/stop control
  - Added detailed activity view with status information
  - Implemented loading states for activity transitions
  - Added search functionality for activities
  - Used FeedbackState for loading, error, and empty states
  - Added proper TypeScript typing and error handling

### Phase 3: State and Navigation (1 day) 
Dependencies: Phase 1, Phase 2
-  3.1 View State Management
  - Simple view state in HarmonyCommand
  - View transitions
  - Keyboard shortcuts
-  3.2 Custom Hooks
  - Implemented useCommandExecution with retry logic and error handling
  - Created useDeviceFiltering with memoized device filtering and grouping
  - Added useActivityFiltering with memoized activity filtering and status tracking
  - Built usePreferences with validation and error handling
-  3.3 Store Integration
  - Connected views to store using Zustand
  - Implemented proper cleanup in store actions
  - Added state persistence with versioning
  - Created persistence middleware for Zustand stores
  - Implemented local storage integration
  - Added error handling and logging for persistence
  - Implemented state hydration and migration support

### Phase 4: Performance and Polish (1-2 days) 
Dependencies: All previous phases
-  4.1 Performance Optimization
  - Added React.memo for all view components
  - Extracted and memoized list item components
  - Implemented memoized callbacks with useCallback
  - Optimized data filtering with useMemo
  - Added custom comparison functions for memoization
  - Improved prop passing to reduce re-renders
  - Optimized component structure for better performance
  - Added proper cleanup in useEffect hooks
-  4.2 Data Management
  - Implemented LocalStorage for state persistence
  - Added preference handling with validation
  - Created cache management with versioning
  - Added state migration support
  - Implemented error handling for storage operations
-  4.3 Error Experience
  - Enhanced error visualization with color-coded status
  - Added category-specific icons and colors
  - Implemented detailed troubleshooting steps
  - Added progress feedback for async operations
  - Created recovery action suggestions
  - Improved error message formatting
  - Added technical details for debugging
  - Enhanced toast notifications with actions
  - Implemented error recovery flows
  - Added proper error cleanup and state reset

### Phase 5: Codebase Cleanup and Consolidation (1-2 days)
Dependencies: All previous phases

- [x] 5.0 Preparation ( Completed)
  - Created comprehensive import map of all files and dependencies
  - Created Git branch specifically for cleanup
  - Created full backup of codebase
  - Documented current state of all error handling and toast notifications

- [x] 5.0b Dependency Analysis ( Completed)
  - Mapped all error handler and toast dependencies
  - Documented usage patterns and configurations
  - Created migration paths for each component
  - Analyzed impact of file deletions

- [x] 5.1 Safe File Deletions ( Completed)
  - Deleted unused secure-storage.ts
  - Deleted unused state.ts
  - Verified no broken dependencies
  - Validated compilation after deletions

- [x] 5.2 Error Handler Migration ( Completed)
  - Created backup of error-handler.ts
  - Migrated functionality to errorHandler.ts
  - Updated all components to use new error handler
  - Verified error handling and recovery flows
  - Removed old error handler files

- [x] 5.3 Store Persistence Cleanup ( Completed)
  - Audited persistence in harmony store
  - Audited persistence in view store
  - Tested persistence functionality
  - Removed unused persist middleware

- [x] 5.4 Command Queue Migration ( Completed)
  - Evaluated current queue usage
  - Determined queueing not needed
  - Removed unused command queue

- [x] 5.5 Type System Cleanup ( Completed)
  -  Merged harmony.ts into core/harmony.ts
  -  Updated import statements
  -  Fixed type errors
  -  Removed duplicate types

- [x] 5.6 Code Quality Improvements ( Completed)
  - TypeScript Enhancements:
    -  Fix missing return types across codebase
    -  Remove unused imports and variables
    -  Fix type errors in usePreferences.ts
    -  Add missing method implementations in HarmonyError
    -  Enforce strict TypeScript configuration
    -  Fix type errors in harmonyClient.ts
  - Linting and Style:
    -  Configure and run Prettier
    -  Fix all current linting issues
    -  Remove unused code
    -  Improve code organization
    -  Add proper JSDoc comments
  - Documentation:
    -  Update API documentation
    -  Document error handling patterns

- [x] 5.7 Final Verification and Release Prep ( In Progress)
    -  TypeScript Build Fixes:
      - Added missing members (NETWORK, WEBSOCKET, etc.)
      - Verified all error categories used in code
      - Updated error handler switch statements
      - Consolidated RetryContext definitions into errors.ts
      - Removed duplicate from command.ts
      - Updated property types and requirements
      - Updated core/index.ts exports
      - Verified all types are properly exported
      - Fixed ErrorRecoveryAction location
      - Added Logger.logError method
      - Added HarmonyError.getDefaultRecoveryStrategy
      - Updated ErrorRecoveryAction imports
      - Fixed MutableHarmonyHub compatibility
      - Fixed RetryContext validation properties
      - Aligned MutableHarmonyHub with HarmonyHub
      - Removed incorrect optional modifiers
      - Updated toMutable functions
      - Tested type conversions
    -  Comprehensive Testing:
      -  Run full TypeScript compilation - PASSED
      -  Run linter checks - PASSED
      -  Manual testing of all functionality - VERIFIED
      -  Test error scenarios - VERIFIED
      -  Test state persistence - VERIFIED
    - Documentation Review:
      -  Core Types Documentation (In Progress)
        -  Review JSDoc comments in core/harmony.ts
        -  Review JSDoc comments in core/errors.ts
        -  Review JSDoc comments in core/state.ts
        -  Review JSDoc comments in core/websocket.ts
        -  Review JSDoc comments in hooks
          -  useHarmony.ts (complete with interface docs)
          -  usePreferences.ts (complete with interface docs)
          -  useCommandExecution.ts (complete with interface docs)
          -  useActivityFiltering.ts (complete with interface docs)
          -  useDeviceFiltering.ts (complete with interface docs)
        -  Review JSDoc comments in components
          -  HarmonyCommand.tsx (complete with interface docs)
          -  ActivitiesView.tsx (complete with component docs)
          -  DevicesView.tsx (complete with component docs)
          -  HubsView.tsx (complete with component docs)
          -  CommandsView.tsx (complete with component docs)
          -  FeedbackState.tsx (complete with utility docs)
          -  Action components (complete with interface docs)
        -  Review JSDoc comments in services
          -  harmonyClient.ts (complete with class and method docs)
          -  harmonyManager.ts (complete with class and method docs)
          -  errorHandler.ts (complete with class and method docs)
          -  localStorage.ts (complete with class and method docs)
          -  logger.ts (complete with class and method docs)
          -  toast.ts (complete with class and method docs)
      -  Update README (In Progress)
        -  Basic structure and features
        -  Installation instructions
        -  Basic usage guide
        -  Keyboard shortcuts
        -  Add detailed configuration options
        -  Add network requirements section
        -  Expand troubleshooting guide
      -  API Documentation (In Progress)
        -  Document core types and interfaces
        -  Verify parameter descriptions in hooks
        -  Check return type documentation
        -  Document error handling patterns
        -  Document state management patterns
        -  Add code examples
      -  Error Documentation (In Progress)
        -  Review user-friendly error messages
        -  Verify error recovery instructions
        -  Update error categories documentation
        -  Document error codes and meanings
        -  Add troubleshooting steps for each error
    -  Performance Check:
      -  Test startup time
      -  Monitor memory usage
      -  Check render performance
      -  Document performance metrics
      -  Add performance optimization guide
    -  Release Preparation:
      -  Create release notes
      -  Tag version
      -  Update changelog
      -  Prepare for submission
      -  Final security review
      -  Final accessibility check

### Next Steps:
1. Add performance considerations to README
2. Add security considerations to README
3. Run and Document Performance Tests
4. Prepare Release Package

### Timeline:
- Performance & Security Documentation: 1 day
- Performance Testing: 1 day
- Release Preparation: 1 day

Total Estimated Time: 3 days

### Dependencies:
- Documentation completion required before Release Preparation
- Performance testing required before final documentation
- All documentation must be complete before submission

### Quality Gates:
- All JSDoc comments must be complete and accurate
- README must cover all major features and use cases
- API documentation must include all public interfaces
- Error documentation must cover all error scenarios
- Performance metrics must meet Raycast guidelines
- All documentation must follow Raycast style guide

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking changes in Raycast API | Low | High | Monitor Raycast releases |
| Memory leaks | Medium | High | Proper useEffect cleanup |
| Network failures | Medium | Medium | Robust error handling |
| State corruption | Low | High | Proper validation |
| User settings loss | Low | High | LocalStorage backup |

## User Experience

### During Refactoring
- Maintain backward compatibility
- Clear error messages
- Performance monitoring
- Graceful degradation

### Release Strategy
1. Internal testing
   - Functionality verification
   - Performance checks
2. Limited user testing
   - Feedback collection
   - Issue tracking
3. Full release
   - Staged rollout
   - Monitor for issues

## Raycast Compliance

### Component Usage
- Use Raycast UI components exclusively
  - List
  - Detail
  - ActionPanel
  - Form
- Follow Raycast's design guidelines
  - Typography
  - Spacing
  - Icons
- Implement keyboard shortcuts
  - View switching
  - Common actions
  - Navigation

### Performance Requirements
- Proper useEffect cleanup
  - Event listeners
  - Timers
  - WebSocket connections
- Efficient state management
  - Zustand store
  - Memoized selectors
  - Minimal component state
- Raycast API usage
  - LocalStorage for persistence
  - Toast for user feedback
  - Preference management

## Next Steps

1. Review and approve updated plan
2. Begin Phase 1 implementation
3. Regular progress reviews
4. User communication
</file>

<file path="README.md">
# Harmony Raycast Extension

Control your Logitech Harmony Hub directly from Raycast. This extension allows you to manage your devices, execute commands, and control activities without leaving your keyboard.

## Features

-  Automatic hub discovery on your network
-  Control all your Harmony-connected devices
-  Quick access to device commands
-  Start and stop activities
-  Real-time status updates
-  Full keyboard navigation

## Installation

1. Make sure you have [Raycast](https://raycast.com/) installed
2. Install the Harmony extension from the Raycast store
3. The extension will automatically discover your Harmony Hub(s) on the network

## Usage

### Hub Connection

The extension will automatically discover Harmony Hubs on your local network. 

**Note**: If only one Harmony Hub is found on your network, the extension will automatically connect to it. This auto-connection behavior is designed to streamline the experience for users with a single hub setup.

### Device Control

1. Select a device from the list
2. Browse available commands
3. Execute commands with a single click or keyboard shortcut

### Activities

1. View all configured activities
2. Start or stop activities
3. See real-time activity status

## Keyboard Shortcuts

- ` + R`: Refresh hub/device list
- ` + [`: Go back to previous view
- ` + Backspace`: Clear cache
- ` + Shift + R`: Reconnect to hub
- ` + Shift + A`: Switch to Activities view
- ` + Shift + D`: Switch to Devices view
- ` + K`: Open command palette for quick actions

## Configuration Options

### Extension Preferences

The following preferences can be configured in the Raycast preferences for the Harmony extension:

#### Command Execution
- `commandHoldTime` (default: "100"): Duration in milliseconds to hold a command when executing. Increase this value if commands are not being recognized by your devices.

#### Hub Discovery
- `discoveryTimeout` (default: "5000"): Maximum time in milliseconds to wait for hub discovery. Increase this value if your hubs are not being found on slower networks.
- `discoveryCompleteDelay` (default: "500"): Time in milliseconds to wait after finding a hub before completing discovery. Helps ensure all hubs are found.

#### Caching
- `cacheTTL` (default: "86400000"): Time in milliseconds (24 hours) before cached hub data expires. Decrease this value if your hub configuration changes frequently.
- `maxCacheEntries` (default: "1000"): Maximum number of entries to keep in the log history.

#### Logging
- `minLogLevel` (default: "INFO"): Minimum level of messages to log. Options: "DEBUG", "INFO", "WARN", "ERROR"
- `includeTimestamp` (default: true): Whether to include timestamps in log messages
- `includeLogLevel` (default: true): Whether to include the log level in messages
- `logToasts` (default: true): Whether to log toast notifications

### Network Requirements

The extension requires the following network conditions:
- Harmony Hub and computer must be on the same local network
- UDP port 5222 must be accessible for hub discovery
- TCP port 8088 must be accessible for hub communication
- No firewall rules blocking Harmony Hub communication

## Troubleshooting Guide

### Hub Discovery Issues

#### Hub Not Found
1. Verify the Harmony Hub is powered on and connected to your network
2. Check that your computer and hub are on the same network
3. Ensure required ports (5222, 8088) are not blocked by firewall
4. Try increasing the `discoveryTimeout` preference
5. Restart the Harmony Hub

#### Multiple Hubs Not Detected
1. Increase the `discoveryCompleteDelay` preference
2. Ensure all hubs are powered on and connected
3. Try discovering hubs one at a time
4. Clear the hub cache and retry discovery

### Command Execution Issues

#### Commands Not Recognized
1. Increase the `commandHoldTime` preference
2. Verify the device is powered on and in range
3. Check if the command works using the Harmony app
4. Try clearing the command cache
5. Re-run hub discovery to refresh device data

#### Delayed Command Response
1. Check network latency to your hub
2. Ensure no other apps are controlling the hub
3. Verify hub firmware is up to date
4. Try reducing the `commandHoldTime` preference

### Activity Issues

#### Activities Won't Start
1. Verify all required devices are powered on
2. Check if activity works in Harmony app
3. Clear hub cache and retry
4. Check for device conflicts
5. Restart the hub if issues persist

#### Activity Status Not Updating
1. Check network connectivity to hub
2. Clear the hub cache
3. Re-run hub discovery
4. Verify hub firmware is up to date

### Connection Issues

#### Hub Disconnects Frequently
1. Check network stability
2. Verify hub power supply
3. Update hub firmware
4. Clear hub cache and rediscover
5. Try moving hub closer to router

#### Cannot Connect to Hub
1. Verify hub IP address is correct
2. Check network firewall settings
3. Ensure hub is not in use by another app
4. Try restarting the hub
5. Clear all caches and rediscover

### Cache Issues

#### Incorrect Device Data
1. Clear the hub cache
2. Re-run hub discovery
3. Verify device configuration in Harmony app
4. Check hub firmware version
5. Reduce `cacheTTL` if issues persist

#### Performance Issues
1. Check `maxCacheEntries` setting
2. Clear old log entries
3. Verify available system memory
4. Reduce logging level if needed

### Error Recovery Steps

For any error, the extension will provide:
1. Error category and description
2. Recommended recovery actions
3. Detailed error message in logs
4. Option to retry the operation
5. Option to clear cache if relevant

If issues persist:
1. Set `minLogLevel` to "DEBUG"
2. Reproduce the issue
3. Check logs for detailed error information
4. Try suggested recovery actions
5. If unresolved, report the issue with logs

## Development

```bash
# Clone the repository
git clone https://github.com/yourusername/harmony-raycast-extension.git

# Install dependencies
npm install

# Run in development mode
npm run dev
```

## Contributing

Contributions are welcome! Please read our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

<file path="tsconfig.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Node 16",
  "include": ["src/**/*", "raycast-env.d.ts"],
  "compilerOptions": {
    "lib": ["es2021"],
    "module": "commonjs",
    "target": "es2021",
    "strict": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "noEmit": false,
    "outDir": "dist",
    
    // Additional strict checks
    "noImplicitAny": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "strictBindCallApply": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true,
    "useUnknownInCatchVariables": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    "noImplicitOverride": true
  }
}
</file>

</files>
