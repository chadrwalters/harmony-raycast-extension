This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-19T15:45:13.398Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
local-docs/
  harmony-raycast.md
src/
  features/
    control/
      types/
        harmony.ts
  hooks/
    useActivityFiltering.ts
    useCommandExecution.ts
    useDeviceFiltering.ts
    useHarmony.ts
    usePreferences.ts
  services/
    harmony/
      harmonyClient.ts
      harmonyManager.ts
      harmonyState.ts
    errorHandler.ts
    localStorage.ts
    logger.ts
    session-manager.ts
    toast.ts
  stores/
    middleware/
    activityStore.ts
    commandStore.ts
    deviceStore.ts
    harmony.ts
    hubStore.ts
    view.ts
    viewStore.ts
  types/
    core/
      command.ts
      errors.ts
      harmony.ts
      index.ts
      logging.ts
      state-mutable.ts
      state.ts
      validation.ts
      views.ts
      websocket.ts
    components.ts
    logging.ts
    preferences.ts
    websocket.ts
  ui/
    components/
      actions/
        ActivityActionPanel.tsx
        BaseActionPanel.tsx
        DeviceActionPanel.tsx
      views/
        ActivitiesView.tsx
        CommandsView.tsx
        DevicesView.tsx
        HarmonyCommand.tsx
        HubsView.tsx
      FeedbackState.tsx
  utils/
    state.ts
    validation.ts
  control.tsx
.eslintrc.json
.gitignore
.prettierrc
CHANGELOG.md
package.json
Plan.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="local-docs/harmony-raycast.md">
```markdown
# Harmony Control for Raycast

Harmony Control is a Raycast extension that allows you to control your Logitech Harmony Hub devices directly from Raycast. It provides a fast and efficient interface for managing your home entertainment system.

## Quick Start

### Installation

1.  Open Raycast.
2.  Search for "Harmony Control".
3.  Click Install.

### Usage

1.  Launch the extension by typing "Harmony Control" in Raycast.
2.  The extension will automatically discover Harmony Hubs on your local network.
3.  Select your hub from the list.
4.  Browse and control your devices and activities.

## Configuration

You can configure the extension in Raycast's preferences:

*   **Default View:** Choose whether to show "Activities" or "Devices" by default.
*   **Command Hold Time:** Adjust the duration (in milliseconds) to hold a command. Default is 100ms.
*   **Cache Duration:**  Set how long hub data is cached (in seconds). Default is 3600 seconds (1 hour).
*   **Debug Logging:** Enable or disable debug logging. Default is true.
*   **Network Timeout:**  Set the network request timeout (in milliseconds). Default is 5000ms.
* **Auto Retry:** Enable/Disable automatic retries for failed operations. Defaults to true
* **Max Retries**: Maximum number of times to retry. Defaults to 3.

## Features

### Device Control

*   Browse all configured devices.
*   Execute device-specific commands (e.g., power, volume, input).

### Activity Management

*   Start and stop Harmony activities.
*   View the current activity status.

### Hub Discovery
* Automatically detects hubs on the local network

### Other
* Refresh the current connection.
* Clear cache and re-discover hubs.

## Troubleshooting
* Ensure your Hub and Mac are on the same network.
* Make sure the Hub is powered on and connected to your Wi-Fi.
* Check your firewall settings and unblock ports required by Harmony.
* Verify that the hub has a direct line of sight to IR-controlled devices.

## Dependencies

*   `@harmonyhub/client-ws`:  Harmony Hub client library.
*   `@harmonyhub/discover`:  Harmony Hub discovery library.
*   `@raycast/api`: Raycast API library.
*   `@raycast/utils`: Raycast utilities.
*   `ws`: WebSocket library.

## Public Interfaces and Features

The extension's main functionalities are organized around React components, custom hooks, and services. Here's a breakdown:

### `src/control.tsx`

This is the main entry point for the extension. It renders the `HarmonyCommand` component wrapped in a `HarmonyProvider`.

### Components (`src/components/`)

#### `DeviceList.tsx`

Displays a searchable list of Harmony devices and their commands.

*   **Props:**
    *   `deviceType?: string`: (Optional) Filters the list to a specific device type.

*   **Features:**
    *   Lists devices, showing their name, type, and number of commands.
    *   Provides a search bar to filter devices and commands.
    *   Allows execution of commands via an `ActionPanel`.

#### `ErrorBoundary.tsx`

A standard React error boundary component that catches and displays errors.

*   **Props:**
    *   `children: React.ReactNode`: The child components to wrap.

*   **Features:**
    *   Catches errors in its child component tree.
    *   Displays a generic error message.
    *   Logs errors for debugging.

#### `FeedbackState.tsx`

Displays loading, error, and empty states.

*   **Props:**
    *   `title: string`: The title to display.
    *   `description?: string`: Optional description.
    *   `icon?: Icon | { source: string }`: The icon.
    *   `color?: Color`: Icon color.
    *   `actions?: React.ReactNode`: Optional actions.
    *   `error?: HarmonyError`: Optional error object.
    *   `onRetry?: () => void`: Optional retry callback.
    * `onReconnect?: () => void`: Optional reconnect callback.
    * `onClearCache?: () => void`: Optional clear-cache callback.
    * `onResetConfig?: () => void`: Optional config-reset callback.
*   **Features:**
    *   Provides consistent UI for different states.
    *   Supports displaying error details and recovery actions.

#### `HarmonyCommand.tsx`

Provides a unified interface to control devices and activities.

*   **Features:**
    *   Displays a list of hubs, activities, or devices based on the selected view.
    *   Supports searching and filtering.
    *   Allows execution of commands and starting/stopping activities.
    *   Handles hub selection and connection.
    * Handles switching view between hubs, activities, devices, and individual commands.

### Hooks (`src/hooks/`)

#### `useHarmony.ts`

The main hook for managing Harmony Hub state and operations. Provides a context that is used by other components.

*   **Returned Values:**
    *   `hubs: HarmonyHub[]`: List of discovered hubs.
    *   `selectedHub: HarmonyHub | null`: The currently selected hub.
    *   `devices: HarmonyDevice[]`: List of devices for the selected hub.
    *   `activities: HarmonyActivity[]`: List of activities for the selected hub.
    *   `currentActivity: HarmonyActivity | null`: The currently active activity.
    *   `error: HarmonyError | null`: Any current error.
    *   `loadingState: LoadingState`: The current loading state.
    *   `connect: (hub: HarmonyHub) => Promise<void>`: Connects to the specified hub.
    *   `disconnect: () => Promise<void>`: Disconnects from the current hub.
    *   `refresh: () => Promise<void>`: Refreshes the hub state.
    *   `executeCommand: (command: HarmonyCommand) => Promise<void>`: Executes a command.
    *   `clearCache: () => Promise<void>`: Clears the cache and rediscovers hubs.
    *   `startActivity: (activityId: string) => Promise<void>`: Starts an activity.
    *   `stopActivity: () => Promise<void>`: Stops the current activity.

### Services (`src/services/`)
#### `harmony/harmonyClient.ts`

Handles communication with a specific Harmony Hub.

*   **`HarmonyClient` Class:**
    *   `constructor(hub: HarmonyHub)`: Initializes a new client for the given hub.
    *   `connect(): Promise<void>`: Connects to the hub.
    *   `getDevices(): Promise<HarmonyDevice[]>`: Retrieves the list of devices.
    *   `getActivities(): Promise<HarmonyActivity[]>`: Retrieves the list of activities.
    *   `getCurrentActivity(): Promise<HarmonyActivity | null>`: Gets the current activity.
    *   `startActivity(activityId: string): Promise<void>`: Starts an activity.
    *   `stopActivity(): Promise<void>`: Stops the current activity.
    *   `executeCommand(command: HarmonyCommand): Promise<void>`: Executes a command.
    *   `disconnect(): Promise<void>`: Disconnects from the hub.

#### `harmony/harmonyManager.ts`

Manages discovery of Harmony Hubs.

* **`HarmonyManager` Class:**
  * `startDiscovery(onProgress?: (progress: number, message: string) => void): Promise<HarmonyHub[]>`: Starts the hub discovery process, with an optional progress callback.
  * `cleanup(): Promise<void>`: Cleans up discovery.
  *  `clearCache(): Promise<void>`: Clears the hub cache.

#### `harmony/commandQueue.ts`

Manages a queue of commands to be executed.

*   **`CommandQueue` Class:**
    *   `constructor(commandSender: CommandSender, config?: Partial<CommandQueueConfig>)`: Creates a new command queue. `CommandSender` is a function that takes a `HarmonyCommand` and sends it.
    *   `enqueue(request: CommandRequest): Promise<CommandResult>`: Adds a command to the queue.
    *  `cancelAll(): void`: Cancels all pending commands
    *  `clearCompleted(): void`: Clears completed commands.

#### `errorHandler.ts`

Provides consistent error handling.

*   **`ErrorHandler` Class:**
    *   `static handle(error: Error | unknown, context?: string): void`: Handles an error by logging and showing a toast.
    *   `static handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T>`: Handles errors in an async operation.

#### `localStorage.ts`

Provides a wrapper around Raycast's `LocalStorage` with error logging.

*   **`LocalStorage` Class:**
    *   `static getItem(key: string): Promise<string | null>`: Retrieves an item.
    *   `static setItem(key: string, value: string): Promise<void>`: Stores an item.
    *   `static removeItem(key: string): Promise<void>`: Removes an item.
    *   `static clear(): Promise<void>`: Clears all items.

#### `logger.ts`

Provides a logging mechanism.

*   **`Logger` Class:**
    *   `static debug(message: string, data?: unknown): void`: Logs a debug message.
    *   `static info(message: string, data?: unknown): void`: Logs an info message.
    *   `static warn(message: string, data?: unknown): void`: Logs a warning message.
    *   `static error(message: string, data?: unknown): void`: Logs an error message.
    *   `static logError(error: Error, context?: string): void`: Logs a full error with stack trace.

#### `secure-storage.ts`
Provides secure storage using encryption. (Currently not in use.)
#### `session-manager.ts`
Manages sessions. (Currently not in use.)

#### `ui/toast-manager.ts`

Helper class to wrap and simplify Raycast `showToast` calls.

*   **`ToastManager` Class:**
    *  `static success(title: string, message?: string): void`: Shows a success toast.
    *  `static error(title: string, message?: string): void`: Shows an error toast.
    *  `static loading(title: string, message?: string): void` Shows a loading toast.

#### `utils/validation.ts`

Provides validation functions.
*   `isNonEmptyString(value: unknown): value is string`: Check if a value is not an empty string.
*  `isPositiveNumber(value: unknown): value is number`: Checks if a value is a number > 0.
*   `isValidIpAddress(value: unknown): value is string`: Checks if a value is a valid IPv4 address.
*  `validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub`: Validates Hub configurations.
*  `validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice`: Validates Device information.
* `validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity`: Validates Activity information.
* `validateCommandRequest(request: Partial<CommandRequest>): asserts request is CommandRequest`: Validates requests.

### Types (`src/types/`)

This directory contains TypeScript type definitions for the project.  Key types include:

*   `harmony.ts`:  Defines core types like `HarmonyHub`, `HarmonyDevice`, `HarmonyActivity`, `HarmonyCommand`, and `LoadingState`.
*   `errors.ts`:  Defines `HarmonyError`, `ErrorCategory`, `ErrorSeverity`, and related error handling types.
*  `preferences.ts`: Defines the `Preferences` interface.
*   `logging.ts`: Defines types related to logging (`LogLevel`, `LogEntry`, etc.).
```
</file>

<file path="src/features/control/types/harmony.ts">
export interface HarmonyHub {
  id: string;
  ip: string;
  name: string;
  remoteId: string;
  hubId: string;
  version: string;
  port?: string;
}
export interface HarmonyDevice {
  id: string;
  label: string;
  type: string;
  commands: HarmonyCommand[];
}
export interface HarmonyCommand {
  id: string;
  name: string;
  label: string;
  deviceId: string;
}
export interface ControlGroup {
  name: string;
  function: {
    name: string;
    action: string;
  }[];
}
export interface FixItItem {
  id: string;
  description: string;
  solution: string;
  urls?: string[];
}
export interface ActivityRule {
  type: string;
  condition: string;
  action: string;
}
export interface ActivitySequence {
  id: string;
  name: string;
  steps: {
    action: string;
    delay: number;
  }[];
}
export interface HarmonyActivity {
  id: string;
  label: string;
  isAVActivity: boolean;
  activityTypeDisplayName: string;
  controlGroup: ControlGroup[];
  fixit: FixItItem[];
  rules: ActivityRule[];
  sequences: ActivitySequence[];
  suggestedDisplay: string;
  type: string;
  status: string;
}
</file>

<file path="src/hooks/useActivityFiltering.ts">
/**
 * Hook for filtering activities with memoization.
 * Provides filtered activities, grouping, and search functionality.
 * @module
 */
import { useMemo } from "react";
import { useViewStore } from "../stores/view";
import { HarmonyActivity } from "../types/core/harmony";
import { useHarmony } from "./useHarmony";
/**
 * Result interface for activity filtering operations.
 * Contains filtered activities and related metadata.
 * @interface ActivityFilteringResult
 */
interface ActivityFilteringResult {
  /** List of activities after applying filters */
  filteredActivities: HarmonyActivity[];
  /** List of unique activity types */
  activityTypes: string[];
  /** Map of activities grouped by type */
  activitiesByType: Map<string, HarmonyActivity[]>;
  /** Map of activity status (running/stopped) */
  activityStatus: Map<string, boolean>;
  /** Total number of activities before filtering */
  totalActivities: number;
  /** Number of activities after filtering */
  filteredCount: number;
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
}
/**
 * Hook for filtering and searching activities.
 * Provides memoized filtering, grouping, and status tracking.
 * Integrates with view store for search and filter state.
 * @returns ActivityFilteringResult containing filtered activities and metadata
 */
export function useActivityFiltering(): ActivityFilteringResult {
  const { activities, currentActivity } = useHarmony();
  const searchQuery = useViewStore((state) => state.searchQuery);
  const filters = useViewStore((state) => state.filters);
  // Memoize filtered activities
  const filteredActivities = useMemo(() => {
    let result = [...activities];
    // Apply activity type filter
    if (filters.activityType) {
      result = result.filter((activity) => activity.type === filters.activityType);
    }
    // Apply search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (activity) => activity.name.toLowerCase().includes(query) || activity.type.toLowerCase().includes(query),
      );
    }
    return result;
  }, [activities, searchQuery, filters.activityType]);
  // Memoize activity types
  const activityTypes = useMemo(() => {
    const types = new Set(activities.map((activity) => activity.type));
    return Array.from(types).sort();
  }, [activities]);
  // Memoize activities by type
  const activitiesByType = useMemo(() => {
    const byType = new Map<string, HarmonyActivity[]>();
    filteredActivities.forEach((activity) => {
      const activities = byType.get(activity.type) || [];
      activities.push(activity);
      byType.set(activity.type, activities);
    });
    // Sort activities within each type
    byType.forEach((activities) => {
      activities.sort((a, b) => {
        // Put current activity first
        if (a.id === currentActivity?.id) return -1;
        if (b.id === currentActivity?.id) return 1;
        // Then sort by name
        return a.name.localeCompare(b.name);
      });
    });
    return byType;
  }, [filteredActivities, currentActivity]);
  // Memoize activity status
  const activityStatus = useMemo(() => {
    const status = new Map<string, boolean>();
    activities.forEach((activity) => {
      status.set(activity.id, activity.isCurrent);
    });
    return status;
  }, [activities]);
  return {
    filteredActivities,
    activityTypes,
    activitiesByType,
    activityStatus,
    totalActivities: activities.length,
    filteredCount: filteredActivities.length,
    currentActivity,
  };
}
</file>

<file path="src/hooks/useCommandExecution.ts">
/**
 * Hook for executing Harmony commands with memoization.
 * Provides command execution with retry logic and error handling.
 * @module
 */
import { getPreferenceValues } from "@raycast/api";
import { useCallback, useState } from "react";
import { ToastManager } from "../services/toast";
import { HarmonyError, ErrorCategory } from "../types/core/errors";
import { HarmonyCommand } from "../types/core/harmony";
import { Preferences } from "../types/preferences";
import { useHarmony } from "./useHarmony";
/**
 * State interface for command execution.
 * Tracks execution state and statistics.
 * @interface CommandExecutionState
 */
interface CommandExecutionState {
  /** Whether a command is currently executing */
  isExecuting: boolean;
  /** Last executed command */
  lastCommand: HarmonyCommand | null;
  /** Last execution error */
  error: HarmonyError | null;
}
/**
 * Result interface for command execution hook.
 * Contains execution functions and state.
 * @interface CommandExecutionResult
 */
interface CommandExecutionResult {
  /** Execute a command with retry logic
   * @param command - Command to execute
   */
  execute: (command: HarmonyCommand) => Promise<void>;
  /** Retry the last failed command */
  retry: () => Promise<void>;
  /** Whether a command is currently executing */
  isExecuting: boolean;
  /** Last executed command */
  lastCommand: HarmonyCommand | null;
  /** Last execution error */
  error: HarmonyError | null;
}
/**
 * Hook for executing commands with retry and error handling.
 * Provides automatic retry based on preferences.
 * Shows toast notifications for execution status.
 * @returns CommandExecutionResult containing execution functions and state
 */
export function useCommandExecution(): CommandExecutionResult {
  const { executeCommand } = useHarmony();
  const [state, setState] = useState<CommandExecutionState>({
    isExecuting: false,
    lastCommand: null,
    error: null,
  });
  const preferences = getPreferenceValues<Preferences>();
  const holdTime = parseInt(preferences.commandHoldTime, 10);
  const autoRetry = preferences.autoRetry;
  const maxRetries = parseInt(preferences.maxRetries, 10);
  /**
   * Execute a command with retry logic.
   * Retries failed commands based on preferences.
   * Shows toast notifications for status.
   * @param command - Command to execute
   */
  const execute = useCallback(
    async (command: HarmonyCommand) => {
      setState((prev) => ({
        ...prev,
        isExecuting: true,
        lastCommand: command,
        error: null,
      }));
      try {
        let retries = 0;
        let success = false;
        while (!success && retries <= maxRetries) {
          try {
            await executeCommand(command);
            success = true;
          } catch (error) {
            retries++;
            if (!autoRetry || retries > maxRetries) {
              throw error;
            }
            // Wait before retrying
            await new Promise((resolve) => setTimeout(resolve, holdTime));
          }
        }
        setState((prev) => ({
          ...prev,
          isExecuting: false,
        }));
        ToastManager.success(`Executed ${command.label}`);
      } catch (error) {
        const harmonyError = new HarmonyError(
          `Failed to execute ${command.label}`,
          ErrorCategory.COMMAND_EXECUTION,
          error instanceof Error ? error : undefined,
        );
        setState((prev) => ({
          ...prev,
          isExecuting: false,
          error: harmonyError,
        }));
        ToastManager.error(`Failed to execute ${command.label}`, harmonyError.message);
      }
    },
    [executeCommand, holdTime, autoRetry, maxRetries],
  );
  /**
   * Retry the last failed command.
   * Only works if there is a last command.
   */
  const retry = useCallback(async () => {
    if (state.lastCommand) {
      await execute(state.lastCommand);
    }
  }, [execute, state.lastCommand]);
  return {
    execute,
    retry,
    isExecuting: state.isExecuting,
    lastCommand: state.lastCommand,
    error: state.error,
  };
}
</file>

<file path="src/hooks/useDeviceFiltering.ts">
/**
 * Hook for filtering devices with memoization.
 * Provides filtered devices, grouping, and search functionality.
 * @module
 */
import { useMemo } from "react";
import { useViewStore } from "../stores/view";
import { HarmonyDevice } from "../types/core/harmony";
import { useHarmony } from "./useHarmony";
/**
 * Result interface for device filtering operations.
 * Contains filtered devices and related metadata.
 * @interface DeviceFilteringResult
 */
interface DeviceFilteringResult {
  /** List of devices after applying filters */
  filteredDevices: HarmonyDevice[];
  /** List of unique device types */
  deviceTypes: string[];
  /** Map of devices grouped by type */
  devicesByType: Map<string, HarmonyDevice[]>;
  /** Total number of devices before filtering */
  totalDevices: number;
  /** Number of devices after filtering */
  filteredCount: number;
}
/**
 * Hook for filtering and searching devices.
 * Provides memoized filtering, grouping, and command search.
 * Integrates with view store for search and filter state.
 * @returns DeviceFilteringResult containing filtered devices and metadata
 */
export function useDeviceFiltering(): DeviceFilteringResult {
  const { devices } = useHarmony();
  const searchQuery = useViewStore((state) => state.searchQuery);
  const filters = useViewStore((state) => state.filters);
  // Memoize filtered devices
  const filteredDevices = useMemo(() => {
    let result = [...devices];
    // Apply device type filter
    if (filters.deviceType) {
      result = result.filter((device) => device.type === filters.deviceType);
    }
    // Apply search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (device) =>
          device.name.toLowerCase().includes(query) ||
          device.type.toLowerCase().includes(query) ||
          device.commands.some((cmd) => cmd.label.toLowerCase().includes(query)),
      );
    }
    return result;
  }, [devices, searchQuery, filters.deviceType]);
  // Memoize device types
  const deviceTypes = useMemo(() => {
    const types = new Set(devices.map((device) => device.type));
    return Array.from(types).sort();
  }, [devices]);
  // Memoize devices by type
  const devicesByType = useMemo(() => {
    const byType = new Map<string, HarmonyDevice[]>();
    filteredDevices.forEach((device) => {
      const devices = byType.get(device.type) || [];
      devices.push(device);
      byType.set(device.type, devices);
    });
    // Sort devices within each type
    byType.forEach((devices) => {
      devices.sort((a, b) => a.name.localeCompare(b.name));
    });
    return byType;
  }, [filteredDevices]);
  return {
    filteredDevices,
    deviceTypes,
    devicesByType,
    totalDevices: devices.length,
    filteredCount: filteredDevices.length,
  };
}
</file>

<file path="src/hooks/useHarmony.ts">
/**
 * Core hook for managing Harmony Hub state and operations.
 * Provides centralized access to hub, device, and activity management.
 * @module
 */
import React, { useCallback, useState, createContext, useContext, useRef } from "react";
import { HarmonyClient } from "../services/harmony/harmonyClient";
import { HarmonyManager } from "../services/harmony/harmonyManager";
import { Logger } from "../services/logger";
import { HarmonyError, ErrorCategory } from "../types/core/errors";
import {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  LoadingState,
  HarmonyStage,
} from "../types/core/harmony";
// Create a single manager instance
const manager = new HarmonyManager();
/**
 * Core state and operations for Harmony Hub integration.
 * Provides access to hub state, devices, activities, and operations.
 * @interface HarmonyContextState
 */
interface HarmonyContextState {
  /** List of discovered Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected Harmony Hub */
  selectedHub: HarmonyHub | null;
  /** List of devices available on the selected hub */
  devices: HarmonyDevice[];
  /** List of activities available on the selected hub */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Current error state */
  error: HarmonyError | null;
  /** Current loading state */
  loadingState: LoadingState;
  /** Connect to a specific Harmony Hub */
  connect: (hub: HarmonyHub) => Promise<void>;
  /** Disconnect from the current hub */
  disconnect: () => Promise<void>;
  /** Refresh hub discovery and state */
  refresh: () => Promise<void>;
  /** Execute a command on a device */
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  /** Clear cached hub data */
  clearCache: () => Promise<void>;
  /** Start an activity by ID */
  startActivity: (activityId: string) => Promise<void>;
  /** Stop the current activity */
  stopActivity: () => Promise<void>;
}
/** Context for sharing Harmony state across components */
const HarmonyContext = createContext<HarmonyContextState | null>(null);
/**
 * Props for the HarmonyProvider component
 * @interface HarmonyProviderProps
 */
interface HarmonyProviderProps {
  /** Child components that will have access to Harmony state */
  children: React.ReactNode;
}
/**
 * Provider component for Harmony Hub functionality.
 * Wraps child components with access to Harmony state and operations.
 * @param props - The provider props
 * @returns A provider component
 */
export const HarmonyProvider: React.FC<HarmonyProviderProps> = ({ children }) => {
  const harmony = useHarmonyState();
  return React.createElement(HarmonyContext.Provider, { value: harmony }, children);
};
/**
 * Internal state interface for the Harmony hook.
 * Contains complete state for hub management.
 * @interface HarmonyInternalState
 */
interface HarmonyInternalState {
  /** List of discovered Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected Harmony Hub */
  selectedHub: HarmonyHub | null;
  /** Active client for hub communication */
  client: HarmonyClient | null;
  /** List of devices available on the selected hub */
  devices: HarmonyDevice[];
  /** List of activities available on the selected hub */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Current error state */
  error: HarmonyError | null;
  /** Current loading state */
  loadingState: LoadingState;
}
/**
 * Hook for managing Harmony Hub state and operations.
 * This is the internal implementation used by the provider.
 * Handles hub discovery, connection, device and activity management.
 * @returns The Harmony context state
 */
function useHarmonyState(): HarmonyContextState {
  const [state, setState] = useState<HarmonyInternalState>({
    hubs: [],
    selectedHub: null,
    client: null,
    devices: [],
    activities: [],
    currentActivity: null,
    error: null,
    loadingState: {
      stage: HarmonyStage.INITIAL,
      message: "Starting hub discovery",
      progress: 0,
    },
  });
  // Use ref to track if discovery is in progress
  const isDiscovering = useRef(false);
  /**
   * Update the current loading state
   * @param stage - The current stage of operation
   * @param message - User-friendly message about the current state
   * @param progress - Progress value between 0 and 1
   */
  const setLoadingState = useCallback((stage: HarmonyStage, message: string, progress: number) => {
    setState((prev) => ({
      ...prev,
      loadingState: { stage, message, progress },
    }));
  }, []);
  /**
   * Update the current error state
   * @param error - The current error or null if cleared
   */
  const setError = useCallback((error: HarmonyError | null) => {
    setState((prev) => ({ ...prev, error }));
  }, []);
  // Connect to a hub
  const connect = useCallback(
    async (hub: HarmonyHub) => {
      try {
        Logger.info(`Connecting to hub ${hub.name}`);
        setError(null);
        setLoadingState(HarmonyStage.CONNECTING, `Connecting to ${hub.name}...`, 0);
        // Create and connect to the client
        const newClient = new HarmonyClient(hub);
        await newClient.connect();
        Logger.info("Connected to hub, setting up state");
        setState((prev) => ({
          ...prev,
          client: newClient,
          selectedHub: hub,
        }));
        // Load devices
        setLoadingState(HarmonyStage.LOADING_DEVICES, "Loading devices...", 0.3);
        Logger.info("Loading devices");
        const hubDevices = await newClient.getDevices();
        Logger.info(`Loaded ${hubDevices.length} devices`);
        setState((prev) => ({ ...prev, devices: hubDevices }));
        // Load activities
        setLoadingState(HarmonyStage.LOADING_ACTIVITIES, "Loading activities...", 0.6);
        Logger.info("Loading activities");
        const hubActivities = await newClient.getActivities();
        Logger.info(`Loaded ${hubActivities.length} activities`);
        setState((prev) => ({ ...prev, activities: hubActivities }));
        // Get current activity
        Logger.info("Getting current activity");
        const current = await newClient.getCurrentActivity();
        setState((prev) => ({ ...prev, currentActivity: current }));
        setLoadingState(HarmonyStage.CONNECTED, "Connected successfully", 1);
        Logger.info("Hub setup completed successfully");
      } catch (err) {
        const error = new HarmonyError(
          "Failed to connect to hub",
          ErrorCategory.HUB_COMMUNICATION,
          err instanceof Error ? err : undefined,
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        Logger.error("Hub connection failed", { error: error.getDetailedMessage() });
      }
    },
    [setLoadingState, setError],
  );
  // Discover hubs
  const discover = useCallback(async () => {
    if (isDiscovering.current) {
      Logger.info("Discovery already in progress, skipping");
      return;
    }
    try {
      isDiscovering.current = true;
      setError(null);
      setLoadingState(HarmonyStage.DISCOVERING, "Searching for Harmony Hubs...", 0.1);
      Logger.info("Starting hub discovery");
      const discoveredHubs = await manager.startDiscovery((progress, message) => {
        setLoadingState(HarmonyStage.DISCOVERING, message, Math.max(0.1, progress));
      });
      if (!isDiscovering.current) {
        Logger.info("Discovery was cancelled");
        return;
      }
      Logger.info(`Discovery completed, found ${discoveredHubs.length} hubs`);
      setState((prev) => ({ ...prev, hubs: discoveredHubs }));
      if (discoveredHubs.length === 0) {
        const error = new HarmonyError("No Harmony Hubs found", ErrorCategory.HUB_COMMUNICATION);
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
      setLoadingState(HarmonyStage.CONNECTED, "Hubs discovered successfully", 1);
      // If there's only one hub, automatically select it
      if (discoveredHubs.length === 1) {
        const hub = discoveredHubs[0];
        if (hub) {
          Logger.info("Single hub found, auto-selecting");
          await connect(hub);
        }
      }
    } catch (err) {
      const error = new HarmonyError(
        "Failed to discover hubs",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined,
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      Logger.error("Hub discovery failed", { error: error.getDetailedMessage() });
    } finally {
      isDiscovering.current = false;
    }
  }, [connect, setLoadingState, setError]);
  // Disconnect from hub
  const disconnect = useCallback(async () => {
    if (state.client) {
      try {
        await state.client.disconnect();
        setLoadingState(HarmonyStage.INITIAL, "Disconnected", 0);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to disconnect",
          ErrorCategory.HUB_COMMUNICATION,
          err instanceof Error ? err : undefined,
        );
        Logger.error("Hub disconnection failed", { error: error.getDetailedMessage() });
      } finally {
        setState((prev) => ({
          ...prev,
          client: null,
          selectedHub: null,
          devices: [],
          activities: [],
          currentActivity: null,
          error: null,
        }));
      }
    }
  }, [state.client, setLoadingState]);
  // Execute a command
  const executeCommand = useCallback(
    async (command: HarmonyCommand) => {
      if (!state.client) {
        throw new HarmonyError("No hub selected", ErrorCategory.STATE);
      }
      try {
        Logger.debug("Sending command to hub", { command });
        setLoadingState(HarmonyStage.EXECUTING_COMMAND, `Sending ${command.name}...`, 0.5);
        await state.client.executeCommand(command);
        setLoadingState(HarmonyStage.CONNECTED, "Command sent successfully", 1);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to execute command",
          ErrorCategory.COMMAND_EXECUTION,
          err instanceof Error ? err : undefined,
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
    },
    [state.client, setLoadingState, setError],
  );
  // Start activity
  const startActivity = useCallback(
    async (activityId: string) => {
      if (!state.client) {
        throw new HarmonyError("No hub selected", ErrorCategory.STATE);
      }
      try {
        setLoadingState(HarmonyStage.STARTING_ACTIVITY, `Starting activity ${activityId}...`, 0.5);
        await state.client.startActivity(activityId);
        setLoadingState(HarmonyStage.CONNECTED, "Activity started successfully", 1);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to start activity",
          ErrorCategory.ACTIVITY_START,
          err instanceof Error ? err : undefined,
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
    },
    [state.client, setLoadingState, setError],
  );
  // Stop activity
  const stopActivity = useCallback(async () => {
    if (!state.client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      setLoadingState(HarmonyStage.STOPPING_ACTIVITY, "Stopping activity...", 0.5);
      await state.client.stopActivity();
      setLoadingState(HarmonyStage.CONNECTED, "Activity stopped successfully", 1);
    } catch (err) {
      const error = new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.ACTIVITY_STOP,
        err instanceof Error ? err : undefined,
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      throw error;
    }
  }, [state.client, setLoadingState, setError]);
  // Clear cache and rediscover
  const clearCache = useCallback(async () => {
    await disconnect();
    await manager.clearCache();
    await discover();
  }, [disconnect, discover]);
  // Refresh state
  const refresh = useCallback(async () => {
    await discover();
  }, [discover]);
  return {
    ...state,
    connect,
    disconnect,
    refresh,
    executeCommand,
    clearCache,
    startActivity,
    stopActivity,
  };
}
/**
 * Hook for accessing Harmony Hub functionality.
 * Must be used within a HarmonyProvider component.
 * Provides access to hub state, devices, activities, and operations.
 * @throws {Error} If used outside of a HarmonyProvider
 * @returns The Harmony context state
 */
export function useHarmony(): HarmonyContextState {
  const context = useContext(HarmonyContext);
  if (!context) {
    throw new Error("useHarmony must be used within a HarmonyProvider");
  }
  return context;
}
</file>

<file path="src/hooks/usePreferences.ts">
/**
 * Hook for managing user preferences.
 * Handles loading, saving, validating, and resetting preferences.
 * @module
 */
import { useCallback, useEffect, useState } from "react";
import { LocalStorage } from "@raycast/api";
import { Logger } from "../services/logger";
import { HarmonyError } from "../types/core/errors";
import { ErrorCategory } from "../types/core/harmony";
import {
  validateDefaultView,
  validateCommandDisplayMode,
  validateCommandGridColumns,
  validateAutoConnect,
  validateShowToasts,
  validateDiscoveryTimeout,
  validateCommandTimeout,
  validateActivityTimeout,
} from "../utils/validation";
/**
 * Default values for preferences.
 * Used when no stored preferences exist.
 * @const
 */
const DEFAULT_PREFERENCES = {
  /** Default view to show when opening the extension */
  defaultView: "devices",
  /** How to display command buttons */
  commandDisplayMode: "list",
  /** Number of columns in grid mode */
  commandGridColumns: 3,
  /** Whether to auto-connect to a single hub */
  autoConnect: true,
  /** Whether to show toast notifications */
  showToasts: true,
  /** Timeout for hub discovery in milliseconds */
  discoveryTimeout: 5000,
  /** Timeout for command execution in milliseconds */
  commandTimeout: 1000,
  /** Timeout for activity changes in milliseconds */
  activityTimeout: 5000,
} as const;
/**
 * Type for user preferences.
 * Based on the default preferences structure.
 */
export type Preferences = typeof DEFAULT_PREFERENCES;
/** Key for storing preferences in local storage */
const PREFERENCES_KEY = "preferences";
/**
 * Hook for managing user preferences.
 * Handles loading, saving, and validating preferences.
 * Provides functions to update and reset preferences.
 * @returns Object containing preferences and functions to update them
 */
export function usePreferences() {
  const [preferences, setPreferences] = useState<Preferences>(DEFAULT_PREFERENCES);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<HarmonyError | null>(null);
  /**
   * Loads preferences from local storage.
   * Validates and merges with defaults.
   */
  const loadPreferences = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const stored = await LocalStorage.getItem<string>(PREFERENCES_KEY);
      if (!stored) {
        Logger.info("No stored preferences found, using defaults");
        return;
      }
      const parsed = JSON.parse(stored) as Partial<Preferences>;
      Logger.debug("Loaded stored preferences", parsed);
      // Validate each preference
      if (parsed.defaultView !== undefined) {
        validateDefaultView(parsed.defaultView);
      }
      if (parsed.commandDisplayMode !== undefined) {
        validateCommandDisplayMode(parsed.commandDisplayMode);
      }
      if (parsed.commandGridColumns !== undefined) {
        validateCommandGridColumns(parsed.commandGridColumns);
      }
      if (parsed.autoConnect !== undefined) {
        validateAutoConnect(parsed.autoConnect);
      }
      if (parsed.showToasts !== undefined) {
        validateShowToasts(parsed.showToasts);
      }
      if (parsed.discoveryTimeout !== undefined) {
        validateDiscoveryTimeout(parsed.discoveryTimeout);
      }
      if (parsed.commandTimeout !== undefined) {
        validateCommandTimeout(parsed.commandTimeout);
      }
      if (parsed.activityTimeout !== undefined) {
        validateActivityTimeout(parsed.activityTimeout);
      }
      // Merge with defaults
      setPreferences((prev) => ({ ...prev, ...parsed }));
    } catch (err) {
      const error = new HarmonyError(
        "Failed to load preferences",
        ErrorCategory.STORAGE,
        err instanceof Error ? err : undefined,
      );
      Logger.error("Failed to load preferences", error);
      setError(error);
    } finally {
      setIsLoading(false);
    }
  }, []);
  /**
   * Saves preferences to local storage.
   * Validates new preferences before saving.
   * @param newPreferences - New preferences to save
   * @throws {HarmonyError} If preferences are invalid or saving fails
   */
  const savePreferences = useCallback(async (newPreferences: Partial<Preferences>) => {
    try {
      setError(null);
      // Validate new preferences
      if (newPreferences.defaultView !== undefined) {
        validateDefaultView(newPreferences.defaultView);
      }
      if (newPreferences.commandDisplayMode !== undefined) {
        validateCommandDisplayMode(newPreferences.commandDisplayMode);
      }
      if (newPreferences.commandGridColumns !== undefined) {
        validateCommandGridColumns(newPreferences.commandGridColumns);
      }
      if (newPreferences.autoConnect !== undefined) {
        validateAutoConnect(newPreferences.autoConnect);
      }
      if (newPreferences.showToasts !== undefined) {
        validateShowToasts(newPreferences.showToasts);
      }
      if (newPreferences.discoveryTimeout !== undefined) {
        validateDiscoveryTimeout(newPreferences.discoveryTimeout);
      }
      if (newPreferences.commandTimeout !== undefined) {
        validateCommandTimeout(newPreferences.commandTimeout);
      }
      if (newPreferences.activityTimeout !== undefined) {
        validateActivityTimeout(newPreferences.activityTimeout);
      }
      // Update state
      const updatedPreferences = { ...preferences, ...newPreferences };
      setPreferences(updatedPreferences);
      // Save to storage
      await LocalStorage.setItem(PREFERENCES_KEY, JSON.stringify(updatedPreferences));
      Logger.debug("Saved preferences", updatedPreferences);
    } catch (err) {
      const error = new HarmonyError(
        "Failed to save preferences",
        ErrorCategory.STORAGE,
        err instanceof Error ? err : undefined,
      );
      Logger.error("Failed to save preferences", error);
      setError(error);
      throw error;
    }
  }, [preferences]);
  /**
   * Resets preferences to defaults.
   * Clears stored preferences and reverts to defaults.
   * @throws {HarmonyError} If resetting preferences fails
   */
  const resetPreferences = useCallback(async () => {
    try {
      setError(null);
      await LocalStorage.removeItem(PREFERENCES_KEY);
      setPreferences(DEFAULT_PREFERENCES);
      Logger.info("Reset preferences to defaults");
    } catch (err) {
      const error = new HarmonyError(
        "Failed to reset preferences",
        ErrorCategory.STORAGE,
        err instanceof Error ? err : undefined,
      );
      Logger.error("Failed to reset preferences", error);
      setError(error);
      throw error;
    }
  }, []);
  // Load preferences on mount
  useEffect(() => {
    void loadPreferences();
  }, [loadPreferences]);
  return {
    preferences,
    isLoading,
    error,
    savePreferences,
    resetPreferences,
  };
}
</file>

<file path="src/services/harmony/harmonyClient.ts">
/**
 * Client for communicating with a Harmony Hub.
 * Handles connection, command execution, activity management, and state caching.
 * @module
 */
import getHarmonyClient from "@harmonyhub/client-ws";
import { getPreferenceValues, LocalStorage } from "@raycast/api";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import { 
  HarmonyHub, 
  HarmonyDevice, 
  HarmonyActivity, 
  HarmonyCommand,
  isHarmonyDevice,
  isHarmonyActivity 
} from "../../types/core/harmony";
import { Logger } from "../logger";
/** Cache expiration time in milliseconds (24 hours) */
const CACHE_EXPIRY = 24 * 60 * 60 * 1000;
/**
 * Interface for cached hub configuration
 * @interface CachedConfig
 */
interface CachedConfig {
  /** List of devices associated with the hub */
  devices: HarmonyDevice[];
  /** List of activities configured on the hub */
  activities: HarmonyActivity[];
  /** Timestamp when the cache was created */
  timestamp: number;
}
/**
 * Interface for command execution body
 * @interface HarmonyCommandBody
 */
interface HarmonyCommandBody {
  /** Command identifier */
  command: string;
  /** Target device identifier */
  deviceId: string;
  /** Command type (e.g., "IRCommand") */
  type: string;
}
/**
 * Interface for command function configuration
 * @interface CommandFunction
 */
interface CommandFunction {
  /** Function name */
  name: string;
  /** Display label */
  label?: string;
  /** Command action configuration */
  action?: {
    /** Command identifier */
    command?: string;
  };
}
/**
 * Interface for device control group
 * @interface ControlGroup
 */
interface ControlGroup {
  /** Group name */
  name: string;
  /** List of functions in this group */
  function: CommandFunction[];
}
/**
 * Interface for raw device data from hub
 * @interface RawDevice
 */
interface RawDevice {
  /** Device identifier */
  id: string;
  /** Display label */
  label?: string;
  /** Device type */
  type?: string;
  /** List of control groups */
  controlGroup: ControlGroup[];
}
/**
 * Interface for raw hub configuration
 * @interface RawConfig
 */
interface RawConfig {
  /** List of devices */
  device: RawDevice[];
}
/**
 * Interface for raw activity data from hub
 * @interface RawActivity
 */
interface RawActivity {
  /** Activity identifier */
  id: string;
  /** Activity display label */
  label: string;
  /** Activity type */
  type: string;
}
/**
 * Client for communicating with a Harmony Hub
 * Handles connection, command execution, and activity management
 */
export class HarmonyClient {
  /** Connected client instance */
  private client: Awaited<ReturnType<typeof getHarmonyClient>> | null = null;
  /** Connection state */
  private isConnected = false;
  /** The hub this client is connected to */
  public readonly hub: HarmonyHub;
  /** Cache key for this hub's configuration */
  private cacheKey: string;
  /**
   * Creates a new HarmonyClient instance
   * @param hub - The Harmony Hub to connect to
   */
  constructor(hub: HarmonyHub) {
    this.hub = hub;
    this.cacheKey = `harmony-config-${hub.hubId}`;
  }
  /**
   * Connects to the Harmony Hub and retrieves its configuration.
   * Establishes WebSocket connection and verifies connectivity by fetching initial config.
   * Sets up disconnect handler and validates connection state.
   * @throws {HarmonyError} If connection fails or initial config cannot be retrieved
   */
  public async connect(): Promise<void> {
    if (this.isConnected) {
      Logger.info(`Already connected to hub ${this.hub.name}`);
      return;
    }
    try {
      Logger.info(`Initiating connection to hub ${this.hub.name} (${this.hub.ip})`);
      // Create client with remoteId if available for faster connection
      Logger.debug("Creating Harmony client", {
        hubInfo: {
          hubIp: this.hub.ip,
          hubId: this.hub.hubId,
          remoteId: this.hub.remoteId,
        },
      });
      this.client = await getHarmonyClient(this.hub.ip);
      this.isConnected = true;
      Logger.info(`Successfully connected to hub ${this.hub.name}`);
      // Setup disconnect handler
      this.client?.on("disconnected", () => {
        Logger.warn(`Disconnected from hub ${this.hub.name}`);
        this.isConnected = false;
      });
      // Verify connection by attempting to get config
      Logger.debug("Verifying connection by fetching initial config");
      await this.getDevicesFromHub();
      Logger.info("Connection verified successfully");
    } catch (err) {
      this.isConnected = false;
      this.client = null;
      const error = new HarmonyError(
        `Failed to connect to hub ${this.hub.name}`,
        ErrorCategory.CONNECTION,
        err instanceof Error ? err : undefined,
      );
      Logger.error("Connection failed", { error: error.getDetailedMessage() });
      throw error;
    }
  }
  /**
   * Retrieves the list of devices from the hub.
   * Attempts to load from cache first, falls back to hub query if cache is invalid.
   * @returns Promise resolving to list of devices
   * @throws {HarmonyError} If retrieving devices fails or hub is not connected
   */
  public async getDevices(): Promise<HarmonyDevice[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.devices) {
        Logger.info("Using cached devices for hub", this.hub.name);
        return cached.devices;
      }
      // Get from hub if not cached
      const rawDevices = await this.getDevicesFromHub();
      Logger.debug("Mapping raw devices to HarmonyDevice", { 
        deviceCount: rawDevices.length,
        firstDevice: rawDevices[0] 
      });
      const mappedDevices = rawDevices.map((device) => {
        const mappedDevice = {
          id: device.id,
          name: device.label || device.id,
          type: device.type || "Unknown",
          commands: device.controlGroup.flatMap((group) =>
            group.function.map((fn) => ({
              id: fn.name,
              name: fn.name,
              label: fn.label || fn.name,
              deviceId: device.id,
              group: fn.action?.command || "IRCommand",
            })),
          ),
        } as HarmonyDevice;
        // Validate mapped device
        if (!isHarmonyDevice(mappedDevice)) {
          Logger.error("Invalid device mapping", { device, mappedDevice });
          throw new HarmonyError(
            `Invalid device mapping for ${device.id}`,
            ErrorCategory.VALIDATION,
          );
        }
        return mappedDevice;
      });
      Logger.debug("Successfully mapped devices", { 
        deviceCount: mappedDevices.length,
        commandCounts: mappedDevices.map(d => ({ 
          deviceId: d.id, 
          commandCount: d.commands.length 
        }))
      });
      // Cache the new devices along with current activities
      await this.updateConfigCache(mappedDevices, await this.getActivitiesFromHub());
      return mappedDevices;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Gets devices directly from the hub via WebSocket.
   * @returns Promise resolving to list of raw device data
   * @throws {HarmonyError} If client not initialized or hub communication fails
   * @private
   */
  private async getDevicesFromHub(): Promise<RawDevice[]> {
    if (!this.client) {
      throw new HarmonyError("Client not initialized", ErrorCategory.CONNECTION);
    }
    try {
      Logger.info("Fetching devices from hub", this.hub.name);
      const rawConfig = (await this.client.getAvailableCommands()) as RawConfig;
      if (!rawConfig.device || rawConfig.device.length === 0) {
        Logger.warn("No devices found in hub config");
        return [];
      }
      Logger.info(`Found ${rawConfig.device.length} devices`);
      // Log raw config structure for first device
      if (rawConfig.device[0]) {
        Logger.info("First device raw config:", JSON.stringify(rawConfig.device[0], null, 2));
      }
      return rawConfig.device;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err)),
      );
    }
  }
  /**
   * Retrieves the list of activities from the hub.
   * Attempts to load from cache first, falls back to hub query if cache is invalid.
   * @returns Promise resolving to list of activities
   * @throws {HarmonyError} If retrieving activities fails or hub is not connected
   */
  public async getActivities(): Promise<HarmonyActivity[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.activities) {
        Logger.info("Using cached activities for hub", this.hub.name);
        return cached.activities;
      }
      // Get from hub if not cached
      const activities = await this.getActivitiesFromHub();
      // Cache the new activities along with current devices
      await this.updateConfigCache(await this.getDevices(), activities);
      return activities;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get activities",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Gets the currently running activity.
   * Queries the hub for current activity and matches it against known activities.
   * @returns Promise resolving to current activity or null if none
   * @throws {HarmonyError} If retrieving current activity fails or hub is not connected
   */
  public async getCurrentActivity(): Promise<HarmonyActivity | null> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const rawActivity = await this.client.getCurrentActivity();
      Logger.debug("Got current activity from hub", { rawActivity });
      if (!rawActivity) {
        return null;
      }
      // Convert raw activity string to proper type
      const currentActivityId = String(rawActivity);
      // Get all activities to find the current one
      const activities = await this.getActivities();
      const activity = activities.find((a) => a.id === currentActivityId);
      if (!activity) {
        Logger.warn("Current activity not found in activity list", { 
          currentActivityId,
          availableActivities: activities.map(a => a.id)
        });
        return null;
      }
      const currentActivity = {
        ...activity,
        isCurrent: true,
      };
      // Validate current activity
      if (!isHarmonyActivity(currentActivity)) {
        Logger.error("Invalid current activity", { currentActivity });
        throw new HarmonyError(
          "Invalid current activity data",
          ErrorCategory.VALIDATION,
        );
      }
      return currentActivity;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get current activity",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err)),
      );
    }
  }
  /**
   * Starts an activity by ID.
   * Initiates the activity and waits for confirmation of successful start.
   * @param activityId - ID of the activity to start
   * @throws {HarmonyError} If starting activity fails or hub is not connected
   */
  public async startActivity(activityId: string): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Starting activity", { activityId });
      await this.client.startActivity(activityId);
      // Wait for activity to start and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const currentActivity = await this.getCurrentActivity();
        if (currentActivity?.id === activityId) {
          Logger.debug("Activity started successfully", { activityId });
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to start");
    } catch (err) {
      throw new HarmonyError(
        `Failed to start activity ${activityId}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Stops the current activity.
   * Sends stop command and waits for confirmation of successful stop.
   * @throws {HarmonyError} If stopping activity fails or hub is not connected
   */
  public async stopActivity(): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Stopping current activity");
      const currentActivity = await this.getCurrentActivity();
      if (!currentActivity) {
        Logger.debug("No activity running");
        return;
      }
      await this.client.turnOff();
      // Wait for activity to stop and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const activity = await this.getCurrentActivity();
        if (!activity) {
          Logger.debug("Activity stopped successfully");
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to stop");
    } catch (err) {
      throw new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Gets cached configuration if available.
   * Checks cache validity and expiration.
   * @returns Promise resolving to cached configuration or null
   * @throws {HarmonyError} If reading cache fails
   * @private
   */
  private async getCachedConfig(): Promise<CachedConfig | null> {
    try {
      const cached = await LocalStorage.getItem<string>(this.cacheKey);
      if (!cached) {
        return null;
      }
      const config = JSON.parse(cached) as CachedConfig;
      // Check if cache is expired
      if (Date.now() - config.timestamp > CACHE_EXPIRY) {
        Logger.info("Config cache expired for hub", this.hub.name);
        await LocalStorage.removeItem(this.cacheKey);
        return null;
      }
      return config;
    } catch (err) {
      Logger.warn("Failed to get cached config:", err);
      return null;
    }
  }
  /**
   * Update the config cache with new devices and activities.
   * @param devices - List of devices to cache
   * @param activities - List of activities to cache
   * @private
   */
  private async updateConfigCache(devices: HarmonyDevice[], activities: HarmonyActivity[]): Promise<void> {
    try {
      const cache: CachedConfig = {
        devices,
        activities,
        timestamp: Date.now(),
      };
      await LocalStorage.setItem(this.cacheKey, JSON.stringify(cache));
      Logger.info("Cached config for hub", this.hub.name);
    } catch (err) {
      Logger.warn("Failed to cache config:", err);
    }
  }
  /**
   * Executes a command on a device.
   * Sends press and release actions with configurable hold time.
   * @param command - The command to execute
   * @throws {HarmonyError} If command execution fails or hub is not connected
   */
  public async executeCommand(command: HarmonyCommand): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const preferences = getPreferenceValues<{ commandHoldTime: string }>();
      const holdTime = parseInt(preferences.commandHoldTime || "100", 10);
      Logger.debug("Sending command to hub", { command });
      const commandBody: HarmonyCommandBody = {
        command: command.id,
        deviceId: command.deviceId,
        type: command.group || "IRCommand",
      };
      Logger.debug("Command body:", commandBody);
      // Send press action
      await this.client.send("holdAction", commandBody);
      // Wait for hold time
      await new Promise((resolve) => setTimeout(resolve, holdTime));
      // Send release action
      await this.client.send("releaseAction", commandBody);
    } catch (err) {
      throw new HarmonyError(
        `Failed to execute command ${command.name}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined,
      );
    }
  }
  /**
   * Disconnects from the Harmony Hub.
   * Cleans up resources and closes the connection.
   * @throws {HarmonyError} If disconnection fails
   */
  public async disconnect(): Promise<void> {
    try {
      if (this.client && this.isConnected) {
        await this.client.end();
        this.isConnected = false;
        this.client = null;
      }
    } catch (err) {
      throw new HarmonyError(
        "Failed to disconnect from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err)),
      );
    }
  }
  /**
   * Type guard for raw activity data from hub
   * @param data - Data to check
   * @returns True if data matches RawActivity structure
   * @private
   */
  private isRawActivity(data: unknown): data is RawActivity {
    return (
      typeof data === 'object' &&
      data !== null &&
      typeof (data as RawActivity).id === 'string' &&
      typeof (data as RawActivity).label === 'string' &&
      typeof (data as RawActivity).type === 'string'
    );
  }
  /**
   * Maps raw activity data to HarmonyActivity format
   * @param raw - Raw activity data from hub
   * @returns Mapped HarmonyActivity
   * @private
   */
  private mapRawActivityToHarmonyActivity = (raw: RawActivity): HarmonyActivity => {
    const mappedActivity: HarmonyActivity = {
      id: String(raw.id),
      name: raw.label,
      type: raw.type,
      isCurrent: false,
    };
    if (!isHarmonyActivity(mappedActivity)) {
      Logger.error("Invalid activity mapping", { raw, mappedActivity });
      throw new HarmonyError(`Invalid activity mapping for ${raw.id}`, ErrorCategory.VALIDATION);
    }
    return mappedActivity;
  };
  private async getActivitiesFromHub(): Promise<HarmonyActivity[]> {
    if (!this.client) {
      throw new HarmonyError("Client not initialized", ErrorCategory.CONNECTION);
    }
    const response = await this.client.getActivities();
    const rawData = Array.isArray(response) ? response : [];
    // Convert raw data to activities
    const activities: HarmonyActivity[] = [];
    for (const item of rawData) {
      if (this.isRawActivity(item)) {
        activities.push(this.mapRawActivityToHarmonyActivity(item));
      } else {
        Logger.error("Invalid raw activity data:", item);
        continue;
      }
    }
    Logger.debug("Got activities from hub", {
      activityCount: activities.length,
      firstActivity: activities[0]
    });
    return activities;
  }
  /**
   * Clears cached configuration for this hub.
   * @throws {HarmonyError} If clearing cache fails
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info(`Clearing cache for hub ${this.hub.name}`);
      await LocalStorage.removeItem(this.cacheKey);
    } catch (err) {
      throw new HarmonyError("Failed to clear cache", ErrorCategory.CACHE, err instanceof Error ? err : undefined);
    }
  }
}
</file>

<file path="src/services/harmony/harmonyManager.ts">
/**
 * Manager class for discovering and managing Harmony Hubs on the network.
 * Handles hub discovery, caching, and validation of hub data.
 * @module
 */
import { Explorer } from "@harmonyhub/discover";
import { LocalStorage, showToast, Toast } from "@raycast/api";
import { HarmonyClient } from "../../services/harmony/harmonyClient";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import { HarmonyHub } from "../../types/core/harmony";
import { Logger } from "../logger";
// Constants
const DISCOVERY_TIMEOUT = 5000; // Reduced from 10s to 5s
const DISCOVERY_COMPLETE_DELAY = 500; // Wait 500ms after finding a hub before completing
const CACHE_KEY = "harmony-hubs";
const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours
interface CachedHubs {
  hubs: HarmonyHub[];
  timestamp: number;
}
/**
 * Interface for raw hub data received from discovery process
 * @interface HubDiscoveryData
 */
interface HubDiscoveryData {
  /** Unique identifier for the hub */
  uuid: string;
  /** IP address of the hub */
  ip: string;
  /** User-friendly name of the hub */
  friendlyName: string;
  /** Additional hub information */
  fullHubInfo: {
    /** Hub ID from Logitech service */
    hubId: string;
    /** Product ID of the hub */
    productId: string;
    /** Current firmware version */
    current_fw_version: string;
    /** Protocol version supported by the hub */
    protocolVersion: string;
    /** Port number for hub communication */
    port: string;
    /** Remote ID assigned by Harmony service */
    remoteId: string;
  };
}
/**
 * HarmonyManager class handles discovery and caching of Harmony Hubs on the network.
 * Provides methods for finding, validating, and caching hub data.
 */
export class HarmonyManager {
  /** Explorer instance for hub discovery */
  private explorer: Explorer | null = null;
  /** Flag indicating if discovery is in progress */
  private isDiscovering = false;
  /** Promise for current discovery operation */
  private discoveryPromise: Promise<HarmonyHub[]> | null = null;
  /** Timeout for completing discovery */
  private completeTimeout: NodeJS.Timeout | null = null;
  /**
   * Creates a validated HarmonyHub instance from discovery data
   * @param data - Raw hub data from discovery process
   * @returns Validated HarmonyHub instance
   * @throws {HarmonyError} If hub data is invalid
   */
  private createHub(data: HubDiscoveryData): HarmonyHub {
    // Validate required fields
    if (!data.friendlyName || !data.ip || !data.uuid || !data.fullHubInfo?.hubId) {
      throw new HarmonyError(
        "Invalid hub data received",
        ErrorCategory.VALIDATION,
        new Error(`Missing required fields: ${JSON.stringify(data)}`),
      );
    }
    return {
      id: data.uuid,
      name: data.friendlyName,
      ip: data.ip,
      hubId: data.fullHubInfo.hubId,
      remoteId: data.fullHubInfo.remoteId,
      version: data.fullHubInfo.current_fw_version,
      port: data.fullHubInfo.port,
      productId: data.fullHubInfo.productId,
      protocolVersion: data.fullHubInfo.protocolVersion,
    };
  }
  /**
   * Starts discovery of Harmony Hubs on the network.
   * Checks cache first, then performs network discovery if needed.
   * @param onProgress - Optional callback for progress updates
   * @returns Promise resolving to list of discovered hubs
   * @throws {HarmonyError} If discovery fails
   */
  public async startDiscovery(onProgress?: (progress: number, message: string) => void): Promise<HarmonyHub[]> {
    // Check cache first
    try {
      const cached = await this.getCachedHubs();
      if (cached) {
        Logger.info(`Found ${cached.length} cached hubs`);
        onProgress?.(1, `Found ${cached.length} cached hub(s)`);
        // Verify each cached hub is still accessible
        Logger.debug("Verifying cached hubs are accessible");
        const verifiedHubs: HarmonyHub[] = [];
        for (const hub of cached) {
          try {
            const client = new HarmonyClient(hub);
            await client.connect();
            await client.disconnect();
            verifiedHubs.push(hub);
            Logger.info(`Verified hub ${hub.name} is accessible`);
          } catch (err) {
            Logger.warn(`Cached hub ${hub.name} is no longer accessible, will be removed from cache`, err);
          }
        }
        if (verifiedHubs.length > 0) {
          Logger.info(`${verifiedHubs.length} of ${cached.length} cached hubs verified`);
          if (verifiedHubs.length !== cached.length) {
            // Update cache with only verified hubs
            await this.cacheHubs(verifiedHubs);
          }
          if (verifiedHubs.length === 1) {
            const hub = verifiedHubs[0];
            if (hub) {
              await showToast({
                style: Toast.Style.Success,
                title: "Auto-connecting to Hub",
                message: `Found single Harmony Hub: ${hub.name}`,
              });
            }
          }
          return verifiedHubs;
        }
        Logger.info("No cached hubs are accessible, proceeding with discovery");
      }
    } catch (error) {
      Logger.warn("Failed to read cache:", error);
      // Continue with discovery even if cache read fails
    }
    // If discovery is already in progress, return the existing promise
    if (this.discoveryPromise) {
      Logger.info("Discovery already in progress, returning existing promise");
      return this.discoveryPromise;
    }
    try {
      // Ensure cleanup of any previous explorer
      await this.cleanup();
      this.isDiscovering = true;
      onProgress?.(0, "Starting discovery process");
      Logger.info("Starting hub discovery process");
      this.explorer = new Explorer();
      // Create and store the discovery promise
      this.discoveryPromise = new Promise<HarmonyHub[]>((resolve, reject) => {
        if (!this.explorer) {
          const error = new HarmonyError("Explorer not initialized", ErrorCategory.STATE);
          Logger.error("Discovery failed - explorer not initialized");
          reject(error);
          return;
        }
        const hubs: HarmonyHub[] = [];
        // Function to complete discovery
        const completeDiscovery = async (): Promise<HarmonyHub[]> => {
          await this.cleanup();
          if (hubs.length > 0) {
            Logger.info(`Discovery completed successfully, found ${hubs.length} hubs`);
            await this.cacheHubs(hubs);
          } else {
            Logger.warn("Discovery completed but no hubs were found");
          }
          resolve(hubs);
          return hubs;
        };
        // Set timeout to stop discovery after DISCOVERY_TIMEOUT
        const timeout = setTimeout(async () => {
          Logger.info("Discovery timeout reached");
          await completeDiscovery();
        }, DISCOVERY_TIMEOUT);
        this.explorer.on("online", (data: HubDiscoveryData) => {
          try {
            Logger.debug("Received hub data", { data });
            const hub = this.createHub(data);
            // Check for duplicate hubs
            if (!hubs.some((h) => h.hubId === hub.hubId)) {
              hubs.push(hub);
              Logger.info(`Found hub: ${hub.name} (${hub.ip})`);
              onProgress?.(0.5, `Found hub: ${hub.name}`);
              // Clear any existing completion timeout
              if (this.completeTimeout) {
                clearTimeout(this.completeTimeout);
              }
              // Set a new completion timeout
              this.completeTimeout = setTimeout(async () => {
                clearTimeout(timeout);
                await completeDiscovery();
              }, DISCOVERY_COMPLETE_DELAY);
            } else {
              Logger.info(`Skipping duplicate hub: ${hub.name} (${hub.ip})`);
            }
          } catch (error) {
            Logger.error("Failed to process hub data:", error);
            // Don't reject here, just log and continue discovery
          }
        });
        this.explorer.on("error", async (error: Error) => {
          Logger.error("Discovery error:", error);
          clearTimeout(timeout);
          if (this.completeTimeout) {
            clearTimeout(this.completeTimeout);
          }
          await this.cleanup();
          reject(new HarmonyError("Hub discovery failed", ErrorCategory.HUB_COMMUNICATION, error));
        });
        // Start discovery
        Logger.debug("Starting explorer");
        this.explorer.start();
      });
      // Return the discovery promise
      return await this.discoveryPromise;
    } catch (error) {
      Logger.error("Failed to start discovery:", error);
      throw new HarmonyError("Failed to start hub discovery", ErrorCategory.HUB_COMMUNICATION, error as Error);
    } finally {
      this.isDiscovering = false;
      this.discoveryPromise = null;
    }
  }
  /**
   * Caches discovered hubs in local storage
   * @param hubs - List of hubs to cache
   * @throws {HarmonyError} If caching fails
   */
  private async cacheHubs(hubs: HarmonyHub[]): Promise<void> {
    try {
      const cache: CachedHubs = {
        hubs,
        timestamp: Date.now(),
      };
      await LocalStorage.setItem(CACHE_KEY, JSON.stringify(cache));
      Logger.info(`Cached ${hubs.length} hubs`);
    } catch (error) {
      Logger.warn("Failed to cache hubs:", error);
      throw new HarmonyError("Failed to cache hubs", ErrorCategory.STORAGE, error as Error);
    }
  }
  /**
   * Retrieves cached hubs if available and not expired
   * @returns Promise resolving to cached hubs or null if no valid cache exists
   * @throws {HarmonyError} If reading cache fails
   */
  private async getCachedHubs(): Promise<HarmonyHub[] | null> {
    try {
      const cached = await LocalStorage.getItem<string>(CACHE_KEY);
      if (!cached) return null;
      const { hubs, timestamp } = JSON.parse(cached) as CachedHubs;
      // Check if cache is expired
      if (Date.now() - timestamp > CACHE_TTL) {
        Logger.info("Cache expired");
        await LocalStorage.removeItem(CACHE_KEY);
        return null;
      }
      // Validate cached hub data
      for (const hub of hubs) {
        if (!hub.id || !hub.name || !hub.ip || !hub.hubId) {
          Logger.warn("Invalid hub data in cache, clearing cache");
          await LocalStorage.removeItem(CACHE_KEY);
          return null;
        }
      }
      return hubs;
    } catch (error) {
      Logger.warn("Failed to get cached hubs:", error);
      throw new HarmonyError("Failed to read hub cache", ErrorCategory.STORAGE, error as Error);
    }
  }
  /**
   * Cleans up discovery resources.
   * Stops the explorer and clears timeouts.
   */
  public async cleanup(): Promise<void> {
    if (this.explorer) {
      try {
        this.explorer.stop();
        this.explorer.removeAllListeners();
      } catch (error) {
        Logger.error("Error stopping explorer:", error);
      }
      this.explorer = null;
    }
    if (this.completeTimeout) {
      clearTimeout(this.completeTimeout);
      this.completeTimeout = null;
    }
    this.isDiscovering = false;
    this.discoveryPromise = null;
  }
  /**
   * Clears all caches including hub discovery and configs.
   * @throws {HarmonyError} If clearing caches fails
   */
  public async clearAllCaches(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub discovery cache
      await this.clearCache();
      // Clear all hub config caches
      const keys = await LocalStorage.allItems();
      for (const key of Object.keys(keys)) {
        if (key.startsWith("harmony-config-")) {
          await LocalStorage.removeItem(key);
        }
      }
    } catch (err) {
      throw new HarmonyError("Failed to clear caches", ErrorCategory.CACHE, err instanceof Error ? err : undefined);
    }
  }
  /**
   * Clears all cached data.
   * Removes hub cache and all hub-specific config caches.
   * @throws {HarmonyError} If clearing cache fails
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub cache
      await LocalStorage.removeItem(CACHE_KEY);
      // Clear all hub-specific config caches
      const allKeys = await LocalStorage.allItems();
      for (const key of Object.keys(allKeys)) {
        if (key.startsWith("harmony-config-")) {
          await LocalStorage.removeItem(key);
        }
      }
      Logger.info("All caches cleared");
    } catch (error) {
      Logger.error("Failed to clear caches:", error);
      throw new HarmonyError("Failed to clear caches", ErrorCategory.STORAGE, error as Error);
    }
  }
}
</file>

<file path="src/services/harmony/harmonyState.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "../../types/core/harmony";
/**
 * State machine stages for Harmony operations
 */
export enum HarmonyStage {
  DISCOVERING = "discovering",
  CONNECTING = "connecting",
  LOADING_ACTIVITIES = "loading-activities",
  LOADING_DEVICES = "loading-devices",
  COMPLETE = "complete",
}
/**
 * Loading state information
 */
export interface LoadingState {
  stage: HarmonyStage;
  progress: number;
  message: string;
}
/**
 * Core state for Harmony operations
 */
export interface HarmonyState {
  hubs: HarmonyHub[];
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  selectedHub: HarmonyHub | null;
  error: Error | null;
}
/**
 * Initial loading state
 */
export const initialLoadingState: LoadingState = {
  stage: HarmonyStage.DISCOVERING,
  progress: 0,
  message: "Initializing...",
};
/**
 * Initial harmony state
 */
export const initialHarmonyState: HarmonyState = {
  hubs: [],
  devices: [],
  activities: [],
  currentActivity: null,
  selectedHub: null,
  error: null,
};
</file>

<file path="src/services/errorHandler.ts">
import { showToast, Toast } from "@raycast/api";
import { HarmonyError, ErrorCategory, ErrorSeverity, ErrorRecoveryAction } from "../types/core/errors";
import { Logger } from "./logger";
/**
 * Configuration for error handling
 */
interface ErrorHandlerConfig {
  /** Whether to show toasts for errors */
  showToasts: boolean;
  /** Whether to log errors */
  logErrors: boolean;
  /** Default error category if none is specified */
  defaultCategory: ErrorCategory;
  /** Default error severity if none is specified */
  defaultSeverity: ErrorSeverity;
}
/**
 * Default configuration for error handling
 */
const defaultConfig: ErrorHandlerConfig = {
  showToasts: true,
  logErrors: true,
  defaultCategory: ErrorCategory.UNKNOWN,
  defaultSeverity: ErrorSeverity.ERROR,
};
/**
 * ErrorHandler class for consistent error handling across the application.
 * Provides methods for handling errors, showing user feedback, and logging.
 */
export class ErrorHandler {
  private static config: ErrorHandlerConfig = defaultConfig;
  /**
   * Configure the error handler
   * @param config - Partial configuration to merge with defaults
   */
  static configure(config: Partial<ErrorHandlerConfig>): void {
    ErrorHandler.config = { ...defaultConfig, ...config };
  }
  /**
   * Handle any type of error, converting it to a HarmonyError if needed
   */
  static handle(error: Error | unknown, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error);
    // Log the error if enabled
    if (ErrorHandler.config.logErrors) {
      Logger.logError(harmonyError, context);
    }
    // Show user feedback if enabled
    if (ErrorHandler.config.showToasts) {
      ErrorHandler.showErrorToast(harmonyError);
    }
  }
  /**
   * Handle a specific error with a category
   */
  static handleWithCategory(error: Error | unknown, category: ErrorCategory, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error, category);
    // Log the error if enabled
    if (ErrorHandler.config.logErrors) {
      Logger.logError(harmonyError, context);
    }
    // Show user feedback if enabled
    if (ErrorHandler.config.showToasts) {
      ErrorHandler.showErrorToast(harmonyError);
    }
  }
  /**
   * Convert any error to a HarmonyError
   */
  private static toHarmonyError(error: Error | unknown, category?: ErrorCategory): HarmonyError {
    if (error instanceof HarmonyError) {
      return error;
    }
    const defaultCategory = category || ErrorHandler.config.defaultCategory;
    const message = error instanceof Error ? error.message : String(error);
    const originalError = error instanceof Error ? error : undefined;
    return new HarmonyError(message, defaultCategory, originalError);
  }
  /**
   * Show an error toast to the user
   */
  private static showErrorToast(error: HarmonyError): void {
    const title = ErrorHandler.getCategoryTitle(error.category);
    showToast({
      style: Toast.Style.Failure,
      title,
      message: error.message,
    });
  }
  /**
   * Get a user-friendly title for an error category
   */
  private static getCategoryTitle(category: ErrorCategory): string {
    switch (category) {
      case ErrorCategory.CONNECTION:
      case ErrorCategory.NETWORK:
      case ErrorCategory.WEBSOCKET:
        return "Connection Error";
      case ErrorCategory.DISCOVERY:
        return "Discovery Error";
      case ErrorCategory.COMMAND:
      case ErrorCategory.COMMAND_EXECUTION:
        return "Command Error";
      case ErrorCategory.STATE:
        return "State Error";
      case ErrorCategory.DATA:
        return "Data Error";
      case ErrorCategory.HUB_COMMUNICATION:
        return "Hub Communication Error";
      case ErrorCategory.ACTIVITY_START:
        return "Activity Start Error";
      case ErrorCategory.ACTIVITY_STOP:
        return "Activity Stop Error";
      case ErrorCategory.VALIDATION:
        return "Validation Error";
      case ErrorCategory.STORAGE:
        return "Storage Error";
      case ErrorCategory.CACHE:
        return "Cache Error";
      case ErrorCategory.QUEUE:
        return "Queue Error";
      case ErrorCategory.HARMONY:
        return "Harmony Error";
      case ErrorCategory.AUTHENTICATION:
        return "Authentication Error";
      case ErrorCategory.SYSTEM:
        return "System Error";
      default:
        return "Error";
    }
  }
  /**
   * Handle an async operation with proper error handling
   */
  static async handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handle(error, context);
      throw error;
    }
  }
  /**
   * Handle an async operation with a specific error category
   */
  static async handleAsyncWithCategory<T>(
    operation: () => Promise<T>,
    category: ErrorCategory,
    context?: string,
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handleWithCategory(error, category, context);
      throw error;
    }
  }
  /**
   * Get recovery actions for an error
   */
  static getRecoveryActions(error: HarmonyError): ErrorRecoveryAction[] {
    const strategy = error.getDefaultRecoveryStrategy();
    return strategy?.actions || [ErrorRecoveryAction.MANUAL];
  }
  /**
   * Show a success toast
   */
  static showSuccess(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  /**
   * Show a warning toast
   */
  static showWarning(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Show a loading toast
   */
  static showLoading(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
}
</file>

<file path="src/services/localStorage.ts">
import { LocalStorage as RaycastLocalStorage } from "@raycast/api";
import { Logger } from "./logger";
export class LocalStorage {
  public static async getItem(key: string): Promise<string | null> {
    try {
      const value = await RaycastLocalStorage.getItem(key);
      return typeof value === "string" ? value : null;
    } catch (error) {
      Logger.error(`Failed to get item from storage: ${key}`, error);
      return null;
    }
  }
  public static async setItem(key: string, value: string): Promise<void> {
    try {
      await RaycastLocalStorage.setItem(key, value);
    } catch (error) {
      Logger.error(`Failed to set item in storage: ${key}`, error);
      throw error;
    }
  }
  public static async removeItem(key: string): Promise<void> {
    try {
      await RaycastLocalStorage.removeItem(key);
    } catch (error) {
      Logger.error(`Failed to remove item from storage: ${key}`, error);
      throw error;
    }
  }
  public static async clear(): Promise<void> {
    try {
      await RaycastLocalStorage.clear();
    } catch (error) {
      Logger.error("Failed to clear storage", error);
      throw error;
    }
  }
}
</file>

<file path="src/services/logger.ts">
/**
 * Logging service for the Harmony Hub integration
 * Provides structured logging with different severity levels
 * @module
 */
import { environment } from "@raycast/api";
/**
 * Log levels in order of increasing severity
 */
export enum LogLevel {
  /** Detailed debugging information */
  DEBUG = "DEBUG",
  /** General information about program execution */
  INFO = "INFO",
  /** Potentially harmful situations */
  WARN = "WARN",
  /** Error events that might still allow the program to continue */
  ERROR = "ERROR",
  /** Very severe error events that will likely lead to program termination */
  FATAL = "FATAL",
}
/**
 * Configuration options for the logger
 */
interface LoggerConfig {
  /** Minimum level of messages to log */
  minLevel: LogLevel;
  /** Whether to include timestamps in log messages */
  includeTimestamp: boolean;
  /** Whether to include the log level in messages */
  includeLevel: boolean;
  /** Whether to pretty print objects in log messages */
  prettyPrint: boolean;
}
/**
 * Default logger configuration
 */
const DEFAULT_CONFIG: LoggerConfig = {
  minLevel: environment.isDevelopment ? LogLevel.DEBUG : LogLevel.INFO,
  includeTimestamp: true,
  includeLevel: true,
  prettyPrint: true,
};
/**
 * Logger service for structured logging
 * Supports multiple log levels and configurable output formatting
 */
export class Logger {
  private static config: LoggerConfig = DEFAULT_CONFIG;
  /**
   * Configures the logger
   * @param config - Configuration options to apply
   */
  public static configure(config: Partial<LoggerConfig>): void {
    Logger.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Logs a debug message
   * @param message - The message to log
   * @param context - Optional context object to include
   */
  public static debug(message: string, context?: unknown): void {
    Logger.log(LogLevel.DEBUG, message, context);
  }
  /**
   * Logs an info message
   * @param message - The message to log
   * @param context - Optional context object to include
   */
  public static info(message: string, context?: unknown): void {
    Logger.log(LogLevel.INFO, message, context);
  }
  /**
   * Logs a warning message
   * @param message - The message to log
   * @param context - Optional context object to include
   */
  public static warn(message: string, context?: unknown): void {
    Logger.log(LogLevel.WARN, message, context);
  }
  /**
   * Logs an error message
   * @param message - The message to log
   * @param context - Optional context object to include
   */
  public static error(message: string, context?: unknown): void {
    Logger.log(LogLevel.ERROR, message, context);
  }
  /**
   * Logs a fatal error message
   * @param message - The message to log
   * @param context - Optional context object to include
   */
  public static fatal(message: string, context?: unknown): void {
    Logger.log(LogLevel.FATAL, message, context);
  }
  /**
   * Internal method to format and output log messages
   * @param level - The severity level of the message
   * @param message - The message to log
   * @param context - Optional context object to include
   */
  private static log(level: LogLevel, message: string, context?: unknown): void {
    if (Logger.shouldLog(level)) {
      const parts: string[] = [];
      if (Logger.config.includeTimestamp) {
        parts.push(new Date().toISOString());
      }
      if (Logger.config.includeLevel) {
        parts.push(`[${level}]`);
      }
      parts.push(message);
      if (context !== undefined) {
        const contextStr = Logger.config.prettyPrint
          ? JSON.stringify(context, null, 2)
          : JSON.stringify(context);
        parts.push(contextStr);
      }
      const logMessage = parts.join(" ");
      switch (level) {
        case LogLevel.DEBUG:
          console.debug(logMessage);
          break;
        case LogLevel.INFO:
          console.info(logMessage);
          break;
        case LogLevel.WARN:
          console.warn(logMessage);
          break;
        case LogLevel.ERROR:
        case LogLevel.FATAL:
          console.error(logMessage);
          break;
      }
    }
  }
  /**
   * Checks if a message at the given level should be logged
   * @param level - The severity level to check
   * @returns True if the message should be logged
   */
  private static shouldLog(level: LogLevel): boolean {
    const levels = Object.values(LogLevel);
    const minLevelIndex = levels.indexOf(Logger.config.minLevel);
    const currentLevelIndex = levels.indexOf(level);
    return currentLevelIndex >= minLevelIndex;
  }
}
export type LoggerType = typeof Logger;
</file>

<file path="src/services/session-manager.ts">
/**
 * Session management service for Harmony Hub integration.
 * Handles user session state, persistence, and cache management.
 * @module
 */
import { LocalStorage } from "@raycast/api";
import { ToastManager } from "../services/toast";
/**
 * Interface representing a user session.
 * Contains authentication and state information.
 * @interface Session
 */
interface Session {
  /** Authentication token for the session */
  token: string;
  /** Timestamp when the session expires */
  expiresAt: number;
  /** Timestamp of the last user activity */
  lastActivity: number;
}
/**
 * SessionManager class handles user session state and persistence.
 * Provides methods for storing and retrieving session data securely.
 * Manages session expiration and inactivity timeouts.
 */
export class SessionManager {
  /** Key for storing session data in local storage */
  private static readonly SESSION_KEY = "harmony_session";
  /** Key for storing general cache data */
  private static readonly CACHE_KEY = "harmony_cache";
  /** Key for storing hub-specific cache data */
  private static readonly HUB_CACHE_KEY = "harmony_hub_cache";
  /** Duration of a session in milliseconds (24 hours) */
  private static readonly SESSION_DURATION = 24 * 60 * 60 * 1000;
  /** Threshold for session inactivity in milliseconds (30 minutes) */
  private static readonly ACTIVITY_THRESHOLD = 30 * 60 * 1000;
  /**
   * Creates a new session with the given token.
   * Sets expiration and activity timestamps.
   * @param token - The session token to store
   * @returns Promise that resolves when the session is created
   */
  static async createSession(token: string): Promise<void> {
    const session: Session = {
      token,
      expiresAt: Date.now() + this.SESSION_DURATION,
      lastActivity: Date.now(),
    };
    await LocalStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
  }
  /**
   * Retrieves the current session if valid.
   * Checks for expiration and inactivity.
   * Updates last activity timestamp if session is valid.
   * @returns Promise resolving to the current session or null if invalid/expired
   */
  static async getSession(): Promise<Session | null> {
    try {
      const stored = await LocalStorage.getItem(this.SESSION_KEY);
      if (!stored || typeof stored !== "string") {
        return null;
      }
      const session = JSON.parse(stored) as Session;
      const now = Date.now();
      // Check if session has expired
      if (now > session.expiresAt) {
        await this.clearSession();
        return null;
      }
      // Check if session is inactive
      if (now - session.lastActivity > this.ACTIVITY_THRESHOLD) {
        await this.clearSession();
        return null;
      }
      // Update last activity
      session.lastActivity = now;
      await LocalStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
      return session;
    } catch (error) {
      console.error("Error getting session:", error);
      return null;
    }
  }
  /**
   * Clears the current session.
   * Removes session data from local storage.
   * @returns Promise that resolves when the session is cleared
   */
  static async clearSession(): Promise<void> {
    await LocalStorage.removeItem(this.SESSION_KEY);
  }
  /**
   * Clears all cached data.
   * Removes both general and hub-specific caches.
   * Shows success toast on completion.
   * @returns Promise that resolves when caches are cleared
   */
  static async clearCache(): Promise<void> {
    await Promise.all([LocalStorage.removeItem(this.CACHE_KEY), LocalStorage.removeItem(this.HUB_CACHE_KEY)]);
    await ToastManager.success("Cache cleared successfully");
  }
  /**
   * Validates the current session.
   * Shows error toast if session is invalid.
   * @returns Promise resolving to true if session is valid, false otherwise
   */
  static async validateSession(): Promise<boolean> {
    const session = await this.getSession();
    if (!session) {
      await ToastManager.error("Session Expired", "Please reconnect to your Hub");
      return false;
    }
    return true;
  }
}
</file>

<file path="src/services/toast.ts">
/**
 * Toast utility for user notifications
 * @module
 */
import { showToast, Toast } from "@raycast/api";
import { Logger } from "./logger";
/**
 * Configuration for toast notifications
 */
interface ToastConfig {
  /** Whether to log toast messages */
  logToasts: boolean;
  /** Whether to include timestamps in logs */
  includeTimestamp: boolean;
}
/**
 * Default configuration for toast notifications
 */
const defaultConfig: ToastConfig = {
  logToasts: true,
  includeTimestamp: true,
};
/**
 * ToastManager class for consistent user notifications across the application.
 * Provides methods for showing different types of toasts and optional logging.
 */
export class ToastManager {
  private static config: ToastConfig = defaultConfig;
  /**
   * Configure the toast manager
   * @param config - Partial configuration to merge with defaults
   */
  static configure(config: Partial<ToastConfig>): void {
    ToastManager.config = { ...defaultConfig, ...config };
  }
  /**
   * Show a success toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async success(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(`Success: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  /**
   * Show an error toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async error(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.error(`Error: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Show a warning toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async warning(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.warn(`Warning: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Failure, // Raycast doesn't have a warning style
      title,
      message,
    });
  }
  /**
   * Show a loading toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async loading(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(`Loading: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
  /**
   * Show a progress toast
   * @param title - Toast title
   * @param message - Optional toast message
   * @param progress - Progress value between 0 and 1
   */
  static async progress(title: string, message?: string, progress?: number): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(
        `Progress: ${title}${message ? ` - ${message}` : ""}${
          progress !== undefined ? ` (${Math.round(progress * 100)}%)` : ""
        }`,
      );
    }
    await showToast({
      style: Toast.Style.Animated,
      title,
      message: message ? (progress !== undefined ? `${message} (${Math.round(progress * 100)}%)` : message) : undefined,
    });
  }
}
</file>

<file path="src/stores/activityStore.ts">
/**
 * Store for managing Harmony Hub activities.
 * Handles activity listing, execution, and state tracking.
 * @module
 */
import { create } from "zustand";
import { HarmonyActivity } from "../types/core/harmony";
/**
 * State interface for the activity store.
 * Contains activity list, current activity, and execution states.
 * @interface ActivityState
 */
interface ActivityState {
  /** List of available activities from the hub */
  activities: HarmonyActivity[];
  /** Currently running activity on the hub */
  currentActivity: HarmonyActivity | null;
  /** Whether activities are being loaded from the hub */
  isLoading: boolean;
  /** Error message if loading or execution failed */
  error: string | null;
  /** Whether an activity change is in progress */
  isChanging: boolean;
  /** Timestamp of the last activity state change */
  lastChangeTime: number | null;
}
/**
 * Actions that can be performed on the activity store.
 * Includes activity management and execution operations.
 * @interface ActivityActions
 */
interface ActivityActions {
  /** Set the list of available activities
   * @param activities - List of activities to set
   */
  setActivities: (activities: HarmonyActivity[]) => void;
  /** Update the currently running activity
   * @param activity - Activity that is now running, or null if none
   */
  setCurrentActivity: (activity: HarmonyActivity | null) => void;
  /** Set the loading state
   * @param isLoading - Whether activities are being loaded
   */
  setLoading: (isLoading: boolean) => void;
  /** Set an error message
   * @param error - Error message to display, or null to clear
   */
  setError: (error: string | null) => void;
  /** Start an activity change operation
   * @param activity - Activity being started
   */
  startChange: (activity: HarmonyActivity) => void;
  /** Complete an activity change operation
   * @param success - Whether the change was successful
   * @param error - Error message if change failed
   */
  completeChange: (success: boolean, error?: string) => void;
  /** Reset the store to its initial state */
  reset: () => void;
}
/** Initial state for the activity store */
const initialState: ActivityState = {
  activities: [],
  currentActivity: null,
  isLoading: false,
  error: null,
  isChanging: false,
  lastChangeTime: null,
};
/**
 * Store for managing Harmony Hub activities.
 * Handles activity loading, tracking current activity, and activity changes.
 * Uses Zustand for state management.
 */
export const useActivityStore = create<ActivityState & ActivityActions>((set) => ({
  ...initialState,
  setActivities: (activities) =>
    set({
      activities,
      isLoading: false,
      error: null,
    }),
  setCurrentActivity: (activity) =>
    set({
      currentActivity: activity,
    }),
  setLoading: (isLoading) =>
    set({
      isLoading,
      error: null,
    }),
  setError: (error) =>
    set({
      error,
      isLoading: false,
      isChanging: false,
    }),
  startChange: (activity) =>
    set({
      isChanging: true,
      error: null,
    }),
  completeChange: (success, error) =>
    set({
      isChanging: false,
      error: error || null,
      lastChangeTime: Date.now(),
    }),
  reset: () => set(initialState),
}));
</file>

<file path="src/stores/commandStore.ts">
/**
 * Store for managing command execution state.
 * Handles command queuing, execution tracking, and statistics.
 * @module
 */
import { create } from "zustand";
import { HarmonyCommand } from "../types/core/harmony";
/**
 * State interface for the command store.
 * Contains command execution state and statistics.
 * @interface CommandState
 */
interface CommandState {
  /** Currently executing command */
  currentCommand: HarmonyCommand | null;
  /** Queue of commands waiting to be executed */
  commandQueue: HarmonyCommand[];
  /** Whether a command is currently executing */
  isExecuting: boolean;
  /** Error message if command execution failed */
  error: string | null;
  /** Number of commands successfully executed */
  successCount: number;
  /** Number of commands that failed to execute */
  failureCount: number;
  /** Timestamp of the last command execution */
  lastExecutionTime: number | null;
}
/**
 * Actions that can be performed on the command store.
 * Includes command execution and queue management.
 * @interface CommandActions
 */
interface CommandActions {
  /** Add a command to the execution queue
   * @param command - Command to add to the queue
   */
  queueCommand: (command: HarmonyCommand) => void;
  /** Start executing a command
   * @param command - Command to execute
   */
  startExecution: (command: HarmonyCommand) => void;
  /** Mark the current command execution as complete
   * @param success - Whether the execution was successful
   * @param error - Error message if execution failed
   */
  completeExecution: (success: boolean, error?: string) => void;
  /** Clear the command queue */
  clearQueue: () => void;
  /** Reset execution statistics */
  resetStats: () => void;
  /** Reset the store to its initial state */
  reset: () => void;
}
/** Initial state for the command store */
const initialState: CommandState = {
  currentCommand: null,
  commandQueue: [],
  isExecuting: false,
  error: null,
  successCount: 0,
  failureCount: 0,
  lastExecutionTime: null,
};
/**
 * Store for managing command execution state.
 * Handles command queuing, execution tracking, and statistics.
 * Uses Zustand for state management.
 */
export const useCommandStore = create<CommandState & CommandActions>((set) => ({
  ...initialState,
  queueCommand: (command) =>
    set((state) => ({
      commandQueue: [...state.commandQueue, command],
    })),
  startExecution: (command) =>
    set({
      currentCommand: command,
      isExecuting: true,
      error: null,
    }),
  completeExecution: (success, error) =>
    set((state) => ({
      currentCommand: null,
      isExecuting: false,
      error: error || null,
      successCount: success ? state.successCount + 1 : state.successCount,
      failureCount: success ? state.failureCount : state.failureCount + 1,
      lastExecutionTime: Date.now(),
    })),
  clearQueue: () =>
    set({
      commandQueue: [],
    }),
  resetStats: () =>
    set({
      successCount: 0,
      failureCount: 0,
      lastExecutionTime: null,
    }),
  reset: () => set(initialState),
}));
</file>

<file path="src/stores/deviceStore.ts">
/**
 * Store for managing Harmony Hub devices.
 * Handles device listing, selection, and command management.
 * @module
 */
import { create } from "zustand";
import { HarmonyDevice } from "../types/core/harmony";
/**
 * State interface for the device store.
 * Contains device list, selection, and loading states.
 * @interface DeviceState
 */
interface DeviceState {
  /** List of available devices from the hub */
  devices: HarmonyDevice[];
  /** Currently selected device for command execution */
  selectedDevice: HarmonyDevice | null;
  /** Whether devices are being loaded from the hub */
  isLoading: boolean;
  /** Error message if loading or command execution failed */
  error: string | null;
  /** Timestamp of the last device list update */
  lastUpdateTime: number | null;
}
/**
 * Actions that can be performed on the device store.
 * Includes device management and command operations.
 * @interface DeviceActions
 */
interface DeviceActions {
  /** Set the list of available devices
   * @param devices - List of devices to set
   */
  setDevices: (devices: HarmonyDevice[]) => void;
  /** Select a device for command execution
   * @param device - Device to select, or null to clear selection
   */
  selectDevice: (device: HarmonyDevice | null) => void;
  /** Set the loading state
   * @param isLoading - Whether devices are being loaded
   */
  setLoading: (isLoading: boolean) => void;
  /** Set an error message
   * @param error - Error message to display, or null to clear
   */
  setError: (error: string | null) => void;
  /** Update a device's command list
   * @param deviceId - ID of the device to update
   * @param commands - New commands for the device
   */
  updateDeviceCommands: (deviceId: string, commands: HarmonyDevice["commands"]) => void;
  /** Reset the store to its initial state */
  reset: () => void;
}
/** Initial state for the device store */
const initialState: DeviceState = {
  devices: [],
  selectedDevice: null,
  isLoading: false,
  error: null,
  lastUpdateTime: null,
};
/**
 * Store for managing Harmony Hub devices.
 * Handles device loading, selection, and command updates.
 * Uses Zustand for state management.
 */
export const useDeviceStore = create<DeviceState & DeviceActions>((set) => ({
  ...initialState,
  setDevices: (devices) =>
    set({
      devices,
      isLoading: false,
      error: null,
      lastUpdateTime: Date.now(),
    }),
  selectDevice: (device) =>
    set({
      selectedDevice: device,
    }),
  setLoading: (isLoading) =>
    set({
      isLoading,
      error: null,
    }),
  setError: (error) =>
    set({
      error,
      isLoading: false,
    }),
  updateDeviceCommands: (deviceId, commands) =>
    set((state) => ({
      devices: state.devices.map((device) =>
        device.id === deviceId
          ? {
              ...device,
              commands,
            }
          : device,
      ),
      lastUpdateTime: Date.now(),
    })),
  reset: () => set(initialState),
}));
</file>

<file path="src/stores/harmony.ts">
/**
 * Harmony Hub state management store
 * @module
 */
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { ErrorHandler } from "../services/errorHandler";
import { LocalStorage } from "../services/localStorage";
import { Logger } from "../services/logger";
import { ToastManager } from "../services/toast";
import {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  HarmonyError,
  ErrorCategory,
  LoadingState,
  HarmonyStage,
} from "../types/core";
import {
  MutableHarmonyState,
  toMutableHub,
  toMutableDevice,
  toMutableActivity,
  toMutableLoadingState,
} from "../types/core/state-mutable";
/**
 * Actions that can be performed on the store
 */
interface HarmonyActions {
  // Hub Management
  discoverHubs: () => Promise<void>;
  selectHub: (hub: HarmonyHub) => Promise<void>;
  disconnectHub: () => Promise<void>;
  // Device Management
  loadDevices: () => Promise<void>;
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  // Activity Management
  loadActivities: () => Promise<void>;
  startActivity: (activity: HarmonyActivity) => Promise<void>;
  stopActivity: (activity: HarmonyActivity) => Promise<void>;
  // State Management
  setError: (error: HarmonyError | null) => void;
  clearError: () => void;
  setLoadingState: (state: LoadingState) => void;
  reset: () => void;
}
/**
 * Combined store type with state and actions
 */
type HarmonyStore = MutableHarmonyState & HarmonyActions;
/**
 * Create the Harmony store with Zustand and Immer
 */
export const useHarmonyStore = create<HarmonyStore>()(
  immer((set, get) => {
    // Load persisted state
    const loadPersistedState = async (): Promise<void> => {
      try {
        const persistedJSON = await LocalStorage.getItem("harmony-hub-state");
        if (persistedJSON) {
          const { state } = JSON.parse(persistedJSON);
          set((draft) => {
            if (state.selectedHub) {
              draft.selectedHub = toMutableHub(state.selectedHub);
            }
            if (state.hubs) {
              draft.hubs = state.hubs.map(toMutableHub);
            }
          });
          Logger.info("Loaded persisted hub state");
        }
      } catch (err) {
        Logger.error("Failed to load persisted hub state", err);
      }
    };
    // Save state changes
    const saveState = async (state: HarmonyStore): Promise<void> => {
      try {
        const persistedState = {
          selectedHub: state.selectedHub,
          hubs: state.hubs,
        };
        await LocalStorage.setItem("harmony-hub-state", JSON.stringify({ state: persistedState, version: 1 }));
        Logger.info("Saved hub state");
      } catch (err) {
        Logger.error("Failed to save hub state", err);
      }
    };
    // Initialize state
    loadPersistedState();
    return {
      // Initial State
      hubs: [],
      selectedHub: null,
      devices: [],
      activities: [],
      currentActivity: null,
      error: null,
      loadingState: {
        stage: HarmonyStage.INITIAL,
        progress: 0,
        message: "Ready",
      },
      // Hub Management Actions
      discoverHubs: async () => {
        try {
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.DISCOVERING,
              progress: 0,
              message: "Discovering Harmony Hubs...",
            });
            state.error = null;
          });
          // TODO: Implement hub discovery
          const hubs: HarmonyHub[] = [];
          set((state) => {
            state.hubs = hubs.map(toMutableHub);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 1,
              message: `Found ${hubs.length} hub(s)`,
            });
          });
          saveState(get());
          ToastManager.success(`Found ${hubs.length} Harmony Hub(s)`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to discover hubs",
                  ErrorCategory.DISCOVERY,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Hub discovery failed");
          set((state) => {
            state.error = harmonyError;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.ERROR,
              progress: 1,
              message: "Hub discovery failed",
            });
          });
        }
      },
      selectHub: async (hub) => {
        try {
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTING,
              progress: 0,
              message: `Connecting to ${hub.name}...`,
            });
            state.error = null;
          });
          // TODO: Implement hub connection
          set((state) => {
            state.selectedHub = toMutableHub(hub);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Connected to ${hub.name}`,
            });
          });
          saveState(get());
          // Load devices and activities
          await get().loadDevices();
          await get().loadActivities();
          ToastManager.success(`Connected to ${hub.name}`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to connect to hub",
                  ErrorCategory.CONNECTION,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Hub connection failed");
          set((state) => {
            state.error = harmonyError;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.ERROR,
              progress: 1,
              message: "Connection failed",
            });
          });
        }
      },
      disconnectHub: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) return;
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 0,
              message: "Disconnecting...",
            });
          });
          // TODO: Implement hub disconnection
          set((state) => {
            state.selectedHub = null;
            state.devices = [];
            state.activities = [];
            state.currentActivity = null;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 1,
              message: "Disconnected",
            });
          });
          saveState(get());
          ToastManager.success("Disconnected from Harmony Hub");
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to disconnect",
                  ErrorCategory.CONNECTION,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Hub disconnection failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      // Device Management Actions
      loadDevices: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.LOADING_DEVICES,
              progress: 0,
              message: "Loading devices...",
            });
          });
          // TODO: Implement device loading
          const devices: HarmonyDevice[] = [];
          set((state) => {
            state.devices = devices.map(toMutableDevice);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Loaded ${devices.length} devices`,
            });
          });
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to load devices",
                  ErrorCategory.DATA,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Device loading failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      executeCommand: async (command) => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.EXECUTING_COMMAND,
              progress: 0,
              message: `Executing command: ${command.label}`,
            });
          });
          // TODO: Implement command execution
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Executed command: ${command.label}`,
            });
          });
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to execute command",
                  ErrorCategory.COMMAND,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Command execution failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      // Activity Management Actions
      loadActivities: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.LOADING_ACTIVITIES,
              progress: 0,
              message: "Loading activities...",
            });
          });
          // TODO: Implement activity loading
          const activities: HarmonyActivity[] = [];
          set((state) => {
            state.activities = activities.map(toMutableActivity);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Loaded ${activities.length} activities`,
            });
          });
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to load activities",
                  ErrorCategory.DATA,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Activity loading failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      startActivity: async (activity) => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.STARTING_ACTIVITY,
              progress: 0,
              message: `Starting activity: ${activity.name}`,
            });
          });
          // TODO: Implement activity start
          set((state) => {
            state.currentActivity = toMutableActivity(activity);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Started activity: ${activity.name}`,
            });
          });
          ToastManager.success(`Started activity: ${activity.name}`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to start activity",
                  ErrorCategory.COMMAND,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Activity start failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      stopActivity: async (activity) => {
        try {
          const { selectedHub, currentActivity } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          if (!currentActivity) {
            throw new HarmonyError("No activity is running", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.STOPPING_ACTIVITY,
              progress: 0,
              message: `Stopping activity: ${activity.name}`,
            });
          });
          // TODO: Implement activity stop
          set((state) => {
            state.currentActivity = null;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Stopped activity: ${activity.name}`,
            });
          });
          ToastManager.success(`Stopped activity: ${activity.name}`);
        } catch (error) {
          const harmonyError =
            error instanceof HarmonyError
              ? error
              : new HarmonyError(
                  "Failed to stop activity",
                  ErrorCategory.COMMAND,
                  error instanceof Error ? error : undefined,
                );
          ErrorHandler.handle(harmonyError, "Activity stop failed");
          set((state) => {
            state.error = harmonyError;
          });
        }
      },
      // State Management Actions
      setError: (error) => {
        set((state) => {
          state.error = error;
        });
      },
      clearError: () => {
        set((state) => {
          state.error = null;
        });
      },
      setLoadingState: (loadingState) => {
        set((state) => {
          state.loadingState = toMutableLoadingState(loadingState);
        });
      },
      reset: () => {
        set((state) => {
          state.hubs = [];
          state.selectedHub = null;
          state.devices = [];
          state.activities = [];
          state.currentActivity = null;
          state.error = null;
          state.loadingState = toMutableLoadingState({
            stage: HarmonyStage.INITIAL,
            progress: 0,
            message: "Ready",
          });
        });
        saveState(get());
      },
    };
  }),
);
// Export selectors for common state derivations
export const selectHubs = (state: HarmonyStore): readonly HarmonyHub[] => state.hubs;
export const selectSelectedHub = (state: HarmonyStore): HarmonyHub | null => state.selectedHub;
export const selectDevices = (state: HarmonyStore): readonly HarmonyDevice[] => state.devices;
export const selectActivities = (state: HarmonyStore): readonly HarmonyActivity[] => state.activities;
export const selectCurrentActivity = (state: HarmonyStore): HarmonyActivity | null => state.currentActivity;
export const selectError = (state: HarmonyStore): HarmonyError | null => state.error as HarmonyError | null;
export const selectLoadingState = (state: HarmonyStore): LoadingState => ({
  stage: state.loadingState.stage as HarmonyStage,
  progress: state.loadingState.progress,
  message: state.loadingState.message,
});
export const selectIsLoading = (state: HarmonyStore): boolean =>
  state.loadingState.stage !== HarmonyStage.INITIAL &&
  state.loadingState.stage !== HarmonyStage.CONNECTED &&
  state.loadingState.stage !== HarmonyStage.ERROR;
</file>

<file path="src/stores/hubStore.ts">
/**
 * Store for managing Harmony Hub connections.
 * Handles hub discovery, selection, and connection state.
 * @module
 */
import { create } from "zustand";
import { HarmonyHub } from "../types/core/harmony";
/**
 * State interface for the hub store.
 * Contains hub list, selection, and connection states.
 * @interface HubState
 */
interface HubState {
  /** List of discovered Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub for interaction */
  selectedHub: HarmonyHub | null;
  /** Whether hub discovery is in progress */
  isDiscovering: boolean;
  /** Whether a connection attempt is in progress */
  isConnecting: boolean;
  /** Error message if discovery or connection failed */
  error: string | null;
  /** Timestamp of the last successful discovery */
  lastDiscoveryTime: number | null;
  /** Timestamp of the last successful connection */
  lastConnectionTime: number | null;
}
/**
 * Actions that can be performed on the hub store.
 * Includes hub management, discovery, and connection operations.
 * @interface HubActions
 */
interface HubActions {
  /** Set the list of discovered hubs
   * @param hubs - List of hubs to set
   */
  setHubs: (hubs: HarmonyHub[]) => void;
  /** Select a hub for interaction
   * @param hub - Hub to select, or null to clear selection
   */
  selectHub: (hub: HarmonyHub | null) => void;
  /** Set the discovery state
   * @param isDiscovering - Whether discovery is in progress
   */
  setDiscovering: (isDiscovering: boolean) => void;
  /** Set the connection state
   * @param isConnecting - Whether connection is in progress
   */
  setConnecting: (isConnecting: boolean) => void;
  /** Set an error message
   * @param error - Error message to display, or null to clear
   */
  setError: (error: string | null) => void;
  /** Start hub discovery process */
  startDiscovery: () => void;
  /** Complete hub discovery process
   * @param success - Whether discovery was successful
   * @param error - Error message if discovery failed
   */
  completeDiscovery: (success: boolean, error?: string) => void;
  /** Start hub connection process
   * @param hub - Hub to connect to
   */
  startConnection: (hub: HarmonyHub) => void;
  /** Complete hub connection process
   * @param success - Whether connection was successful
   * @param error - Error message if connection failed
   */
  completeConnection: (success: boolean, error?: string) => void;
  /** Reset the store to its initial state */
  reset: () => void;
}
/** Initial state for the hub store */
const initialState: HubState = {
  hubs: [],
  selectedHub: null,
  isDiscovering: false,
  isConnecting: false,
  error: null,
  lastDiscoveryTime: null,
  lastConnectionTime: null,
};
/**
 * Store for managing Harmony Hub connections.
 * Handles hub discovery, selection, and connection state.
 * Uses Zustand for state management.
 */
export const useHubStore = create<HubState & HubActions>((set) => ({
  ...initialState,
  setHubs: (hubs) =>
    set({
      hubs,
      isDiscovering: false,
      error: null,
    }),
  selectHub: (hub) =>
    set({
      selectedHub: hub,
    }),
  setDiscovering: (isDiscovering) =>
    set({
      isDiscovering,
      error: null,
    }),
  setConnecting: (isConnecting) =>
    set({
      isConnecting,
      error: null,
    }),
  setError: (error) =>
    set({
      error,
      isDiscovering: false,
      isConnecting: false,
    }),
  startDiscovery: () =>
    set({
      isDiscovering: true,
      error: null,
    }),
  completeDiscovery: (success, error) =>
    set({
      isDiscovering: false,
      error: error || null,
      lastDiscoveryTime: Date.now(),
    }),
  startConnection: (hub) =>
    set({
      selectedHub: hub,
      isConnecting: true,
      error: null,
    }),
  completeConnection: (success, error) =>
    set({
      isConnecting: false,
      error: error || null,
      lastConnectionTime: Date.now(),
    }),
  reset: () => set(initialState),
}));
</file>

<file path="src/stores/view.ts">
/**
 * View state management store
 * @module
 */
import { getPreferenceValues } from "@raycast/api";
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { LocalStorage } from "../services/localStorage";
import { Logger } from "../services/logger";
import { HarmonyDevice, HarmonyActivity } from "../types/core/harmony";
import { View, ViewFilters, ViewActions, MutableViewState } from "../types/core/views";
import { Preferences } from "../types/preferences";
import { toMutableDevice, toMutableActivity } from "../utils/state";
/**
 * Combined store type with state and actions
 */
type ViewStore = MutableViewState & ViewActions;
/**
 * Create the view store with Zustand and Immer
 */
export const useViewStore = create<ViewStore>()(
  immer((set, get) => {
    const preferences = getPreferenceValues<Preferences>();
    Logger.debug("Initializing view store with preferences", { defaultView: preferences.defaultView });
    // Load persisted state
    const loadPersistedState = async (): Promise<void> => {
      try {
        const persistedJSON = await LocalStorage.getItem("harmony-view-state");
        if (persistedJSON) {
          const { state } = JSON.parse(persistedJSON);
          set((draft) => {
            // Don't override the default view from preferences
            draft.filters = state.filters;
          });
          Logger.info("Loaded persisted view state");
        }
      } catch (err) {
        Logger.error("Failed to load persisted view state", err);
      }
    };
    // Save state changes
    const saveState = async (state: ViewStore): Promise<void> => {
      try {
        const persistedState = {
          filters: state.filters,
        };
        await LocalStorage.setItem("harmony-view-state", JSON.stringify({ state: persistedState, version: 1 }));
        Logger.info("Saved view state");
      } catch (err) {
        Logger.error("Failed to save view state", err);
      }
    };
    // Initialize state
    loadPersistedState();
    const initialView = preferences.defaultView === "activities" ? View.ACTIVITIES : View.DEVICES;
    Logger.debug("Setting initial view", { initialView });
    return {
      // Initial State
      currentView: initialView,
      selectedDevice: null,
      selectedActivity: null,
      searchQuery: "",
      filters: {
        deviceType: undefined,
        activityType: undefined,
        showFavorites: false,
      },
      // View Actions
      changeView: (view: View) => {
        set((state: MutableViewState) => {
          // If transitioning from hubs view after connection, use the preferred view
          if (state.currentView === View.HUBS && view === View.DEVICES) {
            const preferences = getPreferenceValues<Preferences>();
            state.currentView = preferences.defaultView === "activities" ? View.ACTIVITIES : View.DEVICES;
          } else {
            state.currentView = view;
          }
          // Clear selection when changing views
          if (view !== View.DEVICE_DETAIL) {
            state.selectedDevice = null;
          }
          if (view !== View.ACTIVITY_DETAIL) {
            state.selectedActivity = null;
          }
          // Clear search and filters
          state.searchQuery = "";
          state.filters = {
            deviceType: undefined,
            activityType: undefined,
            showFavorites: false,
          };
        });
        saveState(get());
      },
      selectDevice: (device: HarmonyDevice) => {
        Logger.debug("Selecting device in store", { device });
        set((state: MutableViewState) => {
          state.selectedDevice = toMutableDevice(device);
          state.currentView = View.DEVICE_DETAIL;
        });
        saveState(get());
      },
      selectActivity: (activity: HarmonyActivity) => {
        set((state: MutableViewState) => {
          state.selectedActivity = toMutableActivity(activity);
          state.currentView = View.ACTIVITY_DETAIL;
        });
        saveState(get());
      },
      clearSelection: () => {
        set((state: MutableViewState) => {
          if (state.currentView === View.DEVICE_DETAIL) {
            state.currentView = View.DEVICES;
            state.selectedDevice = null;
          } else if (state.currentView === View.ACTIVITY_DETAIL) {
            state.currentView = View.ACTIVITIES;
            state.selectedActivity = null;
          }
        });
        saveState(get());
      },
      setSearch: (query: string) => {
        set((state: MutableViewState) => {
          state.searchQuery = query;
        });
      },
      setFilters: (filters: Partial<ViewFilters>) => {
        set((state: MutableViewState) => {
          state.filters = {
            ...state.filters,
            ...filters,
          };
        });
        saveState(get());
      },
    };
  }),
);
// Selectors
export const selectCurrentView = (state: ViewStore): View => state.currentView;
export const selectSelectedDevice = (state: ViewStore): HarmonyDevice | null => state.selectedDevice;
export const selectSelectedActivity = (state: ViewStore): HarmonyActivity | null => state.selectedActivity;
export const selectSearchQuery = (state: ViewStore): string => state.searchQuery;
export const selectFilters = (state: ViewStore): ViewFilters => state.filters;
// Derived selectors
export const selectIsDetailView = (state: ViewStore): boolean =>
  state.currentView === View.DEVICE_DETAIL || state.currentView === View.ACTIVITY_DETAIL;
export const selectCanGoBack = (state: ViewStore): boolean =>
  state.currentView === View.DEVICE_DETAIL || state.currentView === View.ACTIVITY_DETAIL;
</file>

<file path="src/stores/viewStore.ts">
/**
 * Store for managing view state in the application
 * @module
 */
import { create } from "zustand";
/**
 * Available views in the application
 */
export enum View {
  /** View for managing devices */
  DEVICES = "devices",
  /** View for managing activities */
  ACTIVITIES = "activities",
  /** View for executing commands */
  COMMANDS = "commands",
}
/**
 * State interface for the view store
 */
interface ViewState {
  /** Currently active view */
  currentView: View;
  /** Previously active view */
  previousView: View | null;
  /** Whether the view is in a loading state */
  isLoading: boolean;
  /** Error message if any */
  error: string | null;
  /** Selected device ID if in device view */
  selectedDeviceId: string | null;
  /** Selected activity ID if in activity view */
  selectedActivityId: string | null;
}
/**
 * Actions that can be performed on the view store
 */
interface ViewActions {
  /** Set the current view
   * @param view - View to set as current
   */
  setView: (view: View) => void;
  /** Set the loading state
   * @param isLoading - Whether the view is loading
   */
  setLoading: (isLoading: boolean) => void;
  /** Set an error message
   * @param error - Error message to display
   */
  setError: (error: string | null) => void;
  /** Select a device
   * @param deviceId - ID of the device to select
   */
  selectDevice: (deviceId: string | null) => void;
  /** Select an activity
   * @param activityId - ID of the activity to select
   */
  selectActivity: (activityId: string | null) => void;
  /** Reset the store to its initial state */
  reset: () => void;
}
/**
 * Initial state for the view store
 */
const initialState: ViewState = {
  currentView: View.DEVICES,
  previousView: null,
  isLoading: false,
  error: null,
  selectedDeviceId: null,
  selectedActivityId: null,
};
/**
 * Store for managing view state
 * Handles view transitions, loading states, and selection
 */
export const useViewStore = create<ViewState & ViewActions>((set) => ({
  ...initialState,
  setView: (view) =>
    set((state) => ({
      currentView: view,
      previousView: state.currentView,
    })),
  setLoading: (isLoading) =>
    set({
      isLoading,
      error: null,
    }),
  setError: (error) =>
    set({
      error,
      isLoading: false,
    }),
  selectDevice: (deviceId) =>
    set({
      selectedDeviceId: deviceId,
      selectedActivityId: null,
    }),
  selectActivity: (activityId) =>
    set({
      selectedActivityId: activityId,
      selectedDeviceId: null,
    }),
  reset: () => set(initialState),
}));
</file>

<file path="src/types/core/command.ts">
/**
 * Command-related type definitions for Harmony Hub integration
 * @module
 */
/**
 * Status of a command in the queue
 * @enum {string}
 */
export enum CommandStatus {
  /** Command is queued for execution */
  QUEUED = "QUEUED",
  /** Command is pending execution */
  PENDING = "PENDING",
  /** Command is currently executing */
  EXECUTING = "EXECUTING",
  /** Command has completed successfully */
  COMPLETED = "COMPLETED",
  /** Command has failed */
  FAILED = "FAILED",
  /** Command was cancelled */
  CANCELLED = "CANCELLED",
}
/**
 * Command queue configuration
 * @interface CommandQueueConfig
 */
export interface CommandQueueConfig {
  /** Maximum number of commands that can be queued */
  readonly maxQueueSize?: number;
  /** Maximum number of commands that can run concurrently */
  readonly maxConcurrent?: number;
  /** Default timeout for command execution in milliseconds */
  readonly defaultTimeout?: number;
  /** Default number of retries for failed commands */
  readonly defaultRetries?: number;
  /** Delay between commands in milliseconds */
  readonly commandDelay?: number;
}
/**
 * Command request for the queue
 * @interface CommandRequest
 */
export interface CommandRequest {
  /** Unique identifier for the command request */
  readonly id: string;
  /** Command to execute */
  readonly command: import("./harmony").HarmonyCommand;
  /** Timestamp when the request was created */
  readonly timestamp: number;
  /** Optional timeout in milliseconds */
  readonly timeout?: number;
  /** Optional number of retries */
  readonly retries?: number;
  /** Optional callback when command completes successfully */
  readonly onComplete?: () => void;
  /** Optional callback when command fails */
  readonly onError?: (error: Error) => void;
}
/**
 * Result of a command execution
 * @interface CommandResult
 */
export interface CommandResult {
  /** Unique identifier matching the request */
  readonly id: string;
  /** Command that was executed */
  readonly command: import("./harmony").HarmonyCommand;
  /** Current status of the command */
  readonly status: CommandStatus;
  /** Error if command failed */
  readonly error?: Error;
  /** When the command was queued */
  readonly queuedAt: number;
  /** When the command started executing */
  readonly startedAt?: number;
  /** When the command completed (success or failure) */
  readonly completedAt?: number;
}
/**
 * Error recovery actions for failed commands
 * @enum {string}
 */
export enum ErrorRecoveryAction {
  /** Retry the operation */
  RETRY = "retry",
  /** Reconnect to the hub */
  RECONNECT = "reconnect",
  /** Clear cache and retry */
  CLEAR_CACHE = "clear_cache",
  /** Reset configuration */
  RESET_CONFIG = "reset_config",
  /** Restart extension */
  RESTART = "restart",
  /** Manual user intervention required */
  MANUAL = "manual",
}
/**
 * Retry configuration for error handling
 * @interface RetryConfig
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  readonly maxAttempts: number;
  /** Base delay between retries in milliseconds */
  readonly baseDelay: number;
  /** Maximum delay between retries in milliseconds */
  readonly maxDelay: number;
  /** Whether to use exponential backoff */
  readonly useExponentialBackoff: boolean;
  /** Categories to never retry */
  readonly nonRetryableCategories?: import("./harmony").ErrorCategory[];
  /** Maximum total retry duration in milliseconds */
  readonly maxRetryDuration?: number;
}
/**
 * Timeout configuration for operations
 * @interface TimeoutConfig
 */
export interface TimeoutConfig {
  /** Connection timeout in milliseconds */
  readonly connection: number;
  /** Message timeout in milliseconds */
  readonly message: number;
  /** Activity timeout in milliseconds */
  readonly activity: number;
  /** Command timeout in milliseconds */
  readonly command: number;
  /** Discovery timeout in milliseconds */
  readonly discovery: number;
  /** Cache timeout in milliseconds */
  readonly cache: number;
}
/**
 * Retry context for error handling
 * @interface RetryContext
 */
export interface RetryContext {
  /** Number of retry attempts made */
  readonly attempts: number;
  /** Time of first attempt */
  readonly firstAttempt: number;
  /** Time of last attempt */
  readonly lastAttempt: number;
  /** Next scheduled retry time */
  readonly nextRetry: number | null;
  /** Whether maximum retries have been reached */
  readonly maxRetriesReached: boolean;
  /** Total retry duration in milliseconds */
  readonly totalDuration: number;
  /** Success rate of previous attempts */
  readonly successRate?: number;
}
</file>

<file path="src/types/core/errors.ts">
/**
 * Custom error types for Harmony Hub integration
 * @module
 */
/**
 * Categories of errors that can occur
 */
export enum ErrorCategory {
  /** Network or connection errors */
  CONNECTION = "CONNECTION",
  /** Hub communication errors */
  HUB_COMMUNICATION = "HUB_COMMUNICATION",
  /** Command execution errors */
  COMMAND_EXECUTION = "COMMAND_EXECUTION",
  /** Activity start errors */
  ACTIVITY_START = "ACTIVITY_START",
  /** Activity stop errors */
  ACTIVITY_STOP = "ACTIVITY_STOP",
  /** Cache-related errors */
  CACHE = "CACHE",
  /** Storage-related errors */
  STORAGE = "STORAGE",
  /** State validation errors */
  STATE = "STATE",
  /** Data validation errors */
  VALIDATION = "VALIDATION",
  /** Discovery errors */
  DISCOVERY = "DISCOVERY",
  /** Unknown errors */
  UNKNOWN = "UNKNOWN",
}
/**
 * Severity levels for errors
 */
export enum ErrorSeverity {
  /** Warning level - operation can continue */
  WARNING = "WARNING",
  /** Error level - operation cannot continue */
  ERROR = "ERROR",
  /** Fatal level - application cannot continue */
  FATAL = "FATAL",
}
/**
 * Context for retryable operations
 */
export interface RetryContext {
  /** Number of attempts made */
  readonly attempts: number;
  /** Maximum number of attempts allowed */
  readonly maxAttempts: number;
  /** Timestamp of the last attempt */
  readonly lastAttemptTimestamp: number;
  /** Delay between attempts in milliseconds */
  readonly delayMs: number;
}
/**
 * Strategy for recovering from errors
 */
export interface ErrorRecoveryStrategy {
  /** Name of the recovery strategy */
  readonly name: string;
  /** Description of what the strategy does */
  readonly description: string;
  /** Whether the strategy can be automated */
  readonly isAutomatic: boolean;
  /** Steps to perform for recovery */
  readonly steps: string[];
}
/**
 * Details that can be included with errors
 */
export interface ErrorDetails {
  /** Type of the invalid value */
  type?: string;
  /** Minimum allowed value */
  min?: number;
  /** Maximum allowed value */
  max?: number;
  /** List of allowed values */
  allowedValues?: readonly string[];
  /** Additional context */
  [key: string]: unknown;
}
/**
 * Custom error class for Harmony Hub operations
 * Provides detailed error information and categorization
 */
export class HarmonyError extends Error {
  /** The category of the error */
  readonly category: ErrorCategory;
  /** Error severity level */
  readonly severity: ErrorSeverity;
  /** The original error that caused this error, if any */
  readonly cause?: Error;
  /** Retry context if applicable */
  readonly retryContext?: RetryContext;
  /** Whether the error is retryable */
  readonly isRetryable: boolean;
  /** Error code if any */
  readonly code?: string;
  /** Additional error details */
  readonly details?: ErrorDetails;
  /** Recovery strategies */
  readonly recoveryStrategies?: ErrorRecoveryStrategy[];
  /** Timestamp when error occurred */
  readonly timestamp: number;
  /**
   * Creates a new HarmonyError instance
   * @param message - User-friendly error message
   * @param category - Category of the error
   * @param cause - Original error that caused this error
   * @param retryContext - Context for retryable operations
   * @param isRetryable - Whether the operation can be retried
   * @param code - Error code for specific error types
   * @param details - Additional error details
   * @param severity - Severity level of the error
   * @param recoveryStrategies - Strategies for recovering from the error
   */
  constructor(
    message: string,
    category: ErrorCategory,
    cause?: Error,
    retryContext?: RetryContext,
    isRetryable = true,
    code?: string,
    details?: ErrorDetails,
    severity: ErrorSeverity = ErrorSeverity.ERROR,
    recoveryStrategies?: ErrorRecoveryStrategy[],
  ) {
    super(message);
    this.name = "HarmonyError";
    this.category = category;
    this.severity = severity;
    this.cause = cause;
    this.retryContext = retryContext;
    this.isRetryable = isRetryable;
    this.code = code;
    this.details = details;
    this.recoveryStrategies = recoveryStrategies;
    this.timestamp = Date.now();
    // Maintains proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, HarmonyError);
    }
  }
  /**
   * Gets a user-friendly error message suitable for display
   * @returns User-friendly error message with severity prefix
   */
  getUserMessage(): string {
    const prefix = this.severity === ErrorSeverity.WARNING ? "Warning" : "Error";
    return `${prefix}: ${this.message}`;
  }
  /**
   * Gets a detailed error message including all error information
   * Useful for logging and debugging
   * @returns Detailed multi-line error message
   */
  getDetailedMessage(): string {
    const details: string[] = [
      `Error: ${this.message}`,
      `Category: ${this.category}`,
      `Severity: ${this.severity}`,
      `Timestamp: ${new Date(this.timestamp).toISOString()}`,
      `Retryable: ${this.isRetryable}`,
    ];
    if (this.code) {
      details.push(`Code: ${this.code}`);
    }
    if (this.retryContext) {
      details.push(
        `Retry Attempts: ${this.retryContext.attempts}/${this.retryContext.maxAttempts}`,
        `Last Attempt: ${new Date(this.retryContext.lastAttemptTimestamp).toISOString()}`,
      );
    }
    if (this.cause) {
      details.push(`Cause: ${this.cause.message}`);
      if (this.cause.stack) {
        details.push(`Stack: ${this.cause.stack}`);
      }
    }
    if (this.details) {
      details.push(`Additional Details: ${JSON.stringify(this.details, null, 2)}`);
    }
    return details.join("\n");
  }
}
</file>

<file path="src/types/core/harmony.ts">
/**
 * Core type definitions for Harmony Hub integration
 * @module
 */
import { ErrorCategory } from "./errors";
import { Logger } from "../../services/logger";
/**
 * Represents a Logitech Harmony Hub device on the network
 * @interface HarmonyHub
 */
export interface HarmonyHub {
  /** Unique identifier for the hub */
  readonly id: string;
  /** User-friendly name of the hub */
  readonly name: string;
  /** IP address of the hub on the local network */
  readonly ip: string;
  /** Remote ID assigned by Harmony service */
  readonly remoteId: string;
  /** Hub ID from Logitech service */
  readonly hubId: string;
  /** Version of the hub firmware */
  readonly version: string;
  /** Port number for hub communication */
  readonly port: string;
  /** Product ID of the hub */
  readonly productId: string;
  /** Protocol versions supported by the hub */
  readonly protocolVersion: string;
}
/**
 * Represents a device that can be controlled by the Harmony Hub
 * @interface HarmonyDevice
 */
export interface HarmonyDevice {
  /** Unique identifier for the device */
  readonly id: string;
  /** User-friendly name of the device */
  readonly name: string;
  /** Type of device (e.g., TV, Receiver, etc.) */
  readonly type: string;
  /** Available commands for this device */
  readonly commands: readonly HarmonyCommand[];
}
/**
 * Represents a command that can be sent to a device
 * @interface HarmonyCommand
 */
export interface HarmonyCommand {
  /** Unique identifier for the command */
  readonly id: string;
  /** Internal name of the command */
  readonly name: string;
  /** User-friendly label for display */
  readonly label: string;
  /** ID of the device this command belongs to */
  readonly deviceId: string;
  /** Command group for categorization (e.g., "IRCommand", "PowerToggle", etc.) */
  readonly group?: string;
}
/**
 * Represents an activity configured on the Harmony Hub
 * @interface HarmonyActivity
 */
export interface HarmonyActivity {
  /** Unique identifier for the activity */
  readonly id: string;
  /** User-friendly name of the activity */
  readonly name: string;
  /** Type of activity (e.g., "WatchTV", "ListenToMusic", etc.) */
  readonly type: string;
  /** Whether this is the currently running activity */
  readonly isCurrent: boolean;
}
/**
 * Represents the stage of the Harmony Hub connection process
 * @enum {string}
 */
export enum HarmonyStage {
  /** Initial state before any connection attempt */
  INITIAL = "initial",
  /** Actively discovering hubs on the network */
  DISCOVERING = "discovering",
  /** Establishing connection to a specific hub */
  CONNECTING = "connecting",
  /** Loading device information from the hub */
  LOADING_DEVICES = "loading_devices",
  /** Loading activity information from the hub */
  LOADING_ACTIVITIES = "loading_activities",
  /** Starting a new activity */
  STARTING_ACTIVITY = "starting_activity",
  /** Stopping the current activity */
  STOPPING_ACTIVITY = "stopping_activity",
  /** Executing a device command */
  EXECUTING_COMMAND = "executing_command",
  /** Refreshing hub state */
  REFRESHING = "refreshing",
  /** Successfully connected and ready */
  CONNECTED = "connected",
  /** Error state */
  ERROR = "error",
}
/**
 * Recovery actions available for different error types
 * @enum {string}
 */
export enum ErrorRecoveryAction {
  /** Retry the failed operation */
  RETRY = "retry",
  /** Reconnect to the hub */
  RECONNECT = "reconnect",
  /** Clear local cache */
  CLEAR_CACHE = "clear_cache",
  /** Reset configuration */
  RESET_CONFIG = "reset_config",
  /** Restart the hub */
  RESTART = "restart",
  /** Manual intervention required */
  MANUAL = "manual",
}
/**
 * Represents the loading state during operations
 * @interface LoadingState
 */
export interface LoadingState {
  /** Current stage of the process */
  readonly stage: HarmonyStage;
  /** Progress from 0 to 1 */
  readonly progress: number;
  /** User-friendly message about the current state */
  readonly message: string;
}
/**
 * Configuration for operation timeouts
 */
export interface TimeoutConfig {
  /** Timeout for network operations in milliseconds */
  connection: number;
  /** Timeout for message operations in milliseconds */
  message: number;
  /** Timeout for activity operations in milliseconds */
  activity: number;
  /** Timeout for command operations in milliseconds */
  command: number;
  /** Timeout for discovery operations in milliseconds */
  discovery: number;
  /** Timeout for cache operations in milliseconds */
  cache: number;
}
/**
 * Type guard to check if an object is a HarmonyHub.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyHub
 */
export function isHarmonyHub(obj: unknown): obj is HarmonyHub {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyHub validation failed", { 
      reason: "Not an object",
      received: typeof obj,
      value: obj 
    });
    return false;
  }
  const hub = obj as Partial<HarmonyHub>;
  const validations = [
    { field: "id", valid: typeof hub.id === "string" && hub.id.length > 0, value: hub.id },
    { field: "name", valid: typeof hub.name === "string" && hub.name.length > 0, value: hub.name },
    { field: "ip", valid: typeof hub.ip === "string" && hub.ip.length > 0, value: hub.ip },
    { field: "hubId", valid: typeof hub.hubId === "string" && hub.hubId.length > 0, value: hub.hubId },
    { field: "remoteId", valid: typeof hub.remoteId === "string", value: hub.remoteId },
    { field: "version", valid: typeof hub.version === "string", value: hub.version },
    { field: "port", valid: typeof hub.port === "string", value: hub.port },
    { field: "productId", valid: typeof hub.productId === "string", value: hub.productId },
    { field: "protocolVersion", valid: typeof hub.protocolVersion === "string", value: hub.protocolVersion }
  ];
  const failures = validations.filter(v => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyHub validation failed", {
      failures: failures.map(f => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value
      }))
    });
    return false;
  }
  return true;
}
/**
 * Type guard to check if an object is a HarmonyDevice.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyDevice
 */
export function isHarmonyDevice(obj: unknown): obj is HarmonyDevice {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyDevice validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj
    });
    return false;
  }
  const device = obj as Partial<HarmonyDevice>;
  const validations = [
    { field: "id", valid: typeof device.id === "string" && device.id.length > 0, value: device.id },
    { field: "name", valid: typeof device.name === "string" && device.name.length > 0, value: device.name },
    { field: "type", valid: typeof device.type === "string" && device.type.length > 0, value: device.type },
    { field: "commands", valid: Array.isArray(device.commands), value: device.commands }
  ];
  const failures = validations.filter(v => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyDevice validation failed", {
      failures: failures.map(f => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value
      }))
    });
    return false;
  }
  // Validate each command
  if (device.commands) {
    const invalidCommands = device.commands.map((cmd, index) => ({
      index,
      command: cmd,
      valid: isHarmonyCommand(cmd)
    })).filter(result => !result.valid);
    if (invalidCommands.length > 0) {
      Logger.debug("isHarmonyDevice validation failed", {
        reason: "Invalid commands",
        invalidCommands: invalidCommands.map(ic => ({
          index: ic.index,
          command: ic.command
        }))
      });
      return false;
    }
  }
  return true;
}
/**
 * Type guard to check if an object is a HarmonyCommand.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyCommand
 */
export function isHarmonyCommand(obj: unknown): obj is HarmonyCommand {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyCommand validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj
    });
    return false;
  }
  const command = obj as Partial<HarmonyCommand>;
  const validations = [
    { field: "id", valid: typeof command.id === "string" && command.id.length > 0, value: command.id },
    { field: "name", valid: typeof command.name === "string" && command.name.length > 0, value: command.name },
    { field: "label", valid: typeof command.label === "string" && command.label.length > 0, value: command.label },
    { field: "deviceId", valid: typeof command.deviceId === "string" && command.deviceId.length > 0, value: command.deviceId }
  ];
  const failures = validations.filter(v => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyCommand validation failed", {
      failures: failures.map(f => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value
      }))
    });
    return false;
  }
  // Optional group validation
  if (command.group !== undefined && typeof command.group !== "string") {
    Logger.debug("isHarmonyCommand validation failed", {
      reason: "Invalid group type",
      receivedType: typeof command.group,
      receivedValue: command.group
    });
    return false;
  }
  return true;
}
/**
 * Type guard to check if an object is a HarmonyActivity.
 * Performs detailed validation of all required properties.
 * @param obj The object to check
 * @returns True if the object is a HarmonyActivity
 */
export function isHarmonyActivity(obj: unknown): obj is HarmonyActivity {
  if (typeof obj !== "object" || obj === null) {
    Logger.debug("isHarmonyActivity validation failed", {
      reason: "Not an object",
      received: typeof obj,
      value: obj
    });
    return false;
  }
  const activity = obj as Partial<HarmonyActivity>;
  const validations = [
    { field: "id", valid: typeof activity.id === "string" && activity.id.length > 0, value: activity.id },
    { field: "name", valid: typeof activity.name === "string" && activity.name.length > 0, value: activity.name },
    { field: "type", valid: typeof activity.type === "string" && activity.type.length > 0, value: activity.type },
    { field: "isCurrent", valid: typeof activity.isCurrent === "boolean", value: activity.isCurrent }
  ];
  const failures = validations.filter(v => !v.valid);
  if (failures.length > 0) {
    Logger.debug("isHarmonyActivity validation failed", {
      failures: failures.map(f => ({
        field: f.field,
        receivedType: typeof f.value,
        receivedValue: f.value
      }))
    });
    return false;
  }
  return true;
}
/**
 * Validation utility to ensure a HarmonyHub object is valid
 * @param hub The hub object to validate
 * @throws {Error} If the hub object is invalid
 */
export function validateHarmonyHub(hub: HarmonyHub): void {
  if (!isHarmonyHub(hub)) {
    throw new Error("Invalid HarmonyHub object");
  }
}
/**
 * Validation utility to ensure a HarmonyDevice object is valid
 * @param device The device object to validate
 * @throws {Error} If the device object is invalid
 */
export function validateHarmonyDevice(device: HarmonyDevice): void {
  if (!isHarmonyDevice(device)) {
    throw new Error("Invalid HarmonyDevice object");
  }
  device.commands.forEach(validateHarmonyCommand);
}
/**
 * Validation utility to ensure a HarmonyCommand object is valid
 * @param command The command object to validate
 * @throws {Error} If the command object is invalid
 */
export function validateHarmonyCommand(command: HarmonyCommand): void {
  if (!isHarmonyCommand(command)) {
    throw new Error("Invalid HarmonyCommand object");
  }
}
/**
 * Validation utility to ensure a HarmonyActivity object is valid
 * @param activity The activity object to validate
 * @throws {Error} If the activity object is invalid
 */
export function validateHarmonyActivity(activity: HarmonyActivity): void {
  if (!isHarmonyActivity(activity)) {
    throw new Error("Invalid HarmonyActivity object");
  }
}
/**
 * Current state of the Harmony Hub system
 * @interface HarmonyState
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Current error if any */
  readonly error: Error | null;
  /** Current loading state */
  readonly loadingState: LoadingState;
}
/**
 * WebSocket message format from Harmony Hub
 * @interface HarmonyMessage
 */
export interface HarmonyMessage {
  /** Message type */
  readonly type: string;
  /** Message data */
  readonly data?: {
    /** Message ID */
    readonly id?: string;
    /** Message status */
    readonly status?: string;
    /** Error code if any */
    readonly errorCode?: string;
    /** Error message if any */
    readonly errorMessage?: string;
    /** Additional data fields */
    readonly [key: string]: unknown;
  };
}
/**
 * Message handler type
 */
export type MessageHandler = (message: HarmonyMessage) => void;
/**
 * Hub discovery handler type
 */
export type HubDiscoveryHandler = (hub: HarmonyHub) => void;
/** Re-export ErrorCategory for backwards compatibility */
export { ErrorCategory } from "./errors";
</file>

<file path="src/types/core/index.ts">
/**
 * Core types and utilities for Harmony Hub integration
 * @module
 */
// Base types
export * from "./harmony";
export * from "./errors";
export * from "./validation";
export * from "./command";
export * from "./logging";
export * from "./websocket";
export * from "./state";
// Re-export commonly used types for convenience
export type {
  // Harmony types
  HarmonyHub,
  HarmonyDevice,
  HarmonyCommand,
  HarmonyActivity,
  LoadingState,
} from "./harmony";
// Re-export commonly used enums
export {
  // Harmony enums
  HarmonyStage,
  ErrorCategory,
} from "./harmony";
// Re-export error types
export { HarmonyError, isHarmonyError, wrapError } from "./errors";
// Re-export validation functions
export { validateHub, validateDevice, validateCommand, validateActivity, validateLoadingState } from "./validation";
// Re-export command types
export type {
  CommandQueueConfig,
  CommandRequest,
  CommandResult,
  RetryConfig,
  TimeoutConfig,
  RetryContext,
} from "./command";
export { CommandStatus, ErrorRecoveryAction } from "./command";
// Re-export logging types
export type { LoggerOptions, LogEntry, ILogger, LogFilter, LogFormatter } from "./logging";
export { LogLevel, ErrorSeverity } from "./logging";
// Re-export WebSocket types
export type {
  WebSocketMessage,
  CommandPayload,
  ActivityPayload,
  WebSocketMessageUnion,
  WebSocketResponse,
  ActivitiesResponse,
  DevicesResponse,
  WebSocketEventHandler,
  WebSocketErrorHandler,
  QueuedMessage,
} from "./websocket";
export { WebSocketConnectionStatus, WebSocketMessageType } from "./websocket";
// Re-export state types
export type {
  MachineContext,
  DiscoverEvent,
  SelectHubEvent,
  RefreshEvent,
  RetryEvent,
  ClearEvent,
  DisconnectEvent,
  ErrorEvent,
  DoneDiscoverEvent,
  DoneLoadHubEvent,
  MachineEvent,
  MachineServices,
  HarmonyState,
} from "./state";
export { MachineState } from "./state";
</file>

<file path="src/types/core/logging.ts">
/**
 * Logging type definitions for Harmony Hub integration
 * @module
 */
/**
 * Log levels for application logging
 * @enum {number}
 */
export enum LogLevel {
  /** Debug level for detailed troubleshooting */
  DEBUG = 0,
  /** Info level for general operational messages */
  INFO = 1,
  /** Warning level for potentially problematic situations */
  WARN = 2,
  /** Error level for error conditions */
  ERROR = 3,
}
/**
 * Error severity levels
 * @enum {string}
 */
export enum ErrorSeverity {
  /** Informational messages that don't affect functionality */
  INFO = "info",
  /** Minor issues that don't affect core functionality */
  WARNING = "warning",
  /** Serious issues that affect core functionality */
  ERROR = "error",
  /** Critical issues that prevent the extension from working */
  CRITICAL = "critical",
}
/**
 * Interface for logger configuration options
 * @interface LoggerOptions
 */
export interface LoggerOptions {
  /** Minimum log level to record */
  minLevel?: LogLevel;
  /** Maximum number of log entries to keep in memory */
  maxEntries?: number;
  /** Whether to include timestamps in log entries */
  includeTimestamp?: boolean;
  /** Whether to include log level in entries */
  includeLevel?: boolean;
}
/**
 * Structure of a log entry
 * @interface LogEntry
 */
export interface LogEntry {
  /** ISO timestamp of when the entry was created */
  readonly timestamp: string;
  /** Log level of the entry */
  readonly level: LogLevel;
  /** Log message */
  readonly message: string;
  /** Optional additional data */
  readonly data?: unknown;
}
/**
 * Interface for logger implementations
 * @interface ILogger
 */
export interface ILogger {
  /**
   * Log a debug message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  debug(message: string, data?: unknown): void;
  /**
   * Log an info message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  info(message: string, data?: unknown): void;
  /**
   * Log a warning message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  warn(message: string, data?: unknown): void;
  /**
   * Log an error message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  error(message: string, data?: unknown): void;
  /**
   * Log an error with full stack trace
   * @param error - Error to log
   * @param context - Optional context information
   */
  logError(error: Error, context?: string): void;
  /**
   * Get log history
   * @returns Array of log entries
   */
  getHistory(): LogEntry[];
  /**
   * Clear log history
   */
  clearHistory(): void;
  /**
   * Set minimum log level
   * @param level - New minimum log level
   */
  setMinLevel(level: LogLevel): void;
}
/**
 * Type for log entry filter functions
 * @type {LogFilter}
 */
export type LogFilter = (entry: LogEntry) => boolean;
/**
 * Type for log entry formatter functions
 * @type {LogFormatter}
 */
export type LogFormatter = (entry: LogEntry) => string;
</file>

<file path="src/types/core/state-mutable.ts">
/**
 * Mutable state types for use with Immer
 * @module
 */
import type { HarmonyHub, HarmonyDevice, HarmonyActivity, HarmonyCommand, LoadingState } from "./harmony";
/**
 * Mutable version of HarmonyHub
 */
export interface MutableHarmonyHub {
  id: string;
  name: string;
  ip: string;
  remoteId?: string;
  hubId?: string;
  version?: string;
  port?: string;
  productId?: string;
  protocolVersion?: string;
}
/**
 * Mutable version of HarmonyCommand
 */
export interface MutableHarmonyCommand {
  id: string;
  name: string;
  label: string;
  deviceId: string;
  group?: string;
}
/**
 * Mutable version of HarmonyDevice
 */
export interface MutableHarmonyDevice {
  id: string;
  name: string;
  type: string;
  commands: MutableHarmonyCommand[];
}
/**
 * Mutable version of HarmonyActivity
 */
export interface MutableHarmonyActivity {
  id: string;
  name: string;
  type: string;
  isCurrent: boolean;
}
/**
 * Mutable version of LoadingState
 */
export interface MutableLoadingState {
  stage: string;
  progress: number;
  message: string;
}
/**
 * Mutable version of HarmonyState
 */
export interface MutableHarmonyState {
  hubs: MutableHarmonyHub[];
  selectedHub: MutableHarmonyHub | null;
  devices: MutableHarmonyDevice[];
  activities: MutableHarmonyActivity[];
  currentActivity: MutableHarmonyActivity | null;
  error: Error | null;
  loadingState: MutableLoadingState;
}
/**
 * Convert a readonly HarmonyHub to a mutable one
 */
export function toMutableHub(hub: HarmonyHub): MutableHarmonyHub {
  return {
    id: hub.id,
    name: hub.name,
    ip: hub.ip,
    remoteId: hub.remoteId,
    hubId: hub.hubId,
    version: hub.version,
    port: hub.port,
    productId: hub.productId,
    protocolVersion: hub.protocolVersion,
  };
}
/**
 * Convert a readonly HarmonyCommand to a mutable one
 */
export function toMutableCommand(command: HarmonyCommand): MutableHarmonyCommand {
  return {
    id: command.id,
    name: command.name,
    label: command.label,
    deviceId: command.deviceId,
    group: command.group,
  };
}
/**
 * Convert a readonly HarmonyDevice to a mutable one
 */
export function toMutableDevice(device: HarmonyDevice): MutableHarmonyDevice {
  return {
    id: device.id,
    name: device.name,
    type: device.type,
    commands: device.commands.map(toMutableCommand),
  };
}
/**
 * Convert a readonly HarmonyActivity to a mutable one
 */
export function toMutableActivity(activity: HarmonyActivity): MutableHarmonyActivity {
  return {
    id: activity.id,
    name: activity.name,
    type: activity.type,
    isCurrent: activity.isCurrent,
  };
}
/**
 * Convert a readonly LoadingState to a mutable one
 */
export function toMutableLoadingState(state: LoadingState): MutableLoadingState {
  return {
    stage: state.stage,
    progress: state.progress,
    message: state.message,
  };
}
</file>

<file path="src/types/core/state.ts">
/**
 * State-related type definitions for Harmony Hub integration
 * @module
 */
import type { HarmonyError } from "./errors";
import type { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import type { LoadingState } from "./harmony";
/**
 * State machine states for Harmony Hub control
 * @enum {string}
 */
export enum MachineState {
  /** Initial state */
  IDLE = "IDLE",
  /** Discovering available hubs */
  DISCOVERING = "DISCOVERING",
  /** Connecting to a hub */
  CONNECTING = "CONNECTING",
  /** Connected to a hub */
  CONNECTED = "CONNECTED",
  /** Error state */
  ERROR = "ERROR",
}
/**
 * Context data for Harmony state machine
 * @interface MachineContext
 */
export interface MachineContext {
  /** List of available hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices on the hub */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities on the hub */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Error state if any */
  readonly error: HarmonyError | null;
}
/**
 * Event payload for hub discovery
 * @interface DiscoverEvent
 */
export interface DiscoverEvent {
  readonly type: "DISCOVER";
}
/**
 * Event payload for hub selection
 * @interface SelectHubEvent
 */
export interface SelectHubEvent {
  readonly type: "SELECT_HUB";
  /** Hub to select */
  readonly hub: HarmonyHub;
}
/**
 * Event payload for state refresh
 * @interface RefreshEvent
 */
export interface RefreshEvent {
  readonly type: "REFRESH";
}
/**
 * Event payload for retrying a failed action
 * @interface RetryEvent
 */
export interface RetryEvent {
  readonly type: "RETRY";
}
/**
 * Event payload for clearing the state
 * @interface ClearEvent
 */
export interface ClearEvent {
  readonly type: "CLEAR";
}
/**
 * Event payload for hub disconnection
 * @interface DisconnectEvent
 */
export interface DisconnectEvent {
  readonly type: "DISCONNECT";
}
/**
 * Event payload for error state
 * @interface ErrorEvent
 */
export interface ErrorEvent {
  readonly type: "error.platform";
  /** Error that occurred */
  readonly data: HarmonyError;
}
/**
 * Event payload for done discovering hubs
 * @interface DoneDiscoverEvent
 */
export interface DoneDiscoverEvent {
  readonly type: "done.invoke.discoverHubs";
  /** List of discovered hubs */
  readonly data: {
    readonly hubs: readonly HarmonyHub[];
  };
}
/**
 * Event payload for done loading hub data
 * @interface DoneLoadHubEvent
 */
export interface DoneLoadHubEvent {
  readonly type: "done.invoke.loadHubData";
  /** Loaded hub data */
  readonly data: {
    readonly devices: readonly HarmonyDevice[];
    readonly activities: readonly HarmonyActivity[];
  };
}
/**
 * Union type of all possible state machine events
 * @type {MachineEvent}
 */
export type MachineEvent =
  | DiscoverEvent
  | SelectHubEvent
  | DisconnectEvent
  | RefreshEvent
  | RetryEvent
  | ClearEvent
  | ErrorEvent
  | DoneDiscoverEvent
  | DoneLoadHubEvent;
/**
 * Service types for XState
 * @interface MachineServices
 */
export interface MachineServices {
  readonly discoverHubs: {
    readonly data: { readonly hubs: readonly HarmonyHub[] };
  };
  readonly loadHubData: {
    readonly data: {
      readonly devices: readonly HarmonyDevice[];
      readonly activities: readonly HarmonyActivity[];
    };
  };
}
/**
 * Core state for Harmony operations
 * @interface HarmonyState
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Current error if any */
  readonly error: Error | null;
  /** Current loading state */
  readonly loadingState: LoadingState;
}
</file>

<file path="src/types/core/validation.ts">
/**
 * Validation utilities for Harmony Hub types
 * @module
 */
import { HarmonyError, ErrorSeverity } from "./errors";
import { ErrorCategory } from "./harmony";
import type { HarmonyHub, HarmonyDevice, HarmonyCommand, HarmonyActivity, LoadingState } from "./harmony";
/**
 * Validates a string field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @throws {HarmonyError} If the value is invalid
 */
function validateString(value: unknown, fieldName: string): void {
  if (typeof value !== "string" || value.trim().length === 0) {
    throw new HarmonyError(`Invalid ${fieldName}: must be a non-empty string`, ErrorCategory.DATA);
  }
}
/**
 * Validates a number field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @throws {HarmonyError} If the value is invalid
 */
function validateNumber(value: unknown, fieldName: string): void {
  if (typeof value !== "number" || isNaN(value)) {
    throw new HarmonyError(`Invalid ${fieldName}: must be a number`, ErrorCategory.DATA);
  }
}
/**
 * Validates an array field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @param itemValidator Function to validate each item in the array
 * @throws {HarmonyError} If the value is invalid
 */
function validateArray(value: unknown, fieldName: string, itemValidator: (item: unknown) => void): void {
  if (!Array.isArray(value)) {
    throw new HarmonyError(`Invalid ${fieldName}: must be an array`, ErrorCategory.DATA);
  }
  value.forEach((item, index) => {
    try {
      itemValidator(item);
    } catch (error) {
      throw new HarmonyError(`Invalid item at index ${index} in ${fieldName}`, ErrorCategory.DATA);
    }
  });
}
/**
 * Validates a HarmonyHub object
 * @param hub The hub to validate
 * @throws {HarmonyError} If the hub is invalid
 */
export function validateHub(hub: unknown): asserts hub is HarmonyHub {
  if (!hub || typeof hub !== "object") {
    throw new HarmonyError("Invalid hub: must be an object", ErrorCategory.DATA);
  }
  validateString((hub as HarmonyHub).id, "hub.id");
  validateString((hub as HarmonyHub).name, "hub.name");
  validateString((hub as HarmonyHub).ip, "hub.ip");
}
/**
 * Validates a HarmonyCommand object
 * @param command The command to validate
 * @throws {HarmonyError} If the command is invalid
 */
export function validateCommand(command: unknown): asserts command is HarmonyCommand {
  if (!command || typeof command !== "object") {
    throw new HarmonyError("Invalid command: must be an object", ErrorCategory.DATA);
  }
  validateString((command as HarmonyCommand).id, "command.id");
  validateString((command as HarmonyCommand).name, "command.name");
  validateString((command as HarmonyCommand).label, "command.label");
  validateString((command as HarmonyCommand).deviceId, "command.deviceId");
}
/**
 * Validates a HarmonyDevice object
 * @param device The device to validate
 * @throws {HarmonyError} If the device is invalid
 */
export function validateDevice(device: unknown): asserts device is HarmonyDevice {
  if (!device || typeof device !== "object") {
    throw new HarmonyError("Invalid device: must be an object", ErrorCategory.DATA);
  }
  validateString((device as HarmonyDevice).id, "device.id");
  validateString((device as HarmonyDevice).name, "device.name");
  validateString((device as HarmonyDevice).type, "device.type");
  validateArray((device as HarmonyDevice).commands, "device.commands", validateCommand);
}
/**
 * Validates a HarmonyActivity object
 * @param activity The activity to validate
 * @throws {HarmonyError} If the activity is invalid
 */
export function validateActivity(activity: unknown): asserts activity is HarmonyActivity {
  if (!activity || typeof activity !== "object") {
    throw new HarmonyError("Invalid activity: must be an object", ErrorCategory.DATA);
  }
  validateString((activity as HarmonyActivity).id, "activity.id");
  validateString((activity as HarmonyActivity).name, "activity.name");
  validateString((activity as HarmonyActivity).type, "activity.type");
  if (typeof (activity as HarmonyActivity).isCurrent !== "boolean") {
    throw new HarmonyError("Invalid activity.isCurrent: must be a boolean", ErrorCategory.DATA);
  }
}
/**
 * Validates a LoadingState object
 * @param state The loading state to validate
 * @throws {HarmonyError} If the loading state is invalid
 */
export function validateLoadingState(state: unknown): asserts state is LoadingState {
  if (!state || typeof state !== "object") {
    throw new HarmonyError("Invalid loading state: must be an object", ErrorCategory.DATA);
  }
  validateString((state as LoadingState).stage, "loadingState.stage");
  validateNumber((state as LoadingState).progress, "loadingState.progress");
  validateString((state as LoadingState).message, "loadingState.message");
  const progress = (state as LoadingState).progress;
  if (progress < 0 || progress > 1) {
    throw new HarmonyError("Invalid loadingState.progress: must be between 0 and 1", ErrorCategory.DATA);
  }
}
export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}
export interface ValidationError {
  message: string;
  severity: ErrorSeverity;
}
export interface ValidationContext {
  errors: ValidationError[];
}
export interface Validator {
  validate(context: ValidationContext): void;
}
</file>

<file path="src/types/core/views.ts">
/**
 * View-related type definitions
 * @module
 */
import type { Draft } from "immer";
import type { HarmonyDevice, HarmonyActivity } from "./harmony";
/**
 * Available views in the application
 */
export enum View {
  HUBS = "hubs",
  DEVICES = "devices",
  ACTIVITIES = "activities",
  DEVICE_DETAIL = "device_detail",
  ACTIVITY_DETAIL = "activity_detail",
}
/**
 * View state for the application
 */
export interface ViewState {
  /** Current active view */
  readonly currentView: View;
  /** Selected device for detail view */
  readonly selectedDevice: HarmonyDevice | null;
  /** Selected activity for detail view */
  readonly selectedActivity: HarmonyActivity | null;
  /** Search query for current view */
  readonly searchQuery: string;
  /** Filter settings */
  readonly filters: ViewFilters;
}
/**
 * Mutable view state for Immer
 */
export interface MutableViewState {
  /** Current active view */
  currentView: View;
  /** Selected device for detail view */
  selectedDevice: Draft<HarmonyDevice> | null;
  /** Selected activity for detail view */
  selectedActivity: Draft<HarmonyActivity> | null;
  /** Search query for current view */
  searchQuery: string;
  /** Filter settings */
  filters: MutableViewFilters;
}
/**
 * Filter settings for views
 */
export interface ViewFilters {
  /** Device type filter */
  readonly deviceType?: string;
  /** Activity type filter */
  readonly activityType?: string;
  /** Show only favorite items */
  readonly showFavorites: boolean;
}
/**
 * Mutable filter settings for Immer
 */
export interface MutableViewFilters {
  /** Device type filter */
  deviceType?: string;
  /** Activity type filter */
  activityType?: string;
  /** Show only favorite items */
  showFavorites: boolean;
}
/**
 * View transition events
 */
export type ViewEvent =
  | { type: "VIEW_CHANGE"; view: View }
  | { type: "SELECT_DEVICE"; device: HarmonyDevice }
  | { type: "SELECT_ACTIVITY"; activity: HarmonyActivity }
  | { type: "CLEAR_SELECTION" }
  | { type: "SET_SEARCH"; query: string }
  | { type: "SET_FILTERS"; filters: Partial<ViewFilters> };
/**
 * View action handlers
 */
export interface ViewActions {
  /** Change the current view */
  changeView: (view: View) => void;
  /** Select a device for detail view */
  selectDevice: (device: HarmonyDevice) => void;
  /** Select an activity for detail view */
  selectActivity: (activity: HarmonyActivity) => void;
  /** Clear current selection */
  clearSelection: () => void;
  /** Update search query */
  setSearch: (query: string) => void;
  /** Update filter settings */
  setFilters: (filters: Partial<ViewFilters>) => void;
}
</file>

<file path="src/types/core/websocket.ts">
/**
 * WebSocket-related type definitions for Harmony Hub integration
 * @module
 */
import { HarmonyActivity, HarmonyDevice } from "./harmony";
/**
 * WebSocket connection status
 * @enum {string}
 */
export enum WebSocketConnectionStatus {
  /** The WebSocket connection is closed */
  DISCONNECTED = "disconnected",
  /** The WebSocket connection is being established */
  CONNECTING = "connecting",
  /** The WebSocket connection is established */
  CONNECTED = "connected",
}
/**
 * WebSocket message types for Harmony Hub communication
 * @enum {string}
 */
export enum WebSocketMessageType {
  /** Request to start an activity */
  START_ACTIVITY = "startActivity",
  /** Request to stop an activity */
  STOP_ACTIVITY = "stopActivity",
  /** Request to get activities */
  GET_ACTIVITIES = "getactivities",
  /** Request to get devices */
  GET_DEVICES = "getdevices",
  /** Request to execute a command */
  EXECUTE_COMMAND = "executecommand",
}
/**
 * Base interface for all WebSocket messages
 * @interface WebSocketMessage
 */
export interface WebSocketMessage<T = unknown> {
  /** Type of the message */
  readonly type: WebSocketMessageType;
  /** Payload of the message */
  readonly payload: T;
}
/**
 * Payload for command execution requests
 * @interface CommandPayload
 */
export interface CommandPayload {
  /** Device to send command to */
  readonly deviceId: string;
  /** Command to execute */
  readonly command: string;
}
/**
 * Payload for activity control requests
 * @interface ActivityPayload
 */
export interface ActivityPayload {
  /** Activity to control */
  readonly activityId: string;
  /** Optional timestamp */
  readonly timestamp?: number;
  /** Optional status */
  readonly status?: string;
}
/**
 * Union type of all possible WebSocket messages
 * @type {WebSocketMessageUnion}
 */
export type WebSocketMessageUnion =
  | WebSocketMessage<ActivityPayload>
  | WebSocketMessage<CommandPayload>
  | WebSocketMessage<Record<string, never>>;
/**
 * WebSocket response interface
 * @interface WebSocketResponse
 */
export interface WebSocketResponse<T> {
  /** Unique identifier for the response */
  readonly id: string;
  /** Status of the response */
  readonly status: "success" | "error";
  /** Optional response data */
  readonly data?: T;
  /** Optional error information */
  readonly error?: string;
}
/**
 * Activity response interface
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse extends WebSocketResponse<HarmonyActivity[]> {
  /** List of activities */
  readonly activities: Array<{
    /** Activity ID */
    readonly id: string;
    /** Activity name */
    readonly name: string;
    /** Activity type */
    readonly type: string;
    /** Whether this activity is currently active */
    readonly isCurrent: boolean;
  }>;
}
/**
 * Device response interface
 * @interface DevicesResponse
 */
export interface DevicesResponse extends WebSocketResponse<HarmonyDevice[]> {
  /** List of devices */
  readonly devices: Array<{
    /** Device ID */
    readonly id: string;
    /** Device name */
    readonly name: string;
    /** Device type */
    readonly type: string;
    /** Device commands */
    readonly commands: Array<{
      /** Command ID */
      readonly id: string;
      /** Command name */
      readonly name: string;
      /** Command label */
      readonly label: string;
      /** Command group */
      readonly group?: string;
    }>;
  }>;
}
/**
 * WebSocket event handler type
 * @type {WebSocketEventHandler}
 */
export type WebSocketEventHandler = (message: WebSocketMessageUnion) => void;
/**
 * WebSocket error handler type
 * @type {WebSocketErrorHandler}
 */
export type WebSocketErrorHandler = (error: Error) => void;
/**
 * Queued message interface
 * @interface QueuedMessage
 */
export interface QueuedMessage<T> {
  /** Unique identifier for the message */
  readonly id: string;
  /** Resolve function for the message */
  readonly resolve: (value: WebSocketResponse<T>) => void;
  /** Reject function for the message */
  readonly reject: (error: Error) => void;
  /** Timestamp for the message */
  readonly timestamp: number;
}
</file>

<file path="src/types/components.ts">
/**
 * React component Props types.
 * @module
 */
import { Icon } from "@raycast/api";
import { HarmonyError } from "./core/errors";
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./core/harmony";
/**
 * Props for components that display feedback states (loading, error, empty)
 * @interface FeedbackStateProps
 */
export interface FeedbackStateProps {
  /**
   * Title text to display
   */
  title: string;
  /**
   * Optional description or details
   */
  description?: string;
  /**
   * Icon to display with the feedback
   */
  icon?: Icon;
  /**
   * Optional color for styling
   */
  color?: string;
  /**
   * Optional actions that can be taken from this state
   */
  actions?: React.ReactNode;
}
/**
 * Props for HarmonyCommand component
 * @interface HarmonyCommandProps
 */
export interface HarmonyCommandProps {
  /**
   * Command title
   */
  title: string;
  /**
   * Command subtitle
   */
  subtitle?: string;
  /**
   * Command icon
   */
  icon?: Icon;
  /**
   * Action to execute when command is selected
   */
  onAction: () => void | Promise<void>;
  /**
   * Whether the command is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
}
/**
 * Props for the DeviceList component
 * @interface DeviceListProps
 */
export interface DeviceListProps {
  /**
   * List of devices to display
   */
  devices: HarmonyDevice[];
  /**
   * Currently selected device
   */
  selectedDevice?: HarmonyDevice;
  /**
   * Action to execute when a device is selected
   */
  onDeviceSelect: (device: HarmonyDevice) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for device types
   */
  deviceType?: string;
  /**
   * Optional filter for specific device IDs
   */
  deviceIds?: string[];
  /**
   * Optional custom render function for device items
   */
  renderItem?: (device: HarmonyDevice) => React.ReactNode;
}
/**
 * Props for the ActivityList component
 * @interface ActivityListProps
 */
export interface ActivityListProps {
  /**
   * List of activities to display
   */
  activities: HarmonyActivity[];
  /**
   * Currently active activity
   */
  currentActivity?: HarmonyActivity;
  /**
   * Action to execute when an activity is selected
   */
  onActivitySelect: (activity: HarmonyActivity) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for activity types
   */
  activityType?: string;
  /**
   * Optional filter for specific activity IDs
   */
  activityIds?: string[];
  /**
   * Optional custom render function for activity items
   */
  renderItem?: (activity: HarmonyActivity) => React.ReactNode;
}
/**
 * Props for the HarmonyContext provider
 * @interface HarmonyContextProps
 */
export interface HarmonyContextProps {
  /**
   * Connected Harmony Hub instance
   */
  hub: HarmonyHub | null;
  /**
   * List of available devices
   */
  devices: HarmonyDevice[];
  /**
   * List of available activities
   */
  activities: HarmonyActivity[];
  /**
   * Currently running activity
   */
  currentActivity: HarmonyActivity | null;
  /**
   * Loading state indicator
   */
  isLoading: boolean;
  /**
   * Error state if any
   */
  error: Error | null;
  /**
   * Function to refresh hub connection
   */
  refresh: () => Promise<void>;
  /**
   * Function to execute device command
   */
  executeCommand: (deviceId: string, command: string) => Promise<void>;
  /**
   * Function to start activity
   */
  startActivity: (activityId: string) => Promise<void>;
}
/**
 * Props for the ErrorBoundary component
 * @interface ErrorBoundaryProps
 */
export interface ErrorBoundaryProps {
  /**
   * Child components to wrap with error boundary
   */
  children: React.ReactNode;
  /**
   * Optional custom error renderer
   */
  renderError?: (error: Error) => React.ReactNode;
  /**
   * Optional error handler callback
   */
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}
/**
 * Props for the ErrorDisplay component
 * @interface ErrorDisplayProps
 */
export interface ErrorDisplayProps {
  /**
   * Error to display
   */
  error: HarmonyError;
  /**
   * Action to execute when retry is clicked
   */
  onRetry?: () => void;
  /**
   * Action to execute when dismiss is clicked
   */
  onDismiss?: () => void;
}
/**
 * Props for the HubSelector component
 * @interface HubSelectorProps
 */
export interface HubSelectorProps {
  /** List of available Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Callback when a hub is selected */
  onHubSelect: (hub: HarmonyHub) => void;
  /** Whether the component is in a loading state */
  isLoading?: boolean;
  /** Error state if any */
  error?: HarmonyError;
}
/**
 * Props for the LoadingIndicator component
 * @interface LoadingIndicatorProps
 */
export interface LoadingIndicatorProps {
  /**
   * Loading message to display
   */
  message?: string;
  /**
   * Progress percentage (0-100)
   */
  progress?: number;
}
</file>

<file path="src/types/logging.ts">
/**
 * Log levels for application logging
 * @enum {number}
 */
export enum LogLevel {
  /** Debug level for detailed troubleshooting */
  DEBUG = 0,
  /** Info level for general operational messages */
  INFO = 1,
  /** Warning level for potentially problematic situations */
  WARN = 2,
  /** Error level for error conditions */
  ERROR = 3,
}
/**
 * Interface for logger configuration options
 * @interface LoggerOptions
 */
export interface LoggerOptions {
  /** Minimum log level to record */
  minLevel?: LogLevel;
  /** Maximum number of log entries to keep in memory */
  maxEntries?: number;
  /** Whether to include timestamps in log entries */
  includeTimestamp?: boolean;
  /** Whether to include log level in entries */
  includeLevel?: boolean;
}
/**
 * Structure of a log entry
 * @interface LogEntry
 */
export interface LogEntry {
  /** ISO timestamp of when the entry was created */
  timestamp: string;
  /** Log level of the entry */
  level: LogLevel;
  /** Log message */
  message: string;
  /** Optional additional data */
  data?: unknown;
}
/**
 * Interface for logger implementations
 * @interface ILogger
 */
export interface ILogger {
  /**
   * Log a debug message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  debug(message: string, data?: unknown): void;
  /**
   * Log an info message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  info(message: string, data?: unknown): void;
  /**
   * Log a warning message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  warn(message: string, data?: unknown): void;
  /**
   * Log an error message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  error(message: string, data?: unknown): void;
  /**
   * Log an error with full stack trace
   * @param error - Error to log
   * @param context - Optional context information
   */
  logError(error: Error, context?: string): void;
  /**
   * Get log history
   */
  getHistory(): LogEntry[];
  /**
   * Clear log history
   */
  clearHistory(): void;
  /**
   * Set minimum log level
   */
  setMinLevel(level: LogLevel): void;
}
/**
 * Type for log entry filter functions
 * @type {LogFilter}
 */
export type LogFilter = (entry: LogEntry) => boolean;
/**
 * Type for log entry formatter functions
 * @type {LogFormatter}
 */
export type LogFormatter = (entry: LogEntry) => string;
</file>

<file path="src/types/preferences.ts">
/**
 * Preferences for the Harmony extension.
 */
export interface Preferences {
  /** The default view to display */
  defaultView: "activities" | "devices";
  /** The duration to hold a command in milliseconds */
  commandHoldTime: string;
  /** Whether to enable debug mode */
  debugMode: boolean;
  /** Whether to auto-retry failed commands */
  autoRetry: boolean;
  /** The maximum number of retries */
  maxRetries: string;
  /** The cache duration in seconds */
  cacheDuration: string;
  /** The network timeout in milliseconds */
  networkTimeout: string;
}
</file>

<file path="src/types/websocket.ts">
/**
 * WebSocket-related types for Harmony Hub communication.
 * @module
 */
import { HarmonyActivity, HarmonyDevice } from "./core/harmony";
/**
 * WebSocket connection status
 * @enum {string}
 */
export enum WebSocketConnectionStatus {
  /** The WebSocket connection is closed. */
  DISCONNECTED = "disconnected",
  /** The WebSocket connection is being established. */
  CONNECTING = "connecting",
  /** The WebSocket connection is established. */
  CONNECTED = "connected",
}
/**
 * WebSocket message types for Harmony Hub communication
 * @enum {string}
 */
export enum WebSocketMessageType {
  /** Request to start an activity */
  START_ACTIVITY = "startActivity",
  /** Request to stop an activity */
  STOP_ACTIVITY = "stopActivity",
  /** Request to get activities */
  GET_ACTIVITIES = "getactivities",
  /** Request to get devices */
  GET_DEVICES = "getdevices",
  /** Request to execute a command */
  EXECUTE_COMMAND = "executecommand",
}
/**
 * Base interface for all WebSocket messages
 * @interface WebSocketMessage
 */
export interface WebSocketMessage<T = unknown> {
  /** Type of the message */
  type: WebSocketMessageType;
  /** Payload of the message */
  payload: T;
}
/**
 * Payload for command execution requests
 * @interface CommandPayload
 */
export interface CommandPayload {
  /** Device to send command to */
  deviceId: string;
  /** Command to execute */
  command: string;
}
/**
 * Payload for activity control requests
 * @interface ActivityPayload
 */
export interface ActivityPayload {
  /** Activity to control */
  activityId: string;
  /** Optional timestamp */
  timestamp?: number;
  /** Optional status */
  status?: string;
}
/**
 * Union type of all possible WebSocket messages
 * @type {WebSocketMessageUnion}
 */
export type WebSocketMessageUnion =
  | WebSocketMessage<ActivityPayload>
  | WebSocketMessage<CommandPayload>
  | WebSocketMessage<Record<string, never>>;
/**
 * WebSocket response interface
 * @interface WebSocketResponse
 */
export interface WebSocketResponse<T> {
  /** Unique identifier for the response */
  id: string;
  /** Status of the response */
  status: "success" | "error";
  /** Optional response data */
  data?: T;
  /** Optional error information */
  error?: string;
}
/**
 * Activity response interface
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse extends WebSocketResponse<HarmonyActivity[]> {
  /** List of activities */
  activities: Array<{
    /** Activity ID */
    id: string;
    /** Activity name */
    name: string;
    /** Activity type */
    type: string;
    /** Whether this activity is currently active */
    isCurrent: boolean;
  }>;
}
/**
 * Device response interface
 * @interface DevicesResponse
 */
export interface DevicesResponse extends WebSocketResponse<HarmonyDevice[]> {
  /** List of devices */
  devices: Array<{
    /** Device ID */
    id: string;
    /** Device name */
    name: string;
    /** Device type */
    type: string;
    /** Device commands */
    commands: Array<{
      /** Command ID */
      id: string;
      /** Command name */
      name: string;
      /** Command label */
      label: string;
      /** Command group */
      group?: string;
    }>;
  }>;
}
/**
 * WebSocket event handler type
 * @type {WebSocketEventHandler}
 */
export type WebSocketEventHandler = (message: WebSocketMessageUnion) => void;
/**
 * WebSocket error handler type
 * @type {WebSocketErrorHandler}
 */
export type WebSocketErrorHandler = (error: Error) => void;
/**
 * Queued message interface
 * @interface QueuedMessage
 */
export interface QueuedMessage<T> {
  /** Unique identifier for the message */
  id: string;
  /** Resolve function for the message */
  resolve: (value: WebSocketResponse<T>) => void;
  /** Reject function for the message */
  reject: (error: Error) => void;
  /** Timestamp for the message */
  timestamp: number;
}
</file>

<file path="src/ui/components/actions/ActivityActionPanel.tsx">
import { ActionPanel, Action, Icon } from "@raycast/api";
import { memo } from "react";
interface ActivityActionPanelProps {
  isCurrentActivity: boolean;
  onStartActivity: () => void;
  onStopActivity: () => void;
  onRefresh?: () => void;
  onClearCache?: () => void;
  onBack?: () => void;
}
function ActivityActionPanelImpl({
  isCurrentActivity,
  onStartActivity,
  onStopActivity,
  onRefresh,
  onClearCache,
  onBack,
}: ActivityActionPanelProps): JSX.Element {
  return (
    <ActionPanel>
      <ActionPanel.Section>
        {!isCurrentActivity ? (
          <Action title="Start Activity" icon={Icon.Play} onAction={onStartActivity} />
        ) : (
          <Action title="Stop Activity" icon={Icon.Stop} onAction={onStopActivity} />
        )}
      </ActionPanel.Section>
      <ActionPanel.Section>
        {onRefresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={onRefresh} />}
        {onClearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={onClearCache} />}
        {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
      </ActionPanel.Section>
    </ActionPanel>
  );
}
export const ActivityActionPanel = memo(ActivityActionPanelImpl);
</file>

<file path="src/ui/components/actions/BaseActionPanel.tsx">
import { ActionPanel, Action, Icon } from "@raycast/api";
import { memo } from "react";
interface BaseActionPanelProps {
  onRefresh?: () => void;
  onClearCache?: () => void;
  onBack?: () => void;
}
function BaseActionPanelImpl({ onRefresh, onClearCache, onBack }: BaseActionPanelProps): JSX.Element {
  return (
    <ActionPanel>
      <ActionPanel.Section>
        {onRefresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={onRefresh} />}
        {onClearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={onClearCache} />}
        {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
      </ActionPanel.Section>
    </ActionPanel>
  );
}
export const BaseActionPanel = memo(BaseActionPanelImpl);
</file>

<file path="src/ui/components/actions/DeviceActionPanel.tsx">
import { ActionPanel, Action, Icon } from "@raycast/api";
import { memo } from "react";
import { HarmonyCommand } from "../../../types/core/harmony";
interface DeviceActionPanelProps {
  onExecuteCommand: (command: HarmonyCommand) => void;
  onRefresh?: () => void;
  onClearCache?: () => void;
  onBack?: () => void;
}
function DeviceActionPanelImpl({
  onExecuteCommand,
  onRefresh,
  onClearCache,
  onBack,
}: DeviceActionPanelProps): JSX.Element {
  return (
    <ActionPanel>
      <ActionPanel.Section>
        <Action title="Execute Command" icon={Icon.Terminal} onAction={() => onExecuteCommand} />
      </ActionPanel.Section>
      <ActionPanel.Section>
        {onRefresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={onRefresh} />}
        {onClearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={onClearCache} />}
        {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
      </ActionPanel.Section>
    </ActionPanel>
  );
}
export const DeviceActionPanel = memo(DeviceActionPanelImpl);
</file>

<file path="src/ui/components/views/ActivitiesView.tsx">
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo, useMemo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyActivity } from "../../../types/core/harmony";
interface ActivitiesViewProps {
  onActivitySelect: (activity: HarmonyActivity) => void;
  onBack?: () => void;
}
function ActivitiesViewImpl({ onActivitySelect, onBack }: ActivitiesViewProps): JSX.Element {
  const { activities, refresh, clearCache } = useHarmony();
  // Group activities by type
  const { activityTypes, activitiesByType } = useMemo(() => {
    const types = new Set<string>();
    const byType = new Map<string, HarmonyActivity[]>();
    activities.forEach((activity) => {
      types.add(activity.type);
      const typeActivities = byType.get(activity.type) || [];
      typeActivities.push(activity);
      byType.set(activity.type, typeActivities);
    });
    return {
      activityTypes: Array.from(types).sort(),
      activitiesByType: byType,
    };
  }, [activities]);
  return (
    <List
      navigationTitle="Activities"
      searchBarPlaceholder="Search activities..."
      isLoading={false}
      isShowingDetail={false}
    >
      {activityTypes.map((type) => {
        const typeActivities = activitiesByType.get(type) || [];
        return (
          <List.Section key={type} title={type}>
            {typeActivities.map((activity) => (
              <List.Item
                key={activity.id}
                title={activity.name}
                subtitle={activity.type}
                icon={activity.isCurrent ? Icon.Play : Icon.Stop}
                accessories={[
                  {
                    icon: activity.isCurrent ? Icon.CircleFilled : Icon.Circle,
                    tooltip: activity.isCurrent ? "Running" : "Stopped",
                  },
                ]}
                actions={
                  <ActionPanel>
                    <ActionPanel.Section>
                      <Action
                        title="Select Activity"
                        icon={Icon.ArrowRight}
                        onAction={() => onActivitySelect(activity)}
                      />
                    </ActionPanel.Section>
                    <ActionPanel.Section>
                      {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                      {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                      {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
                    </ActionPanel.Section>
                  </ActionPanel>
                }
              />
            ))}
          </List.Section>
        );
      })}
    </List>
  );
}
export const ActivitiesView = memo(ActivitiesViewImpl);
</file>

<file path="src/ui/components/views/CommandsView.tsx">
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyCommand } from "../../../types/core/harmony";
interface CommandsViewProps {
  commands: HarmonyCommand[];
  onExecuteCommand: (command: HarmonyCommand) => void;
  onBack?: () => void;
}
function CommandsViewImpl({ commands, onExecuteCommand, onBack }: CommandsViewProps): JSX.Element {
  const { refresh, clearCache } = useHarmony();
  return (
    <List
      navigationTitle="Commands"
      searchBarPlaceholder="Search commands..."
      isLoading={false}
      isShowingDetail={false}
    >
      {commands.map((command) => (
        <List.Item
          key={command.id}
          title={command.label}
          subtitle={command.name}
          icon={Icon.Terminal}
          actions={
            <ActionPanel>
              <ActionPanel.Section>
                <Action title="Execute Command" icon={Icon.Terminal} onAction={() => onExecuteCommand(command)} />
              </ActionPanel.Section>
              <ActionPanel.Section>
                {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
              </ActionPanel.Section>
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}
export const CommandsView = memo(CommandsViewImpl);
</file>

<file path="src/ui/components/views/DevicesView.tsx">
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo, useMemo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyDevice } from "../../../types/core/harmony";
interface DevicesViewProps {
  onDeviceSelect: (device: HarmonyDevice) => void;
  onBack?: () => void;
}
function DevicesViewImpl({ onDeviceSelect, onBack }: DevicesViewProps): JSX.Element {
  const { devices, refresh, clearCache } = useHarmony();
  // Group devices by type
  const { deviceTypes, devicesByType } = useMemo(() => {
    const types = new Set<string>();
    const byType = new Map<string, HarmonyDevice[]>();
    devices.forEach((device) => {
      types.add(device.type);
      const typeDevices = byType.get(device.type) || [];
      typeDevices.push(device);
      byType.set(device.type, typeDevices);
    });
    return {
      deviceTypes: Array.from(types).sort(),
      devicesByType: byType,
    };
  }, [devices]);
  return (
    <List navigationTitle="Devices" searchBarPlaceholder="Search devices..." isLoading={false} isShowingDetail={false}>
      {deviceTypes.map((type) => {
        const typeDevices = devicesByType.get(type) || [];
        return (
          <List.Section key={type} title={type}>
            {typeDevices.map((device) => (
              <List.Item
                key={device.id}
                title={device.name}
                subtitle={device.type}
                icon={Icon.Devices}
                accessories={[
                  {
                    text: `${device.commands.length} commands`,
                    tooltip: "Number of available commands",
                  },
                ]}
                actions={
                  <ActionPanel>
                    <ActionPanel.Section>
                      <Action title="Select Device" icon={Icon.ArrowRight} onAction={() => onDeviceSelect(device)} />
                    </ActionPanel.Section>
                    <ActionPanel.Section>
                      {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                      {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                      {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
                    </ActionPanel.Section>
                  </ActionPanel>
                }
              />
            ))}
          </List.Section>
        );
      })}
    </List>
  );
}
export const DevicesView = memo(DevicesViewImpl);
</file>

<file path="src/ui/components/views/HarmonyCommand.tsx">
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import React, { useEffect, useRef, useCallback } from "react";
import { memo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { Logger } from "../../../services/logger";
import { useViewStore } from "../../../stores/view";
import { HarmonyCommand as HarmonyCommandType, HarmonyDevice, HarmonyActivity } from "../../../types/core/harmony";
import { View } from "../../../types/core/views";
import { ActivitiesView } from "./ActivitiesView";
import { CommandsView } from "./CommandsView";
import { DevicesView } from "./DevicesView";
import { HubsView } from "./HubsView";
interface CommandItemProps {
  command: HarmonyCommandType;
  onExecute: () => void;
  onBack?: () => void;
}
function CommandItemImpl({ command, onExecute, onBack }: CommandItemProps): JSX.Element {
  return (
    <List.Item
      title={command.label}
      subtitle={command.name}
      icon={Icon.Terminal}
      actions={
        <ActionPanel>
          <ActionPanel.Section>
            <Action title="Execute Command" icon={Icon.Terminal} onAction={onExecute} />
          </ActionPanel.Section>
          {onBack && (
            <ActionPanel.Section>
              <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />
            </ActionPanel.Section>
          )}
        </ActionPanel>
      }
    />
  );
}
export const CommandItem = memo(CommandItemImpl);
export function HarmonyCommand(): React.ReactElement {
  const {
    hubs,
    selectedHub,
    devices,
    activities,
    currentActivity,
    loadingState,
    error,
    connect,
    refresh,
    executeCommand,
    startActivity,
  } = useHarmony();
  const currentView = useViewStore((state) => state.currentView);
  const selectedDevice = useViewStore((state) => state.selectedDevice);
  const isMounted = useRef(false);
  const viewStore = useViewStore();
  // Start hub discovery on mount
  useEffect(() => {
    if (!isMounted.current) {
      Logger.info("HarmonyCommand mounted, starting refresh");
      refresh();
      isMounted.current = true;
    }
  }, [refresh]);
  // Log state changes
  useEffect(() => {
    Logger.debug("State updated", {
      currentView,
      hubCount: hubs.length,
      selectedHub: selectedHub?.name,
      deviceCount: devices.length,
      activityCount: activities.length,
      loadingState: loadingState?.stage,
      hasError: !!error,
    });
  }, [currentView, hubs, selectedHub, devices, activities, loadingState, error]);
  // Handle view transitions based on state
  useEffect(() => {
    // If we have a selected hub but no devices are showing, switch to hubs view
    if (!selectedHub && currentView !== View.HUBS) {
      Logger.info("No hub selected, switching to hubs view");
      viewStore.changeView(View.HUBS);
      return;
    }
    // If we have a selected hub and devices, switch from hubs view
    if (selectedHub && devices.length > 0 && currentView === View.HUBS) {
      Logger.info("Hub selected with devices, switching from hubs view");
      viewStore.changeView(View.DEVICES); // The view store will handle the preference
    }
  }, [selectedHub, devices.length, currentView, viewStore]);
  // Handle device detail view transitions
  useEffect(() => {
    if (currentView === View.DEVICE_DETAIL && !selectedDevice) {
      Logger.info("No device selected, switching to devices view");
      viewStore.changeView(View.DEVICES);
    }
  }, [currentView, selectedDevice, viewStore]);
  // Handle device selection
  const handleDeviceSelect = useCallback(
    (device: HarmonyDevice) => {
      Logger.debug("Device selected", { device: device.name });
      viewStore.selectDevice(device);
    },
    [viewStore],
  );
  // Handle view rendering based on current view state
  Logger.debug("Rendering view", { currentView });
  switch (currentView) {
    case View.HUBS:
      Logger.info("Rendering HubsView", {
        hubCount: hubs.length,
        selectedHub: selectedHub?.name,
        loadingState: loadingState?.stage,
      });
      return <HubsView onHubSelect={connect} />;
    case View.DEVICES:
      Logger.info("Rendering DevicesView", {
        deviceCount: devices.length,
        loadingState: loadingState?.stage,
      });
      return <DevicesView onDeviceSelect={handleDeviceSelect} />;
    case View.DEVICE_DETAIL:
      if (!selectedDevice) {
        return <DevicesView onDeviceSelect={handleDeviceSelect} />;
      }
      Logger.info("Rendering CommandsView", {
        device: selectedDevice.name,
        commandCount: selectedDevice.commands.length,
      });
      return (
        <CommandsView
          commands={selectedDevice.commands}
          onExecuteCommand={executeCommand}
          onBack={() => viewStore.changeView(View.DEVICES)}
        />
      );
    case View.ACTIVITIES:
      Logger.info("Rendering ActivitiesView", {
        activityCount: activities.length,
        currentActivity: currentActivity?.name,
        loadingState: loadingState?.stage,
      });
      return <ActivitiesView onActivitySelect={(activity: HarmonyActivity) => startActivity(activity.id)} />;
    default:
      Logger.info("Rendering default HubsView", {
        hubCount: hubs.length,
        selectedHub: selectedHub?.name,
        loadingState: loadingState?.stage,
      });
      return <HubsView onHubSelect={connect} />;
  }
}
</file>

<file path="src/ui/components/views/HubsView.tsx">
import { List, Icon, Action, ActionPanel } from "@raycast/api";
import { memo } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { HarmonyHub } from "../../../types/core/harmony";
interface HubsViewProps {
  onHubSelect: (hub: HarmonyHub) => void;
  onBack?: () => void;
}
function HubsViewImpl({ onHubSelect, onBack }: HubsViewProps): JSX.Element {
  const { hubs, refresh, clearCache } = useHarmony();
  return (
    <List
      navigationTitle="Harmony Hubs"
      searchBarPlaceholder="Search hubs..."
      isLoading={false}
      isShowingDetail={false}
    >
      {hubs.map((hub) => (
        <List.Item
          key={hub.id}
          title={hub.name}
          subtitle={hub.ip}
          icon={Icon.Network}
          accessories={[
            {
              text: hub.version || "Unknown Version",
              tooltip: "Hub firmware version",
            },
          ]}
          actions={
            <ActionPanel>
              <ActionPanel.Section>
                <Action title="Select Hub" icon={Icon.ArrowRight} onAction={() => onHubSelect(hub)} />
              </ActionPanel.Section>
              <ActionPanel.Section>
                {refresh && <Action title="Refresh" icon={Icon.ArrowClockwise} onAction={refresh} />}
                {clearCache && <Action title="Clear Cache" icon={Icon.Trash} onAction={clearCache} />}
                {onBack && <Action title="Back" icon={Icon.ArrowLeft} onAction={onBack} />}
              </ActionPanel.Section>
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}
export const HubsView = memo(HubsViewImpl);
</file>

<file path="src/ui/components/FeedbackState.tsx">
import { ActionPanel, Action, Icon, Detail, Color } from "@raycast/api";
import { memo } from "react";
import { HarmonyError } from "../../types/core/errors";
import { ErrorCategory, ErrorRecoveryAction } from "../../types/core/harmony";
interface FeedbackStateProps {
  title: string;
  description?: string;
  icon?: Icon | { source: string };
  color?: string;
  error?: HarmonyError;
  onRetry?: () => void;
  onReconnect?: () => void;
  onClearCache?: () => void;
  onResetConfig?: () => void;
}
function getErrorIcon(category: ErrorCategory): Icon {
  switch (category) {
    case ErrorCategory.CONNECTION:
    case ErrorCategory.HUB_COMMUNICATION:
      return Icon.WifiDisabled;
    case ErrorCategory.DISCOVERY:
      return Icon.MagnifyingGlass;
    case ErrorCategory.COMMAND:
      return Icon.ExclamationMark;
    case ErrorCategory.STATE:
      return Icon.Warning;
    case ErrorCategory.DATA:
      return Icon.XMarkCircle;
    default:
      return Icon.ExclamationMark;
  }
}
function getRecoverySteps(error: HarmonyError): string[] {
  const steps: string[] = [];
  switch (error.category) {
    case ErrorCategory.CONNECTION:
    case ErrorCategory.HUB_COMMUNICATION:
      steps.push(
        "1. Check your network connection",
        "2. Verify the Harmony Hub is powered on",
        "3. Try reconnecting to the hub",
        "4. If issues persist, restart your hub",
      );
      break;
    case ErrorCategory.DISCOVERY:
      steps.push(
        "1. Ensure your hub is on the same network",
        "2. Check your firewall settings",
        "3. Try clearing the cache",
        "4. Attempt manual hub discovery",
      );
      break;
    case ErrorCategory.COMMAND:
      steps.push(
        "1. Wait a moment and try again",
        "2. Check if the device is powered on",
        "3. Verify the hub can control the device",
        "4. Try reconnecting to the hub",
      );
      break;
    case ErrorCategory.STATE:
      steps.push(
        "1. Try reconnecting to the hub",
        "2. Clear the local cache",
        "3. Reset the configuration",
        "4. If issues persist, restart the hub",
      );
      break;
    case ErrorCategory.DATA:
      steps.push(
        "1. Try refreshing the data",
        "2. Clear the local cache",
        "3. Reconnect to the hub",
        "4. Check hub connectivity",
      );
      break;
    default:
      steps.push(
        "1. Try the operation again",
        "2. Check hub connectivity",
        "3. Clear the local cache",
        "4. Contact support if issues persist",
      );
  }
  return steps;
}
function FeedbackStateImpl({
  title,
  description,
  icon,
  color,
  error,
  onRetry,
  onReconnect,
  onClearCache,
  onResetConfig,
}: FeedbackStateProps): JSX.Element {
  // If there's an error, show error-specific UI
  if (error) {
    const errorIcon = getErrorIcon(error.category);
    const recoverySteps = getRecoverySteps(error);
    const recoveryActions = error.getDefaultRecoveryStrategy()?.actions || [];
    return (
      <Detail
        markdown={`# ${title}\n\n${error.message}\n\n${
          recoverySteps.length > 0 ? "## Recovery Steps\n\n" + recoverySteps.join("\n\n") : ""
        }`}
        metadata={
          <Detail.Metadata>
            <Detail.Metadata.Label title="Category" text={error.category} icon={errorIcon} />
            <Detail.Metadata.Label title="Severity" text={error.severity} />
            {error.code && <Detail.Metadata.Label title="Code" text={error.code} />}
            {error.timestamp && (
              <Detail.Metadata.Label title="Time" text={new Date(error.timestamp).toLocaleTimeString()} />
            )}
          </Detail.Metadata>
        }
        actions={
          <ActionPanel>
            {recoveryActions.includes(ErrorRecoveryAction.RETRY) && onRetry && (
              <Action title="Retry" onAction={onRetry} icon={Icon.ArrowClockwise} />
            )}
            {recoveryActions.includes(ErrorRecoveryAction.RECONNECT) && onReconnect && (
              <Action title="Reconnect" onAction={onReconnect} icon={Icon.Link} />
            )}
            {recoveryActions.includes(ErrorRecoveryAction.CLEAR_CACHE) && onClearCache && (
              <Action title="Clear Cache" onAction={onClearCache} icon={Icon.Trash} />
            )}
            {recoveryActions.includes(ErrorRecoveryAction.RESET_CONFIG) && onResetConfig && (
              <Action title="Reset Configuration" onAction={onResetConfig} icon={Icon.Gear} />
            )}
          </ActionPanel>
        }
      />
    );
  }
  // Show standard feedback state
  return (
    <Detail
      markdown={`# ${title}${description ? `\n\n${description}` : ""}`}
      metadata={
        <Detail.Metadata>
          {icon && (
            <Detail.Metadata.TagList title="Status">
              <Detail.Metadata.TagList.Item text="" icon={icon} color={color as Color} />
            </Detail.Metadata.TagList>
          )}
        </Detail.Metadata>
      }
    />
  );
}
export const FeedbackState = memo(FeedbackStateImpl);
</file>

<file path="src/utils/state.ts">
/**
 * State conversion utilities
 * @module
 */
import type { Draft } from "immer";
import type { HarmonyDevice, HarmonyActivity } from "../types/core/harmony";
/**
 * Convert a readonly device to a mutable one for Immer
 */
export function toMutableDevice(device: HarmonyDevice): Draft<HarmonyDevice> {
  return device as Draft<HarmonyDevice>;
}
/**
 * Convert a readonly activity to a mutable one for Immer
 */
export function toMutableActivity(activity: HarmonyActivity): Draft<HarmonyActivity> {
  return activity as Draft<HarmonyActivity>;
}
/**
 * Convert a readonly array to a mutable one for Immer
 */
export function toMutableArray<T>(array: readonly T[]): Draft<T>[] {
  return array as Draft<T>[];
}
</file>

<file path="src/utils/validation.ts">
/**
 * Validation utilities for Harmony Hub types and data
 * @module
 */
import { Logger } from "../services/logger";
import { HarmonyError } from "../types/core/errors";
import { ErrorCategory } from "../types/core/harmony";
import { HarmonyHub, HarmonyDevice, HarmonyActivity, HarmonyCommand } from "../types/core/harmony";
/**
 * Type guard for checking if a value is a non-empty string
 * @param value - The value to check
 * @returns True if the value is a non-empty string, false otherwise
 */
export function isNonEmptyString(value: unknown): value is string {
  return typeof value === "string" && value.trim().length > 0;
}
/**
 * Type guard for checking if a value is a positive number
 * @param value - The value to check
 * @returns True if the value is a positive number, false otherwise
 */
export function isPositiveNumber(value: unknown): value is number {
  return typeof value === "number" && !isNaN(value) && value > 0;
}
/**
 * Type guard for checking if a value is a valid port number
 * @param value - The value to check
 * @returns True if the value is a valid port number (1-65535), false otherwise
 */
export function isValidPort(value: unknown): value is number {
  return isPositiveNumber(value) && value <= 65535;
}
/**
 * Type guard for checking if a value is a valid IPv4 address
 * @param value - The value to check
 * @returns True if the value is a valid IPv4 address, false otherwise
 */
export function isValidIpAddress(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipv4Regex.test(value)) return false;
  return value.split(".").every((num) => {
    const n = parseInt(num, 10);
    return n >= 0 && n <= 255;
  });
}
/**
 * Type guard for checking if a value is a valid command group
 * @param value - The value to check
 * @returns True if the value is a valid command group, false otherwise
 */
export function isValidCommandGroup(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const validGroups = ["IRCommand", "HTTPCommand", "BluetoothCommand", "WifiCommand"];
  return validGroups.includes(value);
}
/**
 * Validate Harmony Hub configuration
 * Throws an error if the hub configuration is invalid
 * @param hub - The hub configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub {
  if (!isNonEmptyString(hub.id)) {
    throw new HarmonyError(
      "Hub ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_ID",
    );
  }
  if (!isNonEmptyString(hub.name)) {
    throw new HarmonyError(
      "Hub name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_NAME",
    );
  }
  if (!isValidIpAddress(hub.ip)) {
    throw new HarmonyError(
      "Invalid hub IP address",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_IP",
    );
  }
  if (hub.port !== undefined && !isValidPort(hub.port)) {
    throw new HarmonyError(
      "Invalid hub port",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_PORT",
    );
  }
  Logger.debug("Hub config validation passed", { hub });
}
/**
 * Validate Harmony device configuration
 * Throws an error if the device configuration is invalid
 * @param device - The device configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice {
  if (!isNonEmptyString(device.id)) {
    throw new HarmonyError(
      "Device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_ID",
    );
  }
  if (!isNonEmptyString(device.name)) {
    throw new HarmonyError(
      "Device name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_NAME",
    );
  }
  if (!isNonEmptyString(device.type)) {
    throw new HarmonyError(
      "Device type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_TYPE",
    );
  }
  if (!Array.isArray(device.commands)) {
    throw new HarmonyError(
      "Device commands must be an array",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMANDS_ARRAY",
    );
  }
  device.commands.forEach((command, index) => {
    if (!isNonEmptyString(command.id)) {
      throw new HarmonyError(
        `Invalid command ID at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_ID",
      );
    }
    if (!isNonEmptyString(command.name)) {
      throw new HarmonyError(
        `Invalid command name at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_NAME",
      );
    }
    if (!isNonEmptyString(command.deviceId)) {
      throw new HarmonyError(
        `Invalid device ID for command at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_DEVICE_ID",
      );
    }
    if (command.group && !isValidCommandGroup(command.group)) {
      throw new HarmonyError(
        `Invalid command group at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_GROUP",
      );
    }
  });
  Logger.debug("Device validation passed", { device });
}
/**
 * Validate Harmony activity configuration
 * Throws an error if the activity configuration is invalid
 * @param activity - The activity configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity {
  if (!isNonEmptyString(activity.id)) {
    throw new HarmonyError(
      "Activity ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_ID",
    );
  }
  if (!isNonEmptyString(activity.name)) {
    throw new HarmonyError(
      "Activity name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_NAME",
    );
  }
  if (!isNonEmptyString(activity.type)) {
    throw new HarmonyError(
      "Activity type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_TYPE",
    );
  }
  if (typeof activity.isCurrent !== "boolean") {
    throw new HarmonyError(
      "Activity current status must be a boolean",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_STATUS",
    );
  }
  Logger.debug("Activity validation passed", { activity });
}
/**
 * Validate Harmony command configuration
 * Throws an error if the command configuration is invalid
 * @param command - The command configuration to validate
 * @throws {HarmonyError} If any required fields are missing or invalid
 */
export function validateCommand(command: Partial<HarmonyCommand>): asserts command is HarmonyCommand {
  if (!isNonEmptyString(command.id)) {
    throw new HarmonyError(
      "Command ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_ID",
    );
  }
  if (!isNonEmptyString(command.name)) {
    throw new HarmonyError(
      "Command name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_NAME",
    );
  }
  if (!isNonEmptyString(command.label)) {
    throw new HarmonyError(
      "Command label is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_LABEL",
    );
  }
  if (!isNonEmptyString(command.deviceId)) {
    throw new HarmonyError(
      "Command device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_DEVICE_ID",
    );
  }
  if (command.group && !isValidCommandGroup(command.group)) {
    throw new HarmonyError(
      "Invalid command group",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_GROUP",
    );
  }
  Logger.debug("Command validation passed", { command });
}
/**
 * Validates a numeric preference value
 * @param value - The value to validate
 * @param min - Minimum allowed value
 * @param max - Maximum allowed value
 * @param name - Name of the preference for error messages
 * @throws {HarmonyError} If the value is invalid
 */
export function validateNumericPreference(value: unknown, min: number, max: number, name: string): asserts value is number {
  if (typeof value !== "number" || isNaN(value)) {
    throw new HarmonyError(
      `${name} must be a number`,
      ErrorCategory.VALIDATION,
      undefined,
      { type: typeof value },
      false,
      "INVALID_NUMERIC_PREFERENCE",
    );
  }
  if (value < min || value > max) {
    throw new HarmonyError(
      `${name} must be between ${min} and ${max}`,
      ErrorCategory.VALIDATION,
      undefined,
      { min, max },
      false,
      "NUMERIC_PREFERENCE_OUT_OF_RANGE",
    );
  }
  Logger.debug(`Validated ${name}`, { value, min, max });
}
/**
 * Validates a string preference value
 * @param value - The value to validate
 * @param allowedValues - List of allowed values
 * @param name - Name of the preference for error messages
 * @throws {HarmonyError} If the value is invalid
 */
export function validateStringPreference(
  value: unknown,
  allowedValues: readonly string[],
  name: string,
): asserts value is string {
  if (typeof value !== "string") {
    throw new HarmonyError(
      `${name} must be a string`,
      ErrorCategory.VALIDATION,
      undefined,
      { type: typeof value },
      false,
      "INVALID_STRING_PREFERENCE",
    );
  }
  if (!allowedValues.includes(value)) {
    throw new HarmonyError(
      `${name} must be one of: ${allowedValues.join(", ")}`,
      ErrorCategory.VALIDATION,
      undefined,
      { allowedValues },
      false,
      "STRING_PREFERENCE_NOT_ALLOWED",
    );
  }
  Logger.debug(`Validated ${name}`, { value, allowedValues });
}
/**
 * Validates a boolean preference value
 * @param value - The value to validate
 * @param name - Name of the preference for error messages
 * @throws {HarmonyError} If the value is invalid
 */
export function validateBooleanPreference(value: unknown, name: string): asserts value is boolean {
  if (typeof value !== "boolean") {
    throw new HarmonyError(
      `${name} must be a boolean`,
      ErrorCategory.VALIDATION,
      undefined,
      { type: typeof value },
      false,
      "INVALID_BOOLEAN_PREFERENCE",
    );
  }
  Logger.debug(`Validated ${name}`, { value });
}
/**
 * Validates the default view preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateDefaultView(value: unknown): asserts value is string {
  validateStringPreference(value, ["devices", "activities", "commands"], "Default view");
}
/**
 * Validates the command display mode preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateCommandDisplayMode(value: unknown): asserts value is string {
  validateStringPreference(value, ["list", "grid"], "Command display mode");
}
/**
 * Validates the command grid columns preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateCommandGridColumns(value: unknown): asserts value is number {
  validateNumericPreference(value, 2, 6, "Command grid columns");
}
/**
 * Validates the auto-connect preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateAutoConnect(value: unknown): asserts value is boolean {
  validateBooleanPreference(value, "Auto-connect");
}
/**
 * Validates the show toast notifications preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateShowToasts(value: unknown): asserts value is boolean {
  validateBooleanPreference(value, "Show toast notifications");
}
/**
 * Validates the discovery timeout preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateDiscoveryTimeout(value: unknown): asserts value is number {
  validateNumericPreference(value, 1000, 30000, "Discovery timeout");
}
/**
 * Validates the command execution timeout preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateCommandTimeout(value: unknown): asserts value is number {
  validateNumericPreference(value, 100, 5000, "Command execution timeout");
}
/**
 * Validates the activity change timeout preference
 * @param value - The value to validate
 * @throws {HarmonyError} If the value is invalid
 */
export function validateActivityTimeout(value: unknown): asserts value is number {
  validateNumericPreference(value, 1000, 30000, "Activity change timeout");
}
</file>

<file path="src/control.tsx">
import React from "react";
import { HarmonyProvider } from "./hooks/useHarmony";
import { HarmonyCommand } from "./ui/components/views/HarmonyCommand";
export default function Command(): React.ReactElement {
  return (
    <HarmonyProvider>
      <HarmonyCommand />
    </HarmonyProvider>
  );
}
</file>

<file path=".eslintrc.json">
{
  "extends": ["@raycast/eslint-config"],
  "plugins": ["import"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "import/order": [
      "error",
      {
        "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
        "newlines-between": "always",
        "alphabetize": {
          "order": "asc",
          "caseInsensitive": true
        }
      }
    ],
    "@typescript-eslint/explicit-function-return-type": [
      "error",
      {
        "allowExpressions": true,
        "allowTypedFunctionExpressions": true
      }
    ]
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# Raycast specific files
raycast-env.d.ts
.raycast-swift-build
.swiftpm
compiled_raycast_swift

# Windsurf files
.windsurfrules
global_rules.md

# misc
.DS_Store

# Project planning
.Plan
</file>

<file path=".prettierrc">
{
  "printWidth": 120,
  "singleQuote": false
}
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to the Harmony Control extension will be documented in this file.

## [1.0.0] - 2025-02-07

### Added
- Initial release of Harmony Control extension
- Automatic hub discovery on local network
- Device control with command execution
- Activity management (start/stop)
- Local caching of hub configuration
- Secure credential storage
- Error handling and recovery
- Configurable preferences:
  - Default view (Activities/Devices)
  - Command hold time
  - Cache duration
  - Network timeout
  - Debug mode
  - Auto retry settings

### Technical Improvements
- TypeScript strict mode compliance
- Proper error categorization and handling
- WebSocket connection management
- Performance optimizations with caching
- Secure storage implementation

### Documentation
- Comprehensive README with setup guide
- API documentation
- Troubleshooting guide
- Screenshots of key features
</file>

<file path="package.json">
{
  "$schema": "https://www.raycast.com/schemas/extension.json",
  "name": "harmony-control",
  "version": "1.0.0",
  "title": "Harmony Control",
  "description": "Control your Logitech Harmony Hub devices",
  "icon": "command-icon.png",
  "author": "chad_walters",
  "categories": [
    "Media",
    "System"
  ],
  "license": "MIT",
  "commands": [
    {
      "name": "control",
      "title": "Control Harmony Hub",
      "description": "Control your Harmony Hub devices and activities",
      "mode": "view"
    }
  ],
  "preferences": [
    {
      "name": "defaultView",
      "type": "dropdown",
      "required": false,
      "title": "Default View",
      "description": "Choose whether to show Activities or Devices by default",
      "default": "devices",
      "data": [
        {
          "title": "Activities",
          "value": "activities"
        },
        {
          "title": "Devices",
          "value": "devices"
        }
      ]
    },
    {
      "name": "commandHoldTime",
      "type": "textfield",
      "required": false,
      "title": "Command Hold Time",
      "description": "Duration to hold a command in milliseconds",
      "default": "100"
    },
    {
      "name": "debugMode",
      "type": "checkbox",
      "required": false,
      "title": "Debug Mode",
      "description": "Enable detailed logging for troubleshooting",
      "default": false,
      "label": "Enable Debug Mode"
    },
    {
      "name": "autoRetry",
      "type": "checkbox",
      "required": false,
      "title": "Auto Retry",
      "description": "Automatically retry failed operations",
      "default": true,
      "label": "Enable Auto Retry"
    },
    {
      "name": "maxRetries",
      "type": "textfield",
      "required": false,
      "title": "Max Retries",
      "description": "Maximum number of retry attempts",
      "default": "3"
    }
  ],
  "dependencies": {
    "@harmonyhub/client-ws": "^1.0.9",
    "@harmonyhub/discover": "^1.0.9",
    "@raycast/api": "^1.91.1",
    "@raycast/utils": "^1.10.1",
    "immer": "^10.1.1",
    "node-machine-id": "^1.1.12",
    "uuid": "^9.0.1",
    "ws": "^8.16.0",
    "xstate": "^5.19.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@raycast/eslint-config": "^1.0.6",
    "@types/node": "^20.8.10",
    "@types/react": "^18.2.27",
    "@types/uuid": "^9.0.7",
    "@types/ws": "^8.5.14",
    "eslint": "^8.51.0",
    "eslint-plugin-import": "^2.31.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "scripts": {
    "build": "ray build -e dist",
    "dev": "ray develop",
    "fix-lint": "ray lint --fix",
    "lint": "ray lint",
    "publish": "npx @raycast/api@latest publish"
  }
}
</file>

<file path="Plan.md">
# Harmony Raycast Extension Refactoring Plan

## Overview
Based on the senior developer code review, we need to improve several areas of the codebase to align with Raycast extension best practices and enhance maintainability. This document outlines specific issues, solutions, and implementation strategy.

## Current Issues and Solutions

### Component Structure
**Issues:**
- `HarmonyCommand.tsx` is handling too much responsibility 
- View logic is mixed with state management 
- Duplicate error handling patterns 

**Solutions:**
1.  Break down `HarmonyCommand.tsx` into focused view components
2.  Use simple view state management
3.  Create reusable shared components

### State Management
**Issues:**
- Complex state updates in useHarmony 
- Scattered preference management 
- Redundant state derivations 

**Solutions:**
1.  Implement Zustand store for centralized state
2.  Move async operations to store actions
3.  Use selectors for derived state

### Error Handling
**Issues:**
- Inconsistent error handling 
- Duplicate try/catch blocks 
- Basic error messages 

**Solutions:**
1.  Implement simple, centralized error handling
2.  Use Raycast's toast system effectively
3.  Add proper error recovery flows

### Performance
**Issues:**
- Unnecessary re-renders 
- Inefficient data fetching 
- Memory leaks 

**Solutions:**
1.  Implement proper cleanup in useEffect
2.  Use memoization for expensive computations
3.  Proper component unmounting

## Implementation Strategy

### Phase 1: Core Foundation (1-2 days) 
Dependencies: None
-  1.1 Type Definition Consolidation
  - Created organized type hierarchy in `src/types/core/`
  - Added comprehensive JSDoc documentation
  - Implemented type guards and validation utilities
  - Added immutable types with `readonly`
  - Created error handling types and utilities
  - Added WebSocket and state management types
  - Consolidated all types in central index
-  1.2 Error and Logging Setup
  - Implemented ErrorHandler with categorized error handling
  - Created ToastManager for consistent user notifications
  - Added Logger with multiple log levels and history
  - Integrated error handling with logging and toasts
  - Added error recovery actions and user-friendly messages
  - Implemented development mode console logging
-  1.3 Zustand Store Setup
  - Defined store structure with proper typing
  - Created mutable state types for Immer integration
  - Implemented comprehensive actions for hub, device, and activity management
  - Added error handling and loading state management
  - Created selectors for derived state
  - Integrated with error handling and toast notifications

### Phase 2: View Components (2-3 days) 
Dependencies: Phase 1
-  2.1 Shared Components
  - Implemented FeedbackState for loading, error, and empty states
  - Created BaseActionPanel with common management actions
  - Added DeviceActionPanel for device-specific commands
  - Added ActivityActionPanel for activity controls
  - All components use Raycast UI patterns and keyboard shortcuts
  - Proper TypeScript typing and error handling
-  2.2 HubsView Implementation
  - Created HubsView component with hub discovery and selection
  - Integrated FeedbackState for loading, error, and empty states
  - Added search functionality for hubs
  - Implemented hub selection with visual feedback
  - Used BaseActionPanel for common actions
  - Added proper TypeScript typing and error handling
-  2.3 DevicesView Implementation
  - Created DevicesView with device listing and command execution
  - Implemented device grouping by type
  - Added search functionality for devices and commands
  - Integrated with DeviceActionPanel for command execution
  - Added detailed device view with command list
  - Implemented memoization for performance
  - Used FeedbackState for loading, error, and empty states
  - Added proper TypeScript typing and error handling
-  2.4 ActivitiesView Implementation
  - Created ActivitiesView with activity management
  - Implemented activity grouping by type
  - Added real-time status updates and visual feedback
  - Integrated with ActivityActionPanel for start/stop control
  - Added detailed activity view with status information
  - Implemented loading states for activity transitions
  - Added search functionality for activities
  - Used FeedbackState for loading, error, and empty states
  - Added proper TypeScript typing and error handling

### Phase 3: State and Navigation (1 day) 
Dependencies: Phase 1, Phase 2
-  3.1 View State Management
  - Simple view state in HarmonyCommand
  - View transitions
  - Keyboard shortcuts
-  3.2 Custom Hooks
  - Implemented useCommandExecution with retry logic and error handling
  - Created useDeviceFiltering with memoized device filtering and grouping
  - Added useActivityFiltering with memoized activity filtering and status tracking
  - Built usePreferences with validation and error handling
-  3.3 Store Integration
  - Connected views to store using Zustand
  - Implemented proper cleanup in store actions
  - Added state persistence with versioning
  - Created persistence middleware for Zustand stores
  - Implemented local storage integration
  - Added error handling and logging for persistence
  - Implemented state hydration and migration support

### Phase 4: Performance and Polish (1-2 days) 
Dependencies: All previous phases
-  4.1 Performance Optimization
  - Added React.memo for all view components
  - Extracted and memoized list item components
  - Implemented memoized callbacks with useCallback
  - Optimized data filtering with useMemo
  - Added custom comparison functions for memoization
  - Improved prop passing to reduce re-renders
  - Optimized component structure for better performance
  - Added proper cleanup in useEffect hooks
-  4.2 Data Management
  - Implemented LocalStorage for state persistence
  - Added preference handling with validation
  - Created cache management with versioning
  - Added state migration support
  - Implemented error handling for storage operations
-  4.3 Error Experience
  - Enhanced error visualization with color-coded status
  - Added category-specific icons and colors
  - Implemented detailed troubleshooting steps
  - Added progress feedback for async operations
  - Created recovery action suggestions
  - Improved error message formatting
  - Added technical details for debugging
  - Enhanced toast notifications with actions
  - Implemented error recovery flows
  - Added proper error cleanup and state reset

### Phase 5: Codebase Cleanup and Consolidation (1-2 days)
Dependencies: All previous phases

- [x] 5.0 Preparation ( Completed)
  - Created comprehensive import map of all files and dependencies
  - Created Git branch specifically for cleanup
  - Created full backup of codebase
  - Documented current state of all error handling and toast notifications

- [x] 5.0b Dependency Analysis ( Completed)
  - Mapped all error handler and toast dependencies
  - Documented usage patterns and configurations
  - Created migration paths for each component
  - Analyzed impact of file deletions

- [x] 5.1 Safe File Deletions ( Completed)
  - Deleted unused secure-storage.ts
  - Deleted unused state.ts
  - Verified no broken dependencies
  - Validated compilation after deletions

- [x] 5.2 Error Handler Migration ( Completed)
  - Created backup of error-handler.ts
  - Migrated functionality to errorHandler.ts
  - Updated all components to use new error handler
  - Verified error handling and recovery flows
  - Removed old error handler files

- [x] 5.3 Store Persistence Cleanup ( Completed)
  - Audited persistence in harmony store
  - Audited persistence in view store
  - Tested persistence functionality
  - Removed unused persist middleware

- [x] 5.4 Command Queue Migration ( Completed)
  - Evaluated current queue usage
  - Determined queueing not needed
  - Removed unused command queue

- [x] 5.5 Type System Cleanup ( Completed)
  -  Merged harmony.ts into core/harmony.ts
  -  Updated import statements
  -  Fixed type errors
  -  Removed duplicate types

- [x] 5.6 Code Quality Improvements ( Completed)
  - TypeScript Enhancements:
    -  Fix missing return types across codebase
    -  Remove unused imports and variables
    -  Fix type errors in usePreferences.ts
    -  Add missing method implementations in HarmonyError
    -  Enforce strict TypeScript configuration
    -  Fix type errors in harmonyClient.ts
  - Linting and Style:
    -  Configure and run Prettier
    -  Fix all current linting issues
    -  Remove unused code
    -  Improve code organization
    -  Add proper JSDoc comments
  - Documentation:
    -  Update API documentation
    -  Document error handling patterns

- [ ] 5.7 Final Verification and Release Prep ( In Progress)
  - Comprehensive Testing:
    -  Run full TypeScript compilation
    -  Run linter checks
    -  Manual testing of all functionality
    -  Test error scenarios
    -  Test state persistence
  - Documentation Review:
    - Verify documentation accuracy
    - Update README
    - Check API documentation
    - Review error messages
  - Performance Check:
    - Test startup time
    - Monitor memory usage
    - Check render performance
  - Release Preparation:
    - Create release notes
    - Tag version
    - Update changelog
    - Prepare for submission

- [ ] 5.8 Automation and CI/CD ( Not Started)
  - Setup GitHub Actions:
    - TypeScript compilation
    - Linting
    - Code formatting
    - Release automation
  - Add Development Tools:
    - Pre-commit hooks
    - Automated code formatting
    - Version management
    - Dependency updates
  - Documentation:
    - CI/CD workflow
    - Development setup
    - Contributing guidelines

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking changes in Raycast API | Low | High | Monitor Raycast releases |
| Memory leaks | Medium | High | Proper useEffect cleanup |
| Network failures | Medium | Medium | Robust error handling |
| State corruption | Low | High | Proper validation |
| User settings loss | Low | High | LocalStorage backup |

## User Experience

### During Refactoring
- Maintain backward compatibility
- Clear error messages
- Performance monitoring
- Graceful degradation

### Release Strategy
1. Internal testing
   - Functionality verification
   - Performance checks
2. Limited user testing
   - Feedback collection
   - Issue tracking
3. Full release
   - Staged rollout
   - Monitor for issues

## Raycast Compliance

### Component Usage
- Use Raycast UI components exclusively
  - List
  - Detail
  - ActionPanel
  - Form
- Follow Raycast's design guidelines
  - Typography
  - Spacing
  - Icons
- Implement keyboard shortcuts
  - View switching
  - Common actions
  - Navigation

### Performance Requirements
- Proper useEffect cleanup
  - Event listeners
  - Timers
  - WebSocket connections
- Efficient state management
  - Zustand store
  - Memoized selectors
  - Minimal component state
- Raycast API usage
  - LocalStorage for persistence
  - Toast for user feedback
  - Preference management

## Next Steps

1. Review and approve updated plan
2. Begin Phase 1 implementation
3. Regular progress reviews
4. User communication
</file>

<file path="README.md">
# Harmony Raycast Extension

Control your Logitech Harmony Hub directly from Raycast. This extension allows you to manage your devices, execute commands, and control activities without leaving your keyboard.

## Features

-  Automatic hub discovery on your network
-  Control all your Harmony-connected devices
-  Quick access to device commands
-  Start and stop activities
-  Real-time status updates
-  Full keyboard navigation

## Installation

1. Make sure you have [Raycast](https://raycast.com/) installed
2. Install the Harmony extension from the Raycast store
3. The extension will automatically discover your Harmony Hub(s) on the network

## Usage

### Hub Connection

The extension will automatically discover Harmony Hubs on your local network. 

**Note**: If only one Harmony Hub is found on your network, the extension will automatically connect to it. This auto-connection behavior is designed to streamline the experience for users with a single hub setup.

### Device Control

1. Select a device from the list
2. Browse available commands
3. Execute commands with a single click or keyboard shortcut

### Activities

1. View all configured activities
2. Start or stop activities
3. See real-time activity status

## Keyboard Shortcuts

- ` + R`: Refresh hub/device list
- ` + [`: Go back to previous view
- ` + Backspace`: Clear cache
- ` + Shift + R`: Reconnect to hub
- ` + Shift + A`: Switch to Activities view
- ` + Shift + D`: Switch to Devices view
- ` + K`: Open command palette for quick actions

## Troubleshooting

If you encounter any issues:

1. Try refreshing the hub connection ( + R)
2. Clear the cache ( + Backspace)
3. Ensure your Harmony Hub is on the same network
4. Check your network firewall settings

## Development

```bash
# Clone the repository
git clone https://github.com/yourusername/harmony-raycast-extension.git

# Install dependencies
npm install

# Run in development mode
npm run dev
```

## Contributing

Contributions are welcome! Please read our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

<file path="tsconfig.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Node 16",
  "include": ["src/**/*", "raycast-env.d.ts"],
  "compilerOptions": {
    "lib": ["es2021"],
    "module": "commonjs",
    "target": "es2021",
    "strict": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "noEmit": false,
    "outDir": "dist",
    
    // Additional strict checks
    "noImplicitAny": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "strictBindCallApply": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true,
    "useUnknownInCatchVariables": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    "noImplicitOverride": true
  }
}
</file>

</files>
