This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-19T13:06:50.074Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
local-docs/
  harmony-raycast.md
src/
  features/
    control/
      types/
        harmony.ts
  hooks/
    useActivityFiltering.ts
    useCommandExecution.ts
    useDeviceFiltering.ts
    useHarmony.ts
    usePreferences.ts
  services/
    harmony/
      commandQueue.ts
      harmonyClient.ts
      harmonyManager.ts
      harmonyState.ts
    error-handler.ts
    errorHandler.ts
    localStorage.ts
    logger.ts
    secure-storage.ts
    session-manager.ts
    toast.ts
  stores/
    middleware/
      persist.ts
    harmony.ts
    view.ts
  types/
    core/
      command.ts
      errors.ts
      harmony.ts
      index.ts
      logging.ts
      state-mutable.ts
      state.ts
      validation.ts
      views.ts
      websocket.ts
    components.ts
    harmony.ts
    logging.ts
    preferences.ts
    state.ts
    websocket.ts
  ui/
    components/
      actions/
        ActivityActionPanel.tsx
        BaseActionPanel.tsx
        DeviceActionPanel.tsx
      views/
        ActivitiesView.tsx
        CommandsView.tsx
        DevicesView.tsx
        HarmonyCommand.tsx
        HubsView.tsx
      FeedbackState.tsx
    toast-manager.ts
  utils/
    state.ts
    validation.ts
  control.tsx
.eslintrc.json
.gitignore
.prettierrc
CHANGELOG.md
package.json
Plan.md
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="local-docs/harmony-raycast.md">
```markdown
# Harmony Control for Raycast

Harmony Control is a Raycast extension that allows you to control your Logitech Harmony Hub devices directly from Raycast. It provides a fast and efficient interface for managing your home entertainment system.

## Quick Start

### Installation

1.  Open Raycast.
2.  Search for "Harmony Control".
3.  Click Install.

### Usage

1.  Launch the extension by typing "Harmony Control" in Raycast.
2.  The extension will automatically discover Harmony Hubs on your local network.
3.  Select your hub from the list.
4.  Browse and control your devices and activities.

## Configuration

You can configure the extension in Raycast's preferences:

*   **Default View:** Choose whether to show "Activities" or "Devices" by default.
*   **Command Hold Time:** Adjust the duration (in milliseconds) to hold a command. Default is 100ms.
*   **Cache Duration:**  Set how long hub data is cached (in seconds). Default is 3600 seconds (1 hour).
*   **Debug Logging:** Enable or disable debug logging. Default is true.
*   **Network Timeout:**  Set the network request timeout (in milliseconds). Default is 5000ms.
* **Auto Retry:** Enable/Disable automatic retries for failed operations. Defaults to true
* **Max Retries**: Maximum number of times to retry. Defaults to 3.

## Features

### Device Control

*   Browse all configured devices.
*   Execute device-specific commands (e.g., power, volume, input).

### Activity Management

*   Start and stop Harmony activities.
*   View the current activity status.

### Hub Discovery
* Automatically detects hubs on the local network

### Other
* Refresh the current connection.
* Clear cache and re-discover hubs.

## Troubleshooting
* Ensure your Hub and Mac are on the same network.
* Make sure the Hub is powered on and connected to your Wi-Fi.
* Check your firewall settings and unblock ports required by Harmony.
* Verify that the hub has a direct line of sight to IR-controlled devices.

## Dependencies

*   `@harmonyhub/client-ws`:  Harmony Hub client library.
*   `@harmonyhub/discover`:  Harmony Hub discovery library.
*   `@raycast/api`: Raycast API library.
*   `@raycast/utils`: Raycast utilities.
*   `ws`: WebSocket library.

## Public Interfaces and Features

The extension's main functionalities are organized around React components, custom hooks, and services. Here's a breakdown:

### `src/control.tsx`

This is the main entry point for the extension. It renders the `HarmonyCommand` component wrapped in a `HarmonyProvider`.

### Components (`src/components/`)

#### `DeviceList.tsx`

Displays a searchable list of Harmony devices and their commands.

*   **Props:**
    *   `deviceType?: string`: (Optional) Filters the list to a specific device type.

*   **Features:**
    *   Lists devices, showing their name, type, and number of commands.
    *   Provides a search bar to filter devices and commands.
    *   Allows execution of commands via an `ActionPanel`.

#### `ErrorBoundary.tsx`

A standard React error boundary component that catches and displays errors.

*   **Props:**
    *   `children: React.ReactNode`: The child components to wrap.

*   **Features:**
    *   Catches errors in its child component tree.
    *   Displays a generic error message.
    *   Logs errors for debugging.

#### `FeedbackState.tsx`

Displays loading, error, and empty states.

*   **Props:**
    *   `title: string`: The title to display.
    *   `description?: string`: Optional description.
    *   `icon?: Icon | { source: string }`: The icon.
    *   `color?: Color`: Icon color.
    *   `actions?: React.ReactNode`: Optional actions.
    *   `error?: HarmonyError`: Optional error object.
    *   `onRetry?: () => void`: Optional retry callback.
    * `onReconnect?: () => void`: Optional reconnect callback.
    * `onClearCache?: () => void`: Optional clear-cache callback.
    * `onResetConfig?: () => void`: Optional config-reset callback.
*   **Features:**
    *   Provides consistent UI for different states.
    *   Supports displaying error details and recovery actions.

#### `HarmonyCommand.tsx`

Provides a unified interface to control devices and activities.

*   **Features:**
    *   Displays a list of hubs, activities, or devices based on the selected view.
    *   Supports searching and filtering.
    *   Allows execution of commands and starting/stopping activities.
    *   Handles hub selection and connection.
    * Handles switching view between hubs, activities, devices, and individual commands.

### Hooks (`src/hooks/`)

#### `useHarmony.ts`

The main hook for managing Harmony Hub state and operations. Provides a context that is used by other components.

*   **Returned Values:**
    *   `hubs: HarmonyHub[]`: List of discovered hubs.
    *   `selectedHub: HarmonyHub | null`: The currently selected hub.
    *   `devices: HarmonyDevice[]`: List of devices for the selected hub.
    *   `activities: HarmonyActivity[]`: List of activities for the selected hub.
    *   `currentActivity: HarmonyActivity | null`: The currently active activity.
    *   `error: HarmonyError | null`: Any current error.
    *   `loadingState: LoadingState`: The current loading state.
    *   `connect: (hub: HarmonyHub) => Promise<void>`: Connects to the specified hub.
    *   `disconnect: () => Promise<void>`: Disconnects from the current hub.
    *   `refresh: () => Promise<void>`: Refreshes the hub state.
    *   `executeCommand: (command: HarmonyCommand) => Promise<void>`: Executes a command.
    *   `clearCache: () => Promise<void>`: Clears the cache and rediscovers hubs.
    *   `startActivity: (activityId: string) => Promise<void>`: Starts an activity.
    *   `stopActivity: () => Promise<void>`: Stops the current activity.

### Services (`src/services/`)
#### `harmony/harmonyClient.ts`

Handles communication with a specific Harmony Hub.

*   **`HarmonyClient` Class:**
    *   `constructor(hub: HarmonyHub)`: Initializes a new client for the given hub.
    *   `connect(): Promise<void>`: Connects to the hub.
    *   `getDevices(): Promise<HarmonyDevice[]>`: Retrieves the list of devices.
    *   `getActivities(): Promise<HarmonyActivity[]>`: Retrieves the list of activities.
    *   `getCurrentActivity(): Promise<HarmonyActivity | null>`: Gets the current activity.
    *   `startActivity(activityId: string): Promise<void>`: Starts an activity.
    *   `stopActivity(): Promise<void>`: Stops the current activity.
    *   `executeCommand(command: HarmonyCommand): Promise<void>`: Executes a command.
    *   `disconnect(): Promise<void>`: Disconnects from the hub.

#### `harmony/harmonyManager.ts`

Manages discovery of Harmony Hubs.

* **`HarmonyManager` Class:**
  * `startDiscovery(onProgress?: (progress: number, message: string) => void): Promise<HarmonyHub[]>`: Starts the hub discovery process, with an optional progress callback.
  * `cleanup(): Promise<void>`: Cleans up discovery.
  *  `clearCache(): Promise<void>`: Clears the hub cache.

#### `harmony/commandQueue.ts`

Manages a queue of commands to be executed.

*   **`CommandQueue` Class:**
    *   `constructor(commandSender: CommandSender, config?: Partial<CommandQueueConfig>)`: Creates a new command queue. `CommandSender` is a function that takes a `HarmonyCommand` and sends it.
    *   `enqueue(request: CommandRequest): Promise<CommandResult>`: Adds a command to the queue.
    *  `cancelAll(): void`: Cancels all pending commands
    *  `clearCompleted(): void`: Clears completed commands.

#### `errorHandler.ts`

Provides consistent error handling.

*   **`ErrorHandler` Class:**
    *   `static handle(error: Error | unknown, context?: string): void`: Handles an error by logging and showing a toast.
    *   `static handleAsync<T>(operation: () => Promise<T>, context?: string): Promise<T>`: Handles errors in an async operation.

#### `localStorage.ts`

Provides a wrapper around Raycast's `LocalStorage` with error logging.

*   **`LocalStorage` Class:**
    *   `static getItem(key: string): Promise<string | null>`: Retrieves an item.
    *   `static setItem(key: string, value: string): Promise<void>`: Stores an item.
    *   `static removeItem(key: string): Promise<void>`: Removes an item.
    *   `static clear(): Promise<void>`: Clears all items.

#### `logger.ts`

Provides a logging mechanism.

*   **`Logger` Class:**
    *   `static debug(message: string, data?: unknown): void`: Logs a debug message.
    *   `static info(message: string, data?: unknown): void`: Logs an info message.
    *   `static warn(message: string, data?: unknown): void`: Logs a warning message.
    *   `static error(message: string, data?: unknown): void`: Logs an error message.
    *   `static logError(error: Error, context?: string): void`: Logs a full error with stack trace.

#### `secure-storage.ts`
Provides secure storage using encryption. (Currently not in use.)
#### `session-manager.ts`
Manages sessions. (Currently not in use.)

#### `ui/toast-manager.ts`

Helper class to wrap and simplify Raycast `showToast` calls.

*   **`ToastManager` Class:**
    *  `static success(title: string, message?: string): void`: Shows a success toast.
    *  `static error(title: string, message?: string): void`: Shows an error toast.
    *  `static loading(title: string, message?: string): void` Shows a loading toast.

#### `utils/validation.ts`

Provides validation functions.
*   `isNonEmptyString(value: unknown): value is string`: Check if a value is not an empty string.
*  `isPositiveNumber(value: unknown): value is number`: Checks if a value is a number > 0.
*   `isValidIpAddress(value: unknown): value is string`: Checks if a value is a valid IPv4 address.
*  `validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub`: Validates Hub configurations.
*  `validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice`: Validates Device information.
* `validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity`: Validates Activity information.
* `validateCommandRequest(request: Partial<CommandRequest>): asserts request is CommandRequest`: Validates requests.

### Types (`src/types/`)

This directory contains TypeScript type definitions for the project.  Key types include:

*   `harmony.ts`:  Defines core types like `HarmonyHub`, `HarmonyDevice`, `HarmonyActivity`, `HarmonyCommand`, and `LoadingState`.
*   `errors.ts`:  Defines `HarmonyError`, `ErrorCategory`, `ErrorSeverity`, and related error handling types.
*  `preferences.ts`: Defines the `Preferences` interface.
*   `logging.ts`: Defines types related to logging (`LogLevel`, `LogEntry`, etc.).
```
</file>

<file path="src/features/control/types/harmony.ts">
export interface HarmonyHub {
  id: string;
  ip: string;
  name: string;
  remoteId: string;
  hubId: string;
  version: string;
  port?: string;
}
export interface HarmonyDevice {
  id: string;
  label: string;
  type: string;
  commands: HarmonyCommand[];
}
export interface HarmonyCommand {
  id: string;
  name: string;
  label: string;
  deviceId: string;
}
export interface ControlGroup {
  name: string;
  function: {
    name: string;
    action: string;
  }[];
}
export interface FixItItem {
  id: string;
  description: string;
  solution: string;
  urls?: string[];
}
export interface ActivityRule {
  type: string;
  condition: string;
  action: string;
}
export interface ActivitySequence {
  id: string;
  name: string;
  steps: {
    action: string;
    delay: number;
  }[];
}
export interface HarmonyActivity {
  id: string;
  label: string;
  isAVActivity: boolean;
  activityTypeDisplayName: string;
  controlGroup: ControlGroup[];
  fixit: FixItItem[];
  rules: ActivityRule[];
  sequences: ActivitySequence[];
  suggestedDisplay: string;
  type: string;
  status: string;
}
</file>

<file path="src/hooks/useActivityFiltering.ts">
/**
 * Hook for filtering activities with memoization
 * @module
 */
import { useMemo } from "react";
import { useHarmony } from "./useHarmony";
import { useViewStore } from "../stores/view";
import { HarmonyActivity } from "../types/core/harmony";
/**
 * Hook for filtering and searching activities
 */
export function useActivityFiltering() {
  const { activities, currentActivity } = useHarmony();
  const searchQuery = useViewStore((state) => state.searchQuery);
  const filters = useViewStore((state) => state.filters);
  // Memoize filtered activities
  const filteredActivities = useMemo(() => {
    let result = [...activities];
    // Apply activity type filter
    if (filters.activityType) {
      result = result.filter((activity) => activity.type === filters.activityType);
    }
    // Apply search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (activity) =>
          activity.name.toLowerCase().includes(query) ||
          activity.type.toLowerCase().includes(query)
      );
    }
    return result;
  }, [activities, searchQuery, filters.activityType]);
  // Memoize activity types
  const activityTypes = useMemo(() => {
    const types = new Set(activities.map((activity) => activity.type));
    return Array.from(types).sort();
  }, [activities]);
  // Memoize activities by type
  const activitiesByType = useMemo(() => {
    const byType = new Map<string, HarmonyActivity[]>();
    filteredActivities.forEach((activity) => {
      const activities = byType.get(activity.type) || [];
      activities.push(activity);
      byType.set(activity.type, activities);
    });
    // Sort activities within each type
    byType.forEach((activities) => {
      activities.sort((a, b) => {
        // Put current activity first
        if (a.id === currentActivity?.id) return -1;
        if (b.id === currentActivity?.id) return 1;
        // Then sort by name
        return a.name.localeCompare(b.name);
      });
    });
    return byType;
  }, [filteredActivities, currentActivity]);
  // Memoize activity status
  const activityStatus = useMemo(() => {
    const status = new Map<string, boolean>();
    activities.forEach((activity) => {
      status.set(activity.id, activity.isCurrent);
    });
    return status;
  }, [activities]);
  return {
    filteredActivities,
    activityTypes,
    activitiesByType,
    activityStatus,
    totalActivities: activities.length,
    filteredCount: filteredActivities.length,
    currentActivity,
  };
}
</file>

<file path="src/hooks/useCommandExecution.ts">
/**
 * Hook for executing Harmony commands with memoization
 * @module
 */
import { useCallback, useState } from "react";
import { useHarmony } from "./useHarmony";
import { HarmonyCommand } from "../types/core/harmony";
import { HarmonyError } from "../types/core/errors";
import { ErrorCategory } from "../types/core/harmony";
import { ToastManager } from "../services/toast";
import { getPreferenceValues } from "@raycast/api";
import { Preferences } from "../types/preferences";
interface CommandExecutionState {
  /** Whether a command is currently executing */
  isExecuting: boolean;
  /** Last executed command */
  lastCommand: HarmonyCommand | null;
  /** Last execution error */
  error: HarmonyError | null;
}
/**
 * Hook for executing commands with retry and error handling
 */
export function useCommandExecution() {
  const { executeCommand } = useHarmony();
  const [state, setState] = useState<CommandExecutionState>({
    isExecuting: false,
    lastCommand: null,
    error: null,
  });
  const preferences = getPreferenceValues<Preferences>();
  const holdTime = parseInt(preferences.commandHoldTime, 10);
  const autoRetry = preferences.autoRetry;
  const maxRetries = parseInt(preferences.maxRetries, 10);
  const execute = useCallback(
    async (command: HarmonyCommand) => {
      setState((prev) => ({
        ...prev,
        isExecuting: true,
        lastCommand: command,
        error: null,
      }));
      try {
        let retries = 0;
        let success = false;
        while (!success && retries <= maxRetries) {
          try {
            await executeCommand(command);
            success = true;
          } catch (error) {
            retries++;
            if (!autoRetry || retries > maxRetries) {
              throw error;
            }
            // Wait before retrying
            await new Promise((resolve) => setTimeout(resolve, holdTime));
          }
        }
        setState((prev) => ({
          ...prev,
          isExecuting: false,
        }));
        ToastManager.success(`Executed ${command.label}`);
      } catch (error) {
        const harmonyError = new HarmonyError(
          `Failed to execute ${command.label}`,
          ErrorCategory.COMMAND,
          error instanceof Error ? error : undefined
        );
        setState((prev) => ({
          ...prev,
          isExecuting: false,
          error: harmonyError,
        }));
        ToastManager.error(`Failed to execute ${command.label}`, harmonyError.message);
      }
    },
    [executeCommand, holdTime, autoRetry, maxRetries]
  );
  const retry = useCallback(async () => {
    if (state.lastCommand) {
      await execute(state.lastCommand);
    }
  }, [execute, state.lastCommand]);
  return {
    execute,
    retry,
    isExecuting: state.isExecuting,
    lastCommand: state.lastCommand,
    error: state.error,
  };
}
</file>

<file path="src/hooks/useDeviceFiltering.ts">
/**
 * Hook for filtering devices with memoization
 * @module
 */
import { useMemo } from "react";
import { useHarmony } from "./useHarmony";
import { useViewStore } from "../stores/view";
import { HarmonyDevice } from "../types/core/harmony";
/**
 * Hook for filtering and searching devices
 */
export function useDeviceFiltering() {
  const { devices } = useHarmony();
  const searchQuery = useViewStore((state) => state.searchQuery);
  const filters = useViewStore((state) => state.filters);
  // Memoize filtered devices
  const filteredDevices = useMemo(() => {
    let result = [...devices];
    // Apply device type filter
    if (filters.deviceType) {
      result = result.filter((device) => device.type === filters.deviceType);
    }
    // Apply search query
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      result = result.filter(
        (device) =>
          device.name.toLowerCase().includes(query) ||
          device.type.toLowerCase().includes(query) ||
          device.commands.some((cmd) =>
            cmd.label.toLowerCase().includes(query)
          )
      );
    }
    return result;
  }, [devices, searchQuery, filters.deviceType]);
  // Memoize device types
  const deviceTypes = useMemo(() => {
    const types = new Set(devices.map((device) => device.type));
    return Array.from(types).sort();
  }, [devices]);
  // Memoize devices by type
  const devicesByType = useMemo(() => {
    const byType = new Map<string, HarmonyDevice[]>();
    filteredDevices.forEach((device) => {
      const devices = byType.get(device.type) || [];
      devices.push(device);
      byType.set(device.type, devices);
    });
    // Sort devices within each type
    byType.forEach((devices) => {
      devices.sort((a, b) => a.name.localeCompare(b.name));
    });
    return byType;
  }, [filteredDevices]);
  return {
    filteredDevices,
    deviceTypes,
    devicesByType,
    totalDevices: devices.length,
    filteredCount: filteredDevices.length,
  };
}
</file>

<file path="src/hooks/useHarmony.ts">
import React, { useCallback, useEffect, useState, createContext, useContext, useRef } from "react";
import { 
  HarmonyHub, 
  HarmonyDevice, 
  HarmonyActivity, 
  HarmonyCommand, 
  LoadingState, 
  HarmonyStage 
} from "../types/harmony";
import { HarmonyManager } from "../services/harmony/harmonyManager";
import { HarmonyClient } from "../services/harmony/harmonyClient";
import { HarmonyError, ErrorCategory } from "../types/core/errors";
import { Logger } from "../services/logger";
import { showToast, Toast } from "@raycast/api";
// Create a single manager instance
const manager = new HarmonyManager();
interface HarmonyContextState {
  hubs: HarmonyHub[];
  selectedHub: HarmonyHub | null;
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  error: HarmonyError | null;
  loadingState: LoadingState;
  connect: (hub: HarmonyHub) => Promise<void>;
  disconnect: () => Promise<void>;
  refresh: () => Promise<void>;
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  clearCache: () => Promise<void>;
  startActivity: (activityId: string) => Promise<void>;
  stopActivity: () => Promise<void>;
}
const HarmonyContext = createContext<HarmonyContextState | null>(null);
interface HarmonyProviderProps {
  children: React.ReactNode;
}
/**
 * Provider component for Harmony Hub functionality
 */
export const HarmonyProvider: React.FC<HarmonyProviderProps> = ({ children }) => {
  const harmony = useHarmonyState();
  return React.createElement(HarmonyContext.Provider, { value: harmony }, children);
};
/**
 * Hook for managing Harmony Hub state and operations
 */
function useHarmonyState(): HarmonyContextState {
  const [state, setState] = useState<{
    hubs: HarmonyHub[];
    selectedHub: HarmonyHub | null;
    client: HarmonyClient | null;
    devices: HarmonyDevice[];
    activities: HarmonyActivity[];
    currentActivity: HarmonyActivity | null;
    error: HarmonyError | null;
    loadingState: LoadingState;
  }>({
    hubs: [],
    selectedHub: null,
    client: null,
    devices: [],
    activities: [],
    currentActivity: null,
    error: null,
    loadingState: {
      stage: HarmonyStage.INITIAL,
      message: "Starting hub discovery",
      progress: 0
    }
  });
  // Use ref to track if discovery is in progress
  const isDiscovering = useRef(false);
  // Update loading state
  const setLoadingState = useCallback((stage: HarmonyStage, message: string, progress: number) => {
    setState(prev => ({
      ...prev,
      loadingState: { stage, message, progress }
    }));
  }, []);
  // Set error state
  const setError = useCallback((error: HarmonyError | null) => {
    setState(prev => ({ ...prev, error }));
  }, []);
  // Connect to a hub
  const connect = useCallback(async (hub: HarmonyHub) => {
    try {
      Logger.info(`Connecting to hub ${hub.name}`);
      setError(null);
      setLoadingState(HarmonyStage.CONNECTING, `Connecting to ${hub.name}...`, 0);
      // Create and connect to the client
      const newClient = new HarmonyClient(hub);
      await newClient.connect();
      Logger.info("Connected to hub, setting up state");
      setState(prev => ({
        ...prev,
        client: newClient,
        selectedHub: hub
      }));
      // Load devices
      setLoadingState(HarmonyStage.LOADING_DEVICES, "Loading devices...", 0.3);
      Logger.info("Loading devices");
      const hubDevices = await newClient.getDevices();
      Logger.info(`Loaded ${hubDevices.length} devices`);
      setState(prev => ({ ...prev, devices: hubDevices }));
      // Load activities
      setLoadingState(HarmonyStage.LOADING_ACTIVITIES, "Loading activities...", 0.6);
      Logger.info("Loading activities");
      const hubActivities = await newClient.getActivities();
      Logger.info(`Loaded ${hubActivities.length} activities`);
      setState(prev => ({ ...prev, activities: hubActivities }));
      // Get current activity
      Logger.info("Getting current activity");
      const current = await newClient.getCurrentActivity();
      setState(prev => ({ ...prev, currentActivity: current }));
      setLoadingState(HarmonyStage.CONNECTED, "Connected successfully", 1);
      Logger.info("Hub setup completed successfully");
    } catch (err) {
      const error = new HarmonyError(
        "Failed to connect to hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      Logger.error("Hub connection failed", error);
    }
  }, [setLoadingState, setError]);
  // Discover hubs
  const discover = useCallback(async () => {
    if (isDiscovering.current) {
      Logger.info("Discovery already in progress, skipping");
      return;
    }
    try {
      isDiscovering.current = true;
      setError(null);
      setLoadingState(HarmonyStage.DISCOVERING, "Searching for Harmony Hubs...", 0.1);
      Logger.info("Starting hub discovery");
      const discoveredHubs = await manager.startDiscovery((progress, message) => {
        setLoadingState(HarmonyStage.DISCOVERING, message, Math.max(0.1, progress));
      });
      if (!isDiscovering.current) {
        Logger.info("Discovery was cancelled");
        return;
      }
      Logger.info(`Discovery completed, found ${discoveredHubs.length} hubs`);
      setState(prev => ({ ...prev, hubs: discoveredHubs }));
      if (discoveredHubs.length === 0) {
        const error = new HarmonyError(
          "No Harmony Hubs found",
          ErrorCategory.HUB_COMMUNICATION
        );
        setError(error);
        setLoadingState(HarmonyStage.ERROR, error.message, 1);
        throw error;
      }
      setLoadingState(HarmonyStage.CONNECTED, "Hubs discovered successfully", 1);
      // If there's only one hub, automatically select it
      if (discoveredHubs.length === 1) {
        Logger.info("Single hub found, auto-selecting");
        await connect(discoveredHubs[0]);
      }
    } catch (err) {
      const error = new HarmonyError(
        "Failed to discover hubs",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      Logger.error("Hub discovery failed", error);
    } finally {
      isDiscovering.current = false;
    }
  }, [connect, setLoadingState, setError]);
  // Disconnect from hub
  const disconnect = useCallback(async () => {
    if (state.client) {
      try {
        await state.client.disconnect();
        setLoadingState(HarmonyStage.INITIAL, "Disconnected", 0);
      } catch (err) {
        const error = new HarmonyError(
          "Failed to disconnect",
          ErrorCategory.HUB_COMMUNICATION,
          err instanceof Error ? err : undefined
        );
        Logger.error("Hub disconnection failed", error);
      } finally {
        setState(prev => ({
          ...prev,
          client: null,
          selectedHub: null,
          devices: [],
          activities: [],
          currentActivity: null,
          error: null
        }));
      }
    }
  }, [state.client, setLoadingState]);
  // Execute a command
  const executeCommand = useCallback(async (command: HarmonyCommand) => {
    if (!state.client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Sending command to hub", { command });
      setLoadingState(HarmonyStage.EXECUTING_COMMAND, `Sending ${command.name}...`, 0.5);
      await state.client.executeCommand(command);
      setLoadingState(HarmonyStage.CONNECTED, "Command sent successfully", 1);
    } catch (err) {
      const error = new HarmonyError(
        "Failed to execute command",
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      throw error;
    }
  }, [state.client, setLoadingState, setError]);
  // Start activity
  const startActivity = useCallback(async (activityId: string) => {
    if (!state.client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      setLoadingState(HarmonyStage.STARTING_ACTIVITY, `Starting activity ${activityId}...`, 0.5);
      await state.client.startActivity(activityId);
      setLoadingState(HarmonyStage.CONNECTED, "Activity started successfully", 1);
    } catch (err) {
      const error = new HarmonyError(
        "Failed to start activity",
        ErrorCategory.ACTIVITY_START,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      throw error;
    }
  }, [state.client, setLoadingState, setError]);
  // Stop activity
  const stopActivity = useCallback(async () => {
    if (!state.client) {
      throw new HarmonyError("No hub selected", ErrorCategory.STATE);
    }
    try {
      setLoadingState(HarmonyStage.STOPPING_ACTIVITY, "Stopping activity...", 0.5);
      await state.client.stopActivity();
      setLoadingState(HarmonyStage.CONNECTED, "Activity stopped successfully", 1);
    } catch (err) {
      const error = new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.ACTIVITY_STOP,
        err instanceof Error ? err : undefined
      );
      setError(error);
      setLoadingState(HarmonyStage.ERROR, error.message, 1);
      throw error;
    }
  }, [state.client, setLoadingState, setError]);
  // Clear cache and rediscover
  const clearCache = useCallback(async () => {
    await disconnect();
    await manager.clearCache();
    await discover();
  }, [disconnect, discover]);
  // Refresh state
  const refresh = useCallback(async () => {
    await discover();
  }, [discover]);
  return {
    ...state,
    connect,
    disconnect,
    refresh,
    executeCommand,
    clearCache,
    startActivity,
    stopActivity,
  };
}
/**
 * Hook for accessing Harmony Hub functionality
 */
export function useHarmony(): HarmonyContextState {
  const context = useContext(HarmonyContext);
  if (!context) {
    throw new Error("useHarmony must be used within a HarmonyProvider");
  }
  return context;
}
</file>

<file path="src/hooks/usePreferences.ts">
/**
 * Hook for accessing and validating preferences
 * @module
 */
import { useMemo } from "react";
import { getPreferenceValues } from "@raycast/api";
import { Preferences } from "../types/preferences";
import { HarmonyError } from "../types/core/errors";
import { ErrorCategory } from "../types/core/harmony";
interface ValidatedPreferences {
  /** Default view to display */
  defaultView: "activities" | "devices";
  /** Cache duration in seconds */
  cacheDuration: number;
  /** Network timeout in milliseconds */
  networkTimeout: number;
  /** Whether debug mode is enabled */
  debugMode: boolean;
  /** Whether to auto-retry failed commands */
  autoRetry: boolean;
  /** Maximum number of retries */
  maxRetries: number;
  /** Duration to hold a command in milliseconds */
  commandHoldTime: number;
}
/**
 * Hook for accessing validated preferences
 */
export function usePreferences() {
  const preferences = getPreferenceValues<Preferences>();
  return useMemo(() => {
    try {
      const cacheDuration = parseInt(preferences.cacheDuration, 10);
      if (isNaN(cacheDuration) || cacheDuration < 0) {
        throw new HarmonyError(
          "Invalid cache duration: must be a positive number",
          ErrorCategory.DATA
        );
      }
      const networkTimeout = parseInt(preferences.networkTimeout, 10);
      if (isNaN(networkTimeout) || networkTimeout < 0) {
        throw new HarmonyError(
          "Invalid network timeout: must be a positive number",
          ErrorCategory.DATA
        );
      }
      const maxRetries = parseInt(preferences.maxRetries, 10);
      if (isNaN(maxRetries) || maxRetries < 0) {
        throw new HarmonyError(
          "Invalid max retries: must be a positive number",
          ErrorCategory.DATA
        );
      }
      const commandHoldTime = parseInt(preferences.commandHoldTime, 10);
      if (isNaN(commandHoldTime) || commandHoldTime < 0) {
        throw new HarmonyError(
          "Invalid command hold time: must be a positive number",
          ErrorCategory.DATA
        );
      }
      const validated: ValidatedPreferences = {
        defaultView: preferences.defaultView,
        cacheDuration,
        networkTimeout,
        debugMode: preferences.debugMode,
        autoRetry: preferences.autoRetry,
        maxRetries,
        commandHoldTime,
      };
      return {
        preferences: validated,
        error: null,
      };
    } catch (error) {
      return {
        preferences: null,
        error: error instanceof HarmonyError ? error : new HarmonyError(
          "Failed to validate preferences",
          ErrorCategory.DATA,
          error instanceof Error ? error : undefined
        ),
      };
    }
  }, [preferences]);
}
</file>

<file path="src/services/harmony/commandQueue.ts">
import { HarmonyCommand, CommandRequest, CommandStatus, CommandResult, CommandQueueConfig } from "../../types/harmony";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import { Logger } from "../logger";
const DEFAULT_CONFIG: Required<CommandQueueConfig> = {
  maxQueueSize: 100,
  maxConcurrent: 1,
  defaultTimeout: 5000,
  defaultRetries: 2,
  commandDelay: 100
};
export type CommandSender = (command: HarmonyCommand) => Promise<void>;
/**
 * Validates command queue configuration
 */
function validateConfig(config: Partial<CommandQueueConfig>): Required<CommandQueueConfig> {
  const result = { ...DEFAULT_CONFIG, ...config };
  // Validate numeric values are positive
  if (result.maxQueueSize <= 0) {
    throw new HarmonyError(
      "maxQueueSize must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (result.maxConcurrent <= 0) {
    throw new HarmonyError(
      "maxConcurrent must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (result.defaultTimeout <= 0) {
    throw new HarmonyError(
      "defaultTimeout must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (result.defaultRetries < 0) {
    throw new HarmonyError(
      "defaultRetries cannot be negative",
      ErrorCategory.VALIDATION
    );
  }
  if (result.commandDelay < 0) {
    throw new HarmonyError(
      "commandDelay cannot be negative",
      ErrorCategory.VALIDATION
    );
  }
  return result;
}
/**
 * Validates a command request
 */
function validateRequest(request: CommandRequest): void {
  if (!request.id) {
    throw new HarmonyError(
      "Command request must have an id",
      ErrorCategory.VALIDATION
    );
  }
  if (!request.command) {
    throw new HarmonyError(
      "Command request must have a command",
      ErrorCategory.VALIDATION
    );
  }
  if (!request.command.id || !request.command.deviceId) {
    throw new HarmonyError(
      "Command must have id and deviceId",
      ErrorCategory.VALIDATION
    );
  }
  if (request.timeout !== undefined && request.timeout <= 0) {
    throw new HarmonyError(
      "Command timeout must be greater than 0",
      ErrorCategory.VALIDATION
    );
  }
  if (request.retries !== undefined && request.retries < 0) {
    throw new HarmonyError(
      "Command retries cannot be negative",
      ErrorCategory.VALIDATION
    );
  }
}
/**
 * Manages command execution queue for Harmony Hub
 */
export class CommandQueue {
  private queue: CommandRequest[] = [];
  private executing: Set<string> = new Set();
  private results: Map<string, CommandResult> = new Map();
  private config: Required<CommandQueueConfig>;
  private commandSender: CommandSender;
  constructor(
    commandSender: CommandSender,
    config?: Partial<CommandQueueConfig>
  ) {
    this.commandSender = commandSender;
    this.config = validateConfig(config || {});
  }
  /**
   * Add a command to the queue
   */
  public async enqueue(request: CommandRequest): Promise<CommandResult> {
    validateRequest(request);
    if (this.queue.length >= this.config.maxQueueSize) {
      throw new HarmonyError(
        `Command queue is full (max size: ${this.config.maxQueueSize})`,
        ErrorCategory.QUEUE
      );
    }
    const result: CommandResult = {
      id: request.id,
      command: request.command,
      status: CommandStatus.QUEUED,
      queuedAt: Date.now()
    };
    this.results.set(request.id, result);
    this.queue.push(request);
    this.processQueue();
    return result;
  }
  /**
   * Process the command queue
   */
  private async processQueue(): Promise<void> {
    if (this.queue.length === 0 || this.executing.size >= this.config.maxConcurrent) {
      return;
    }
    const request = this.queue.shift();
    if (!request) return;
    this.executing.add(request.id);
    const result = this.results.get(request.id);
    if (!result) {
      this.executing.delete(request.id);
      return;
    }
    result.status = CommandStatus.EXECUTING;
    result.startedAt = Date.now();
    try {
      await this.executeCommand(request);
      result.status = CommandStatus.COMPLETED;
      request.onComplete?.();
    } catch (error) {
      result.status = CommandStatus.FAILED;
      result.error = error instanceof Error ? error : new Error(String(error));
      request.onError?.(result.error);
    } finally {
      result.completedAt = Date.now();
      this.executing.delete(request.id);
      this.processQueue();
    }
  }
  /**
   * Execute a single command
   */
  private async executeCommand(request: CommandRequest): Promise<void> {
    const timeout = request.timeout ?? this.config.defaultTimeout;
    const maxRetries = request.retries ?? this.config.defaultRetries;
    let attempts = 0;
    while (attempts <= maxRetries) {
      try {
        Logger.debug(`Executing command (Attempt ${attempts + 1}/${maxRetries + 1})`, {
          command: request.command.name,
          deviceId: request.command.deviceId,
          timeout,
          remainingRetries: maxRetries - attempts
        });
        await Promise.race([
          this.sendCommand(request.command),
          new Promise((_, reject) => 
            setTimeout(() => reject(new HarmonyError(
              `Command execution timed out after ${timeout}ms`,
              ErrorCategory.COMMAND_EXECUTION
            )), timeout)
          )
        ]);
        return;
      } catch (error) {
        attempts++;
        if (attempts > maxRetries) {
          throw new HarmonyError(
            `Command failed after ${attempts} attempts`,
            ErrorCategory.COMMAND_EXECUTION,
            error instanceof Error ? error : undefined
          );
        }
        Logger.warn(`Command failed, retrying (${attempts}/${maxRetries})`, {
          command: request.command.name,
          deviceId: request.command.deviceId,
          error
        });
        await new Promise(resolve => 
          setTimeout(resolve, this.config.commandDelay)
        );
      }
    }
  }
  /**
   * Send command to the hub
   */
  private async sendCommand(command: HarmonyCommand): Promise<void> {
    try {
      await this.commandSender(command);
    } catch (error) {
      throw new HarmonyError(
        "Failed to send command to hub",
        ErrorCategory.HUB_COMMUNICATION,
        error instanceof Error ? error : undefined
      );
    }
  }
  /**
   * Get the result of a command
   */
  public getResult(commandId: string): CommandResult | undefined {
    return this.results.get(commandId);
  }
  /**
   * Clear completed commands from results
   */
  public clearCompleted(): void {
    for (const [id, result] of this.results.entries()) {
      if (result.status === CommandStatus.COMPLETED || 
          result.status === CommandStatus.FAILED ||
          result.status === CommandStatus.CANCELLED) {
        this.results.delete(id);
      }
    }
  }
  /**
   * Cancel all pending commands
   */
  public cancelAll(): void {
    this.queue.forEach(request => {
      const result = this.results.get(request.id);
      if (result) {
        result.status = CommandStatus.CANCELLED;
        result.completedAt = Date.now();
      }
    });
    this.queue = [];
  }
  /**
   * Get current queue status
   */
  public getStatus(): {
    queueLength: number;
    executing: number;
    completed: number;
    failed: number;
  } {
    let completed = 0;
    let failed = 0;
    for (const result of this.results.values()) {
      if (result.status === CommandStatus.COMPLETED) completed++;
      if (result.status === CommandStatus.FAILED) failed++;
    }
    return {
      queueLength: this.queue.length,
      executing: this.executing.size,
      completed,
      failed
    };
  }
}
</file>

<file path="src/services/harmony/harmonyClient.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity, HarmonyCommand } from "../../types/harmony";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import { Logger } from "../logger";
import getHarmonyClient from "@harmonyhub/client-ws";
import { getPreferenceValues, LocalStorage } from "@raycast/api";
// Cache constants
const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours
interface CachedConfig {
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  timestamp: number;
}
interface HarmonyHubConfig {
  device: Array<{
    id: string;
    name: string;
    type: string;
    commands: Array<{
      name: string;
      label?: string;
      action?: {
        command?: {
          type?: string;
        };
      };
    }>;
  }>;
}
interface HarmonyHubActivity {
  id: string;
  label: string;
  type: string;
}
interface HarmonyHubCurrentActivity {
  id: string;
}
interface HarmonyCommandBody {
  command: string;
  deviceId: string;
  type: string;
}
interface CommandFunction {
  name: string;
  label?: string;
  action?: {
    command?: string;
  };
}
interface CommandGroup {
  name: string;
  function: CommandFunction[];
}
interface ControlGroup {
  name: string;
  function: CommandFunction[];
}
interface RawDevice {
  id: string;
  label?: string;
  type?: string;
  controlGroup: ControlGroup[];
}
interface RawConfig {
  device: RawDevice[];
}
export class HarmonyClient {
  private client: Awaited<ReturnType<typeof getHarmonyClient>> | null = null;
  private isConnected = false;
  public readonly hub: HarmonyHub;
  private cacheKey: string;
  constructor(hub: HarmonyHub) {
    this.hub = hub;
    this.cacheKey = `harmony-config-${hub.hubId}`;
  }
  /**
   * Connect to the Harmony Hub
   */
  public async connect(): Promise<void> {
    if (this.isConnected) {
      Logger.info(`Already connected to hub ${this.hub.name}`);
      return;
    }
    try {
      Logger.info(`Initiating connection to hub ${this.hub.name} (${this.hub.ip})`);
      // Create client with remoteId if available for faster connection
      Logger.debug("Creating Harmony client", {
        hubIp: this.hub.ip,
        hubId: this.hub.hubId,
        remoteId: this.hub.remoteId
      });
      this.client = await getHarmonyClient(this.hub.ip);
      this.isConnected = true;
      Logger.info(`Successfully connected to hub ${this.hub.name}`);
      // Setup disconnect handler
      this.client?.on("disconnected", () => {
        Logger.warn(`Disconnected from hub ${this.hub.name}`);
        this.isConnected = false;
      });
      // Verify connection by attempting to get config
      Logger.debug("Verifying connection by fetching initial config");
      await this.getDevicesFromHub();
      Logger.info("Connection verified successfully");
    } catch (err) {
      this.isConnected = false;
      this.client = null;
      const error = new HarmonyError(
        `Failed to connect to hub ${this.hub.name}`,
        ErrorCategory.CONNECTION,
        err instanceof Error ? err : undefined
      );
      Logger.error("Connection failed", {
        error: error.getDetailedMessage(),
        hubName: this.hub.name,
        hubIp: this.hub.ip
      });
      throw error;
    }
  }
  /**
   * Get devices from the hub
   */
  public async getDevices(): Promise<HarmonyDevice[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.devices) {
        Logger.info("Using cached devices for hub", this.hub.name);
        return cached.devices;
      }
      // Get from hub if not cached
      const rawDevices = await this.getDevicesFromHub();
      const mappedDevices = rawDevices.map(device => ({
        id: device.id,
        name: device.label || device.id,
        type: device.type || "Unknown",
        commands: device.controlGroup.flatMap(group => 
          group.function.map(fn => ({
            id: fn.name,
            name: fn.name,
            label: fn.label || fn.name,
            deviceId: device.id,
            group: fn.action?.command || "IRCommand"
          }))
        )
      })) as HarmonyDevice[];
      // Cache the new devices along with current activities
      await this.updateConfigCache(mappedDevices, await this.getActivitiesFromHub());
      return mappedDevices;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
    }
  }
  private async getDevicesFromHub(): Promise<RawDevice[]> {
    if (!this.client) {
      throw new HarmonyError(
        "Client not initialized",
        ErrorCategory.CONNECTION
      );
    }
    try {
      Logger.info("Fetching devices from hub", this.hub.name);
      const rawConfig = await this.client.getAvailableCommands() as RawConfig;
      if (!rawConfig.device || rawConfig.device.length === 0) {
        Logger.warn("No devices found in hub config");
        return [];
      }
      Logger.info(`Found ${rawConfig.device.length} devices`);
      // Log raw config structure for first device
      if (rawConfig.device[0]) {
        Logger.info("First device raw config:", JSON.stringify(rawConfig.device[0], null, 2));
      }
      return rawConfig.device;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get devices from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err))
      );
    }
  }
  /**
   * Get activities from the hub
   */
  public async getActivities(): Promise<HarmonyActivity[]> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      // Try to get from cache first
      const cached = await this.getCachedConfig();
      if (cached?.activities) {
        Logger.info("Using cached activities for hub", this.hub.name);
        return cached.activities;
      }
      // Get from hub if not cached
      const activities = await this.getActivitiesFromHub();
      // Cache the new activities along with current devices
      await this.updateConfigCache(await this.getDevices(), activities);
      return activities;
    } catch (err) {
      throw new HarmonyError(
        "Failed to get activities",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Get activities directly from hub
   */
  private async getActivitiesFromHub(): Promise<HarmonyActivity[]> {
    if (!this.client) {
      throw new HarmonyError(
        "Client not initialized",
        ErrorCategory.CONNECTION
      );
    }
    const activities = await this.client.getActivities() as HarmonyHubActivity[];
    return activities.map(activity => ({
      id: activity.id,
      name: activity.label,
      type: activity.type,
      isCurrent: false // Will be updated by current activity check
    }));
  }
  /**
   * Get current activity from hub
   */
  public async getCurrentActivity(): Promise<HarmonyActivity | null> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const rawActivity = await this.client.getCurrentActivity();
      if (!rawActivity) {
        return null;
      }
      // Convert raw activity string to proper type
      const currentActivityId = String(rawActivity);
      // Get all activities to find the current one
      const activities = await this.getActivities();
      const activity = activities.find(a => a.id === currentActivityId);
      if (!activity) {
        return null;
      }
      return {
        ...activity,
        isCurrent: true
      };
    } catch (err) {
      throw new HarmonyError(
        "Failed to get current activity",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err))
      );
    }
  }
  /**
   * Start an activity
   */
  public async startActivity(activityId: string): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Starting activity", { activityId });
      await this.client.startActivity(activityId);
      // Wait for activity to start and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const currentActivity = await this.getCurrentActivity();
        if (currentActivity?.id === activityId) {
          Logger.debug("Activity started successfully", { activityId });
          return;
        }
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to start");
    } catch (err) {
      throw new HarmonyError(
        `Failed to start activity ${activityId}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Stop the current activity
   */
  public async stopActivity(): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      Logger.debug("Stopping current activity");
      const currentActivity = await this.getCurrentActivity();
      if (!currentActivity) {
        Logger.debug("No activity running");
        return;
      }
      await this.client.turnOff();
      // Wait for activity to stop and verify
      const startTime = Date.now();
      const maxWaitTime = 10000; // 10 seconds max wait
      while (Date.now() - startTime < maxWaitTime) {
        const activity = await this.getCurrentActivity();
        if (!activity) {
          Logger.debug("Activity stopped successfully");
          return;
        }
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      throw new Error("Timeout waiting for activity to stop");
    } catch (err) {
      throw new HarmonyError(
        "Failed to stop activity",
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Clear cached config for this hub
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info(`Clearing cache for hub ${this.hub.name}`);
      await LocalStorage.removeItem(this.cacheKey);
    } catch (err) {
      throw new HarmonyError(
        "Failed to clear cache",
        ErrorCategory.CACHE,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Get cached config if available and not expired
   */
  private async getCachedConfig(): Promise<CachedConfig | null> {
    try {
      const cached = await LocalStorage.getItem<string>(this.cacheKey);
      if (!cached) {
        return null;
      }
      const config = JSON.parse(cached) as CachedConfig;
      // Check if cache is expired
      if (Date.now() - config.timestamp > CACHE_EXPIRY) {
        Logger.info("Config cache expired for hub", this.hub.name);
        await LocalStorage.removeItem(this.cacheKey);
        return null;
      }
      return config;
    } catch (err) {
      Logger.warn("Failed to get cached config:", err);
      return null;
    }
  }
  /**
   * Update the config cache with new devices and activities
   */
  private async updateConfigCache(devices: HarmonyDevice[], activities: HarmonyActivity[]): Promise<void> {
    try {
      const cache: CachedConfig = {
        devices,
        activities,
        timestamp: Date.now()
      };
      await LocalStorage.setItem(this.cacheKey, JSON.stringify(cache));
      Logger.info("Cached config for hub", this.hub.name);
    } catch (err) {
      Logger.warn("Failed to cache config:", err);
    }
  }
  /**
   * Execute a command
   */
  public async executeCommand(command: HarmonyCommand): Promise<void> {
    if (!this.client || !this.isConnected) {
      throw new HarmonyError("Not connected to hub", ErrorCategory.STATE);
    }
    try {
      const preferences = getPreferenceValues<{ commandHoldTime: string }>();
      const holdTime = parseInt(preferences.commandHoldTime || "100", 10);
      Logger.debug("Sending command to hub", { command });
      const commandBody: HarmonyCommandBody = {
        command: command.id,
        deviceId: command.deviceId,
        type: command.group || "IRCommand"
      };
      Logger.debug("Command body:", commandBody);
      // Send press action
      await this.client.send("holdAction", commandBody);
      // Wait for hold time
      await new Promise(resolve => setTimeout(resolve, holdTime));
      // Send release action
      await this.client.send("releaseAction", commandBody);
    } catch (err) {
      throw new HarmonyError(
        `Failed to execute command ${command.name}`,
        ErrorCategory.COMMAND_EXECUTION,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Disconnect from the hub
   */
  public async disconnect(): Promise<void> {
    try {
      if (this.client && this.isConnected) {
        await this.client.end();
        this.isConnected = false;
        this.client = null;
      }
    } catch (err) {
      throw new HarmonyError(
        "Failed to disconnect from hub",
        ErrorCategory.HUB_COMMUNICATION,
        err instanceof Error ? err : new Error(String(err))
      );
    }
  }
}
</file>

<file path="src/services/harmony/harmonyManager.ts">
import { Explorer } from "@harmonyhub/discover";
import { HarmonyHub } from "../../types/harmony";
import { Logger } from "../logger";
import { LocalStorage, showToast, Toast } from "@raycast/api";
import { HarmonyError, ErrorCategory } from "../../types/core/errors";
import { HarmonyClient } from "../../services/harmony/harmonyClient";
// Constants
const DISCOVERY_TIMEOUT = 5000; // Reduced from 10s to 5s
const DISCOVERY_COMPLETE_DELAY = 500; // Wait 500ms after finding a hub before completing
const CACHE_KEY = "harmony-hubs";
const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours
interface CachedHubs {
  hubs: HarmonyHub[];
  timestamp: number;
}
// Hub data from discovery event
interface HubDiscoveryData {
  uuid: string;
  ip: string;
  friendlyName: string;
  fullHubInfo: {
    hubId: string;
    productId: string;
    current_fw_version: string;
    protocolVersion: string;
    port: string;
    remoteId: string;
  };
}
export class HarmonyManager {
  private explorer: Explorer | null = null;
  private isDiscovering = false;
  private discoveryPromise: Promise<HarmonyHub[]> | null = null;
  private completeTimeout: NodeJS.Timeout | null = null;
  /**
   * Create a HarmonyHub instance from discovery data
   */
  private createHub(data: HubDiscoveryData): HarmonyHub {
    // Validate required fields
    if (!data.friendlyName || !data.ip || !data.uuid || !data.fullHubInfo?.hubId) {
      throw new HarmonyError(
        "Invalid hub data received",
        ErrorCategory.VALIDATION,
        new Error(`Missing required fields: ${JSON.stringify(data)}`)
      );
    }
    return {
      id: data.uuid,
      name: data.friendlyName,
      ip: data.ip,
      hubId: data.fullHubInfo.hubId,
      remoteId: data.fullHubInfo.remoteId,
      version: data.fullHubInfo.current_fw_version,
      port: data.fullHubInfo.port,
      productId: data.fullHubInfo.productId,
      protocolVersion: data.fullHubInfo.protocolVersion
    };
  }
  /**
   * Start discovery of Harmony Hubs on the network
   */
  public async startDiscovery(
    onProgress?: (progress: number, message: string) => void
  ): Promise<HarmonyHub[]> {
    // Check cache first
    try {
      const cached = await this.getCachedHubs();
      if (cached) {
        Logger.info(`Found ${cached.length} cached hubs`);
        onProgress?.(1, `Found ${cached.length} cached hub(s)`);
        // Verify each cached hub is still accessible
        Logger.debug("Verifying cached hubs are accessible");
        const verifiedHubs: HarmonyHub[] = [];
        for (const hub of cached) {
          try {
            const client = new HarmonyClient(hub);
            await client.connect();
            await client.disconnect();
            verifiedHubs.push(hub);
            Logger.info(`Verified hub ${hub.name} is accessible`);
          } catch (err) {
            Logger.warn(`Cached hub ${hub.name} is no longer accessible, will be removed from cache`, err);
          }
        }
        if (verifiedHubs.length > 0) {
          Logger.info(`${verifiedHubs.length} of ${cached.length} cached hubs verified`);
          if (verifiedHubs.length !== cached.length) {
            // Update cache with only verified hubs
            await this.cacheHubs(verifiedHubs);
          }
          if (verifiedHubs.length === 1) {
            const hub = verifiedHubs[0];
            await showToast({
              style: Toast.Style.Success,
              title: "Auto-connecting to Hub",
              message: `Found single Harmony Hub: ${hub.name}`
            });
          }
          return verifiedHubs;
        }
        Logger.info("No cached hubs are accessible, proceeding with discovery");
      }
    } catch (error) {
      Logger.warn("Failed to read cache:", error);
      // Continue with discovery even if cache read fails
    }
    // If discovery is already in progress, return the existing promise
    if (this.discoveryPromise) {
      Logger.info("Discovery already in progress, returning existing promise");
      return this.discoveryPromise;
    }
    try {
      // Ensure cleanup of any previous explorer
      await this.cleanup();
      this.isDiscovering = true;
      onProgress?.(0, "Starting discovery process");
      Logger.info("Starting hub discovery process");
      this.explorer = new Explorer();
      // Create and store the discovery promise
      this.discoveryPromise = new Promise<HarmonyHub[]>((resolve, reject) => {
        if (!this.explorer) {
          const error = new HarmonyError("Explorer not initialized", ErrorCategory.STATE);
          Logger.error("Discovery failed - explorer not initialized");
          reject(error);
          return;
        }
        const hubs: HarmonyHub[] = [];
        // Function to complete discovery
        const completeDiscovery = async () => {
          await this.cleanup();
          if (hubs.length > 0) {
            Logger.info(`Discovery completed successfully, found ${hubs.length} hubs`);
            await this.cacheHubs(hubs);
          } else {
            Logger.warn("Discovery completed but no hubs were found");
          }
          resolve(hubs);
        };
        // Set timeout to stop discovery after DISCOVERY_TIMEOUT
        const timeout = setTimeout(async () => {
          Logger.info("Discovery timeout reached");
          await completeDiscovery();
        }, DISCOVERY_TIMEOUT);
        this.explorer.on("online", (data: HubDiscoveryData) => {
          try {
            Logger.debug("Received hub data", { data });
            const hub = this.createHub(data);
            // Check for duplicate hubs
            if (!hubs.some(h => h.hubId === hub.hubId)) {
              hubs.push(hub);
              Logger.info(`Found hub: ${hub.name} (${hub.ip})`);
              onProgress?.(0.5, `Found hub: ${hub.name}`);
              // Clear any existing completion timeout
              if (this.completeTimeout) {
                clearTimeout(this.completeTimeout);
              }
              // Set a new completion timeout
              this.completeTimeout = setTimeout(async () => {
                clearTimeout(timeout);
                await completeDiscovery();
              }, DISCOVERY_COMPLETE_DELAY);
            } else {
              Logger.info(`Skipping duplicate hub: ${hub.name} (${hub.ip})`);
            }
          } catch (error) {
            Logger.error("Failed to process hub data:", error);
            // Don't reject here, just log and continue discovery
          }
        });
        this.explorer.on("error", async (error: Error) => {
          Logger.error("Discovery error:", error);
          clearTimeout(timeout);
          if (this.completeTimeout) {
            clearTimeout(this.completeTimeout);
          }
          await this.cleanup();
          reject(new HarmonyError(
            "Hub discovery failed",
            ErrorCategory.HUB_COMMUNICATION,
            error
          ));
        });
        // Start discovery
        Logger.debug("Starting explorer");
        this.explorer.start();
      });
      // Return the discovery promise
      return await this.discoveryPromise;
    } catch (error) {
      Logger.error("Failed to start discovery:", error);
      throw new HarmonyError(
        "Failed to start hub discovery",
        ErrorCategory.HUB_COMMUNICATION,
        error as Error
      );
    } finally {
      this.isDiscovering = false;
      this.discoveryPromise = null;
    }
  }
  /**
   * Cache discovered hubs
   */
  private async cacheHubs(hubs: HarmonyHub[]): Promise<void> {
    try {
      const cache: CachedHubs = {
        hubs,
        timestamp: Date.now()
      };
      await LocalStorage.setItem(CACHE_KEY, JSON.stringify(cache));
      Logger.info(`Cached ${hubs.length} hubs`);
    } catch (error) {
      Logger.warn("Failed to cache hubs:", error);
      throw new HarmonyError(
        "Failed to cache hubs",
        ErrorCategory.STORAGE,
        error as Error
      );
    }
  }
  /**
   * Get cached hubs if available and not expired
   */
  private async getCachedHubs(): Promise<HarmonyHub[] | null> {
    try {
      const cached = await LocalStorage.getItem<string>(CACHE_KEY);
      if (!cached) return null;
      const { hubs, timestamp } = JSON.parse(cached) as CachedHubs;
      // Check if cache is expired
      if (Date.now() - timestamp > CACHE_TTL) {
        Logger.info("Cache expired");
        await LocalStorage.removeItem(CACHE_KEY);
        return null;
      }
      // Validate cached hub data
      for (const hub of hubs) {
        if (!hub.id || !hub.name || !hub.ip || !hub.hubId) {
          Logger.warn("Invalid hub data in cache, clearing cache");
          await LocalStorage.removeItem(CACHE_KEY);
          return null;
        }
      }
      return hubs;
    } catch (error) {
      Logger.warn("Failed to get cached hubs:", error);
      throw new HarmonyError(
        "Failed to read hub cache",
        ErrorCategory.STORAGE,
        error as Error
      );
    }
  }
  /**
   * Clean up discovery resources
   */
  public async cleanup(): Promise<void> {
    if (this.explorer) {
      try {
        this.explorer.stop();
        this.explorer.removeAllListeners();
      } catch (error) {
        Logger.error("Error stopping explorer:", error);
      }
      this.explorer = null;
    }
    if (this.completeTimeout) {
      clearTimeout(this.completeTimeout);
      this.completeTimeout = null;
    }
    this.isDiscovering = false;
    this.discoveryPromise = null;
  }
  /**
   * Clear all caches (hub discovery and configs)
   */
  public async clearAllCaches(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub discovery cache
      await this.clearCache();
      // Clear all hub config caches
      const keys = await LocalStorage.allItems();
      for (const key of Object.keys(keys)) {
        if (key.startsWith('harmony-config-')) {
          await LocalStorage.removeItem(key);
        }
      }
    } catch (err) {
      throw new HarmonyError(
        "Failed to clear caches",
        ErrorCategory.CACHE,
        err instanceof Error ? err : undefined
      );
    }
  }
  /**
   * Clear all cached data
   */
  public async clearCache(): Promise<void> {
    try {
      Logger.info("Clearing all Harmony caches");
      // Clear hub cache
      await LocalStorage.removeItem(CACHE_KEY);
      // Clear all hub-specific config caches
      const allKeys = await LocalStorage.allItems();
      for (const key of Object.keys(allKeys)) {
        if (key.startsWith('harmony-config-')) {
          await LocalStorage.removeItem(key);
        }
      }
      Logger.info("All caches cleared");
    } catch (error) {
      Logger.error("Failed to clear caches:", error);
      throw new HarmonyError(
        "Failed to clear caches",
        ErrorCategory.STORAGE,
        error as Error
      );
    }
  }
}
</file>

<file path="src/services/harmony/harmonyState.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "../../types/harmony";
/**
 * State machine stages for Harmony operations
 */
export enum HarmonyStage {
  DISCOVERING = "discovering",
  CONNECTING = "connecting",
  LOADING_ACTIVITIES = "loading-activities",
  LOADING_DEVICES = "loading-devices",
  COMPLETE = "complete",
}
/**
 * Loading state information
 */
export interface LoadingState {
  stage: HarmonyStage;
  progress: number;
  message: string;
}
/**
 * Core state for Harmony operations
 */
export interface HarmonyState {
  hubs: HarmonyHub[];
  devices: HarmonyDevice[];
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  selectedHub: HarmonyHub | null;
  error: Error | null;
}
/**
 * Initial loading state
 */
export const initialLoadingState: LoadingState = {
  stage: HarmonyStage.DISCOVERING,
  progress: 0,
  message: "Initializing...",
};
/**
 * Initial harmony state
 */
export const initialHarmonyState: HarmonyState = {
  hubs: [],
  devices: [],
  activities: [],
  currentActivity: null,
  selectedHub: null,
  error: null,
};
</file>

<file path="src/services/error-handler.ts">
/**
 * Error handling utilities for Harmony Hub integration
 * @module
 */
import { showToast, Toast } from "@raycast/api";
import { Logger } from "./logger";
import {
  HarmonyError,
  ErrorCategory,
  ErrorSeverity,
  ErrorRecoveryAction,
} from "../types/core/errors";
/**
 * Configuration for error handling
 */
interface ErrorHandlerConfig {
  /** Whether to show toasts for errors */
  showToasts: boolean;
  /** Whether to log errors */
  logErrors: boolean;
  /** Default error category if none is specified */
  defaultCategory: ErrorCategory;
  /** Default error severity if none is specified */
  defaultSeverity: ErrorSeverity;
}
/**
 * Default configuration for error handling
 */
const defaultConfig: ErrorHandlerConfig = {
  showToasts: true,
  logErrors: true,
  defaultCategory: ErrorCategory.DATA,
  defaultSeverity: ErrorSeverity.ERROR,
};
/**
 * ErrorHandler class for consistent error handling across the application.
 * Provides methods for handling errors, showing user feedback, and logging.
 */
export class ErrorHandler {
  private static config: ErrorHandlerConfig = defaultConfig;
  /**
   * Configure the error handler
   * @param config - Partial configuration to merge with defaults
   */
  static configure(config: Partial<ErrorHandlerConfig>): void {
    ErrorHandler.config = { ...defaultConfig, ...config };
  }
  /**
   * Handle any type of error, converting it to a HarmonyError if needed
   * @param error - The error to handle
   * @param context - Optional context information
   * @param category - Optional error category
   */
  static handle(
    error: Error | unknown,
    context?: string,
    category?: ErrorCategory
  ): void {
    const harmonyError = ErrorHandler.toHarmonyError(error, category);
    // Log the error if enabled
    if (ErrorHandler.config.logErrors) {
      Logger.logError(harmonyError, context);
    }
    // Show user feedback if enabled
    if (ErrorHandler.config.showToasts) {
      ErrorHandler.showErrorToast(harmonyError);
    }
  }
  /**
   * Handle an async operation with proper error handling
   * @param operation - The async operation to handle
   * @param context - Optional context information
   * @param category - Optional error category
   */
  static async handleAsync<T>(
    operation: () => Promise<T>,
    context?: string,
    category?: ErrorCategory
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handle(error, context, category);
      throw error;
    }
  }
  /**
   * Convert any error to a HarmonyError
   * @param error - The error to convert
   * @param category - Optional error category
   */
  private static toHarmonyError(
    error: Error | unknown,
    category?: ErrorCategory
  ): HarmonyError {
    if (error instanceof HarmonyError) {
      return error;
    }
    const message = error instanceof Error ? error.message : String(error);
    const cause = error instanceof Error ? error : undefined;
    return new HarmonyError(
      message,
      category || ErrorHandler.config.defaultCategory,
      cause
    );
  }
  /**
   * Show an error toast to the user
   * @param error - The error to show
   */
  private static showErrorToast(error: HarmonyError): void {
    const title = ErrorHandler.getCategoryTitle(error.category);
    const message = error.getUserMessage();
    showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Get a user-friendly title for an error category
   * @param category - The error category
   */
  private static getCategoryTitle(category: ErrorCategory): string {
    switch (category) {
      case ErrorCategory.CONNECTION:
        return "Connection Error";
      case ErrorCategory.DISCOVERY:
        return "Discovery Error";
      case ErrorCategory.COMMAND:
        return "Command Error";
      case ErrorCategory.STATE:
        return "State Error";
      case ErrorCategory.DATA:
        return "Data Error";
      case ErrorCategory.HUB_COMMUNICATION:
        return "Hub Communication Error";
      default:
        return "Error";
    }
  }
  /**
   * Get recovery actions for an error
   * @param error - The error to get recovery actions for
   */
  static getRecoveryActions(error: HarmonyError): ErrorRecoveryAction[] {
    const actions: ErrorRecoveryAction[] = [];
    switch (error.category) {
      case ErrorCategory.CONNECTION:
        actions.push(
          ErrorRecoveryAction.RETRY,
          ErrorRecoveryAction.RECONNECT
        );
        break;
      case ErrorCategory.DISCOVERY:
        actions.push(
          ErrorRecoveryAction.RETRY,
          ErrorRecoveryAction.CLEAR_CACHE
        );
        break;
      case ErrorCategory.COMMAND:
        actions.push(ErrorRecoveryAction.RETRY);
        break;
      case ErrorCategory.STATE:
        actions.push(
          ErrorRecoveryAction.RESET_CONFIG,
          ErrorRecoveryAction.RESTART
        );
        break;
      case ErrorCategory.DATA:
        actions.push(
          ErrorRecoveryAction.RETRY,
          ErrorRecoveryAction.CLEAR_CACHE
        );
        break;
      case ErrorCategory.HUB_COMMUNICATION:
        actions.push(
          ErrorRecoveryAction.RETRY,
          ErrorRecoveryAction.RECONNECT,
          ErrorRecoveryAction.CLEAR_CACHE
        );
        break;
      default:
        actions.push(ErrorRecoveryAction.MANUAL);
    }
    return actions;
  }
  /**
   * Show a success toast
   * @param title - The toast title
   * @param message - Optional toast message
   */
  static showSuccess(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  /**
   * Show a warning toast
   * @param title - The toast title
   * @param message - Optional toast message
   */
  static showWarning(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Show a loading toast
   * @param title - The toast title
   * @param message - Optional toast message
   */
  static showLoading(title: string, message?: string): void {
    if (!ErrorHandler.config.showToasts) return;
    showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
}
</file>

<file path="src/services/errorHandler.ts">
import { showToast, Toast } from "@raycast/api";
import { Logger } from "./logger";
import {
  HarmonyError,
  ErrorCategory,
  ErrorSeverity,
  ErrorRecoveryAction,
} from "../types/core/errors";
/**
 * ErrorHandler class for consistent error handling across the application.
 * Provides methods for handling errors, showing user feedback, and logging.
 */
export class ErrorHandler {
  /**
   * Handle any type of error, converting it to a HarmonyError if needed
   */
  static handle(error: Error | unknown, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error);
    // Log the error
    Logger.logError(harmonyError, context);
    // Show user feedback
    ErrorHandler.showErrorToast(harmonyError);
  }
  /**
   * Handle a specific error with a category
   */
  static handleWithCategory(error: Error | unknown, category: ErrorCategory, context?: string): void {
    const harmonyError = ErrorHandler.toHarmonyError(error, category);
    // Log the error
    Logger.logError(harmonyError, context);
    // Show user feedback
    ErrorHandler.showErrorToast(harmonyError);
  }
  /**
   * Convert any error to a HarmonyError
   */
  private static toHarmonyError(error: Error | unknown, category?: ErrorCategory): HarmonyError {
    if (error instanceof HarmonyError) {
      return error;
    }
    const defaultCategory = category || ErrorCategory.UNKNOWN;
    const message = error instanceof Error ? error.message : String(error);
    const originalError = error instanceof Error ? error : undefined;
    return new HarmonyError(message, defaultCategory, originalError);
  }
  /**
   * Show an error toast to the user
   */
  private static showErrorToast(error: HarmonyError): void {
    const title = ErrorHandler.getCategoryTitle(error.category);
    showToast({
      style: Toast.Style.Failure,
      title,
      message: error.message,
    });
  }
  /**
   * Get a user-friendly title for an error category
   */
  private static getCategoryTitle(category: ErrorCategory): string {
    switch (category) {
      case ErrorCategory.NETWORK:
        return "Network Error";
      case ErrorCategory.STORAGE:
        return "Storage Error";
      case ErrorCategory.HARMONY:
        return "Harmony Hub Error";
      case ErrorCategory.VALIDATION:
        return "Validation Error";
      case ErrorCategory.WEBSOCKET:
        return "Connection Error";
      case ErrorCategory.COMMAND:
        return "Command Error";
      case ErrorCategory.AUTHENTICATION:
        return "Authentication Error";
      case ErrorCategory.SYSTEM:
        return "System Error";
      default:
        return "Error";
    }
  }
  /**
   * Handle an async operation with proper error handling
   */
  static async handleAsync<T>(
    operation: () => Promise<T>,
    context?: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handle(error, context);
      throw error;
    }
  }
  /**
   * Handle an async operation with a specific error category
   */
  static async handleAsyncWithCategory<T>(
    operation: () => Promise<T>,
    category: ErrorCategory,
    context?: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      ErrorHandler.handleWithCategory(error, category, context);
      throw error;
    }
  }
}
</file>

<file path="src/services/localStorage.ts">
import { LocalStorage as RaycastLocalStorage } from "@raycast/api";
import { Logger } from "./logger";
export class LocalStorage {
  public static async getItem(key: string): Promise<string | null> {
    try {
      const value = await RaycastLocalStorage.getItem(key);
      return typeof value === 'string' ? value : null;
    } catch (error) {
      Logger.error(`Failed to get item from storage: ${key}`, error);
      return null;
    }
  }
  public static async setItem(key: string, value: string): Promise<void> {
    try {
      await RaycastLocalStorage.setItem(key, value);
    } catch (error) {
      Logger.error(`Failed to set item in storage: ${key}`, error);
      throw error;
    }
  }
  public static async removeItem(key: string): Promise<void> {
    try {
      await RaycastLocalStorage.removeItem(key);
    } catch (error) {
      Logger.error(`Failed to remove item from storage: ${key}`, error);
      throw error;
    }
  }
  public static async clear(): Promise<void> {
    try {
      await RaycastLocalStorage.clear();
    } catch (error) {
      Logger.error("Failed to clear storage", error);
      throw error;
    }
  }
}
</file>

<file path="src/services/logger.ts">
/**
 * Logger service for Harmony Hub extension
 * @module
 */
/**
 * Logger interface
 */
export const Logger = {
  debug: (message: string, ...args: any[]) => {
    console.debug(`[DEBUG] ${message}`, ...args);
  },
  info: (message: string, ...args: any[]) => {
    console.info(`[INFO] ${message}`, ...args);
  },
  warn: (message: string, ...args: any[]) => {
    console.warn(`[WARN] ${message}`, ...args);
  },
  error: (message: string, ...args: any[]) => {
    console.error(`[ERROR] ${message}`, ...args);
  },
  logError: (error: Error, context?: string) => {
    const message = context ? `${context}: ${error.message}` : error.message;
    console.error(`[ERROR] ${message}`, {
      name: error.name,
      stack: error.stack,
      error,
    });
  }
} as const;
export type LoggerType = typeof Logger;
</file>

<file path="src/services/secure-storage.ts">
// External dependencies
import { getPreferenceValues, LocalStorage } from "@raycast/api";
import crypto from "crypto";
import { Preferences } from "../types/preferences";
import { ErrorCategory, HarmonyError } from "../types/core/errors";
// Core services
import { ErrorHandler } from "./errorHandler";
import { HarmonyHub } from "../types/harmony";
import { Logger } from "./logger";
/**
 * Secure storage implementation for sensitive data.
 * Uses Raycast's LocalStorage with encryption for sensitive data.
 */
export class SecureStorage {
  private static instance: SecureStorage;
  private readonly ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || "default-key-32-chars-12345678901";
  private readonly ALGORITHM = "aes-256-cbc";
  private readonly errorHandler = new ErrorHandler();
  /**
   * Gets the singleton instance of SecureStorage.
   * @returns {SecureStorage} The singleton instance
   */
  public static getInstance(): SecureStorage {
    if (!SecureStorage.instance) {
      SecureStorage.instance = new SecureStorage();
    }
    return SecureStorage.instance;
  }
  /**
   * Stores a value securely.
   *
   * @param key - Storage key
   * @param value - Value to store
   * @returns Promise<void>
   * @throws {Error} If storage fails
   *
   * @example
   * ```typescript
   * await secureStorage.set("api_key", "secret_key_123");
   * ```
   */
  public async set(key: string, value: string): Promise<void> {
    try {
      const iv = crypto.randomBytes(16);
      const cipher = crypto.createCipheriv(this.ALGORITHM, Buffer.from(this.ENCRYPTION_KEY), iv);
      let encrypted = cipher.update(value);
      encrypted = Buffer.concat([encrypted, cipher.final()]);
      await LocalStorage.setItem(
        key,
        JSON.stringify({
          iv: iv.toString("hex"),
          data: encrypted.toString("hex"),
        }),
      );
      Logger.debug("Stored value in secure storage", { key });
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to store value in secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Retrieves a value from secure storage.
   *
   * @param key - Storage key
   * @returns Promise<string | null> The stored value or null if not found
   * @throws {Error} If retrieval fails
   *
   * @example
   * ```typescript
   * const value = await secureStorage.get("api_key");
   * ```
   */
  public async get(key: string): Promise<string | null> {
    try {
      const item = await LocalStorage.getItem(key);
      if (!item) return null;
      const parsedItem = JSON.parse(item as string);
      const { iv, data } = parsedItem;
      const decipher = crypto.createDecipheriv(
        this.ALGORITHM,
        Buffer.from(this.ENCRYPTION_KEY),
        Buffer.from(iv, "hex"),
      );
      let decrypted = decipher.update(Buffer.from(data, "hex"));
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      Logger.debug("Retrieved value from secure storage", { key });
      return decrypted.toString();
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to retrieve value from secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Removes a value from secure storage.
   *
   * @param key - Storage key
   * @returns Promise<void>
   * @throws {Error} If removal fails
   *
   * @example
   * ```typescript
   * await secureStorage.remove("api_key");
   * ```
   */
  public async remove(key: string): Promise<void> {
    try {
      await LocalStorage.removeItem(key);
      Logger.debug("Removed value from secure storage", { key });
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to remove value from secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Clears all values from secure storage.
   *
   * @returns Promise<void>
   * @throws {Error} If clear operation fails
   *
   * @example
   * ```typescript
   * await secureStorage.clear();
   * ```
   */
  public async clear(): Promise<void> {
    try {
      await LocalStorage.clear();
      Logger.debug("Cleared all secure storage");
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to clear secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Checks if a key exists in secure storage.
   *
   * @param key - Storage key
   * @returns Promise<boolean> True if the key exists
   * @throws {Error} If check fails
   *
   * @example
   * ```typescript
   * const exists = await secureStorage.has("api_key");
   * ```
   */
  public async has(key: string): Promise<boolean> {
    try {
      const item = await LocalStorage.getItem(key);
      Logger.debug("Checked key existence in secure storage", { key, exists: item !== null });
      return item !== null;
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to check key existence in secure storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
  /**
   * Encrypts a value for storage.
   *
   * @param value - Value to encrypt
   * @returns Encrypted value
   */
  private encrypt(value: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.ALGORITHM, Buffer.from(this.ENCRYPTION_KEY), iv);
    let encrypted = cipher.update(value);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return JSON.stringify({
      iv: iv.toString("hex"),
      data: encrypted.toString("hex"),
    });
  }
  /**
   * Decrypts a stored value.
   *
   * @param value - Value to decrypt
   * @returns Decrypted value
   */
  private decrypt(value: string): string {
    const { iv, data } = JSON.parse(value);
    const decipher = crypto.createDecipheriv(this.ALGORITHM, Buffer.from(this.ENCRYPTION_KEY), Buffer.from(iv, "hex"));
    let decrypted = decipher.update(Buffer.from(data, "hex"));
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
  }
  /**
   * Retrieves Harmony Hub data from storage.
   *
   * @returns Promise<HarmonyHub | null> The stored Harmony Hub data or null if not found
   * @throws {Error} If retrieval fails
   */
  public static async getHubData(): Promise<HarmonyHub | null> {
    try {
      const hubData = await LocalStorage.getItem<string>("hubData");
      if (!hubData) {
        return null;
      }
      Logger.debug("Retrieved Harmony Hub data from storage");
      return JSON.parse(hubData) as HarmonyHub;
    } catch (error) {
      const harmonyError = new HarmonyError(
        "Failed to retrieve Harmony Hub data from storage",
        ErrorCategory.STORAGE,
        error instanceof Error ? error : undefined
      );
      ErrorHandler.handle(harmonyError);
      throw harmonyError;
    }
  }
}
</file>

<file path="src/services/session-manager.ts">
import { LocalStorage } from "@raycast/api";
import { ToastManager } from "../ui/toast-manager";
/**
 * Interface representing a user session.
 */
interface Session {
  /**
   * The session token.
   */
  token: string;
  /**
   * The timestamp when the session expires.
   */
  expiresAt: number;
  /**
   * The timestamp of the last activity.
   */
  lastActivity: number;
}
/**
 * SessionManager class handles user session state and persistence.
 * It provides methods for storing and retrieving session data securely.
 */
export class SessionManager {
  /**
   * The key used to store the session in local storage.
   */
  private static readonly SESSION_KEY = "harmony_session";
  /**
   * The key used to store the cache in local storage.
   */
  private static readonly CACHE_KEY = "harmony_cache";
  /**
   * The key used to store the hub cache in local storage.
   */
  private static readonly HUB_CACHE_KEY = "harmony_hub_cache";
  /**
   * The duration of a session in milliseconds (24 hours).
   */
  private static readonly SESSION_DURATION = 24 * 60 * 60 * 1000;
  /**
   * The threshold for session inactivity in milliseconds (30 minutes).
   */
  private static readonly ACTIVITY_THRESHOLD = 30 * 60 * 1000;
  /**
   * Creates a new session with the given token.
   * @param token The session token.
   * @returns Promise<void>
   */
  static async createSession(token: string): Promise<void> {
    const session: Session = {
      token,
      expiresAt: Date.now() + this.SESSION_DURATION,
      lastActivity: Date.now(),
    };
    await LocalStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
  }
  /**
   * Retrieves the current session.
   * @returns Promise<Session | null> The current session or null if not found.
   */
  static async getSession(): Promise<Session | null> {
    try {
      const stored = await LocalStorage.getItem(this.SESSION_KEY);
      if (!stored || typeof stored !== "string") {
        return null;
      }
      const session = JSON.parse(stored) as Session;
      const now = Date.now();
      // Check if session has expired
      if (now > session.expiresAt) {
        await this.clearSession();
        return null;
      }
      // Check if session is inactive
      if (now - session.lastActivity > this.ACTIVITY_THRESHOLD) {
        await this.clearSession();
        return null;
      }
      // Update last activity
      session.lastActivity = now;
      await LocalStorage.setItem(this.SESSION_KEY, JSON.stringify(session));
      return session;
    } catch (error) {
      console.error("Error getting session:", error);
      return null;
    }
  }
  /**
   * Clears the current session.
   * @returns Promise<void>
   */
  static async clearSession(): Promise<void> {
    await LocalStorage.removeItem(this.SESSION_KEY);
  }
  /**
   * Clears the cache.
   * @returns Promise<void>
   */
  static async clearCache(): Promise<void> {
    await Promise.all([LocalStorage.removeItem(this.CACHE_KEY), LocalStorage.removeItem(this.HUB_CACHE_KEY)]);
    ToastManager.success("Cache cleared successfully");
  }
  /**
   * Validates the current session.
   * @returns Promise<boolean> True if the session is valid, false otherwise.
   */
  static async validateSession(): Promise<boolean> {
    const session = await this.getSession();
    if (!session) {
      await ToastManager.error("Session Expired", "Please reconnect to your Hub");
      return false;
    }
    return true;
  }
}
</file>

<file path="src/services/toast.ts">
/**
 * Toast utility for user notifications
 * @module
 */
import { showToast, Toast } from "@raycast/api";
import { Logger } from "./logger";
/**
 * Configuration for toast notifications
 */
interface ToastConfig {
  /** Whether to log toast messages */
  logToasts: boolean;
  /** Whether to include timestamps in logs */
  includeTimestamp: boolean;
}
/**
 * Default configuration for toast notifications
 */
const defaultConfig: ToastConfig = {
  logToasts: true,
  includeTimestamp: true,
};
/**
 * ToastManager class for consistent user notifications across the application.
 * Provides methods for showing different types of toasts and optional logging.
 */
export class ToastManager {
  private static config: ToastConfig = defaultConfig;
  /**
   * Configure the toast manager
   * @param config - Partial configuration to merge with defaults
   */
  static configure(config: Partial<ToastConfig>): void {
    ToastManager.config = { ...defaultConfig, ...config };
  }
  /**
   * Show a success toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async success(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(`Success: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  /**
   * Show an error toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async error(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.error(`Error: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  /**
   * Show a warning toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async warning(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.warn(`Warning: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Failure, // Raycast doesn't have a warning style
      title,
      message,
    });
  }
  /**
   * Show a loading toast
   * @param title - Toast title
   * @param message - Optional toast message
   */
  static async loading(title: string, message?: string): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(`Loading: ${title}${message ? ` - ${message}` : ""}`);
    }
    await showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
  /**
   * Show a progress toast
   * @param title - Toast title
   * @param message - Optional toast message
   * @param progress - Progress value between 0 and 1
   */
  static async progress(
    title: string,
    message?: string,
    progress?: number
  ): Promise<void> {
    if (ToastManager.config.logToasts) {
      Logger.info(
        `Progress: ${title}${message ? ` - ${message}` : ""}${
          progress !== undefined ? ` (${Math.round(progress * 100)}%)` : ""
        }`
      );
    }
    await showToast({
      style: Toast.Style.Animated,
      title,
      message: message
        ? progress !== undefined
          ? `${message} (${Math.round(progress * 100)}%)`
          : message
        : undefined,
    });
  }
}
</file>

<file path="src/stores/middleware/persist.ts">
/**
 * Persistence middleware for Zustand stores
 * @module
 */
import { StateCreator, StoreApi } from "zustand";
import { LocalStorage } from "../../services/localStorage";
import { Logger } from "../../services/logger";
import { HarmonyError } from "../../types/core/errors";
import { ErrorCategory } from "../../types/core/harmony";
type PersistImpl = <T>(
  config: PersistConfig<T>,
  baseStore: StateCreator<T, [], []>
) => StateCreator<T, [], []>;
interface PersistConfig<T> {
  /** Storage key */
  key: string;
  /** Optional filter function to select what to persist */
  filter?: (state: T) => Partial<T>;
  /** Optional version for migrations */
  version?: number;
  /** Optional migration function */
  migrate?: (persistedState: any, version: number) => T;
  /** Optional merge function */
  merge?: (persistedState: Partial<T>, currentState: T) => T;
}
/**
 * Creates a persistence middleware for Zustand stores
 */
export const persist = <T>(
  config: PersistConfig<T>
): StateCreator<T> => (
  setState,
  getState,
  api
): T => {
  const {
    key,
    filter = (state) => state,
    version = 0,
    migrate = (state) => state,
    merge = (persistedState, currentState) => ({
      ...currentState,
      ...persistedState,
    }),
  } = config;
  let isHydrating = false;
  const setItem = async (state: T): Promise<void> => {
    if (isHydrating) return;
    try {
      const persistedState = filter(state);
      await LocalStorage.setItem(
        key,
        JSON.stringify({
          state: persistedState,
          version,
        })
      );
      Logger.info("Persisted state", { key });
    } catch (err) {
      Logger.error("Failed to persist state", err);
      throw new HarmonyError(
        "Failed to persist state",
        ErrorCategory.DATA,
        err instanceof Error ? err : undefined
      );
    }
  };
  const hydrate = async (): Promise<void> => {
    try {
      const persistedJSON = await LocalStorage.getItem(key);
      if (persistedJSON) {
        const { state, version: persistedVersion } = JSON.parse(persistedJSON);
        const migratedState = migrate(state, persistedVersion);
        isHydrating = true;
        setState(
          merge(migratedState, getState()),
          false
        );
        isHydrating = false;
        Logger.info("Hydrated state", { key });
      }
    } catch (err) {
      Logger.error("Failed to hydrate state", err);
      throw new HarmonyError(
        "Failed to hydrate state",
        ErrorCategory.DATA,
        err instanceof Error ? err : undefined
      );
    }
  };
  // Create store with persistence
  const initialState = api.getState();
  // Subscribe to state changes
  api.subscribe((state) => {
    setItem(state as T).catch((err) => {
      Logger.error("Failed to persist state update", err);
    });
  });
  // Hydrate initial state
  hydrate().catch((err) => {
    Logger.error("Failed to hydrate initial state", err);
  });
  return initialState;
};
</file>

<file path="src/stores/harmony.ts">
/**
 * Harmony Hub state management store
 * @module
 */
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { ErrorHandler } from "../services/error-handler";
import { ToastManager } from "../services/toast";
import { LocalStorage } from "../services/localStorage";
import { Logger } from "../services/logger";
import {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  HarmonyError,
  ErrorCategory,
  LoadingState,
  HarmonyStage,
} from "../types/core";
import {
  MutableHarmonyState,
  toMutableHub,
  toMutableDevice,
  toMutableActivity,
  toMutableLoadingState,
} from "../types/core/state-mutable";
/**
 * Actions that can be performed on the store
 */
interface HarmonyActions {
  // Hub Management
  discoverHubs: () => Promise<void>;
  selectHub: (hub: HarmonyHub) => Promise<void>;
  disconnectHub: () => Promise<void>;
  // Device Management
  loadDevices: () => Promise<void>;
  executeCommand: (command: HarmonyCommand) => Promise<void>;
  // Activity Management
  loadActivities: () => Promise<void>;
  startActivity: (activity: HarmonyActivity) => Promise<void>;
  stopActivity: (activity: HarmonyActivity) => Promise<void>;
  // State Management
  setError: (error: HarmonyError | null) => void;
  clearError: () => void;
  setLoadingState: (state: LoadingState) => void;
  reset: () => void;
}
/**
 * Combined store type with state and actions
 */
type HarmonyStore = MutableHarmonyState & HarmonyActions;
/**
 * Create the Harmony store with Zustand and Immer
 */
export const useHarmonyStore = create<HarmonyStore>()(
  immer((set, get) => {
    // Load persisted state
    const loadPersistedState = async () => {
      try {
        const persistedJSON = await LocalStorage.getItem("harmony-hub-state");
        if (persistedJSON) {
          const { state } = JSON.parse(persistedJSON);
          set((draft) => {
            if (state.selectedHub) {
              draft.selectedHub = toMutableHub(state.selectedHub);
            }
            if (state.hubs) {
              draft.hubs = state.hubs.map(toMutableHub);
            }
          });
          Logger.info("Loaded persisted hub state");
        }
      } catch (err) {
        Logger.error("Failed to load persisted hub state", err);
      }
    };
    // Save state changes
    const saveState = async (state: HarmonyStore) => {
      try {
        const persistedState = {
          selectedHub: state.selectedHub,
          hubs: state.hubs,
        };
        await LocalStorage.setItem(
          "harmony-hub-state",
          JSON.stringify({ state: persistedState, version: 1 })
        );
        Logger.info("Saved hub state");
      } catch (err) {
        Logger.error("Failed to save hub state", err);
      }
    };
    // Initialize state
    loadPersistedState();
    return {
      // Initial State
      hubs: [],
      selectedHub: null,
      devices: [],
      activities: [],
      currentActivity: null,
      error: null,
      loadingState: {
        stage: HarmonyStage.INITIAL,
        progress: 0,
        message: "Ready",
      },
      // Hub Management Actions
      discoverHubs: async () => {
        try {
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.DISCOVERING,
              progress: 0,
              message: "Discovering Harmony Hubs...",
            });
            state.error = null;
          });
          // TODO: Implement hub discovery
          const hubs: HarmonyHub[] = [];
          set((state) => {
            state.hubs = hubs.map(toMutableHub);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 1,
              message: `Found ${hubs.length} hub(s)`,
            });
          });
          saveState(get());
          ToastManager.success(`Found ${hubs.length} Harmony Hub(s)`);
        } catch (error) {
          ErrorHandler.handle(error, "Failed to discover hubs", ErrorCategory.DISCOVERY);
          set((state) => {
            state.error = error as HarmonyError;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.ERROR,
              progress: 1,
              message: "Hub discovery failed",
            });
          });
        }
      },
      selectHub: async (hub) => {
        try {
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTING,
              progress: 0,
              message: `Connecting to ${hub.name}...`,
            });
            state.error = null;
          });
          // TODO: Implement hub connection
          set((state) => {
            state.selectedHub = toMutableHub(hub);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Connected to ${hub.name}`,
            });
          });
          saveState(get());
          // Load devices and activities
          await get().loadDevices();
          await get().loadActivities();
          ToastManager.success(`Connected to ${hub.name}`);
        } catch (error) {
          ErrorHandler.handle(error, "Failed to connect to hub", ErrorCategory.CONNECTION);
          set((state) => {
            state.error = error as HarmonyError;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.ERROR,
              progress: 1,
              message: "Connection failed",
            });
          });
        }
      },
      disconnectHub: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) return;
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 0,
              message: "Disconnecting...",
            });
          });
          // TODO: Implement hub disconnection
          set((state) => {
            state.selectedHub = null;
            state.devices = [];
            state.activities = [];
            state.currentActivity = null;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.INITIAL,
              progress: 1,
              message: "Disconnected",
            });
          });
          saveState(get());
          ToastManager.success("Disconnected from Harmony Hub");
        } catch (error) {
          ErrorHandler.handle(error, "Failed to disconnect", ErrorCategory.CONNECTION);
        }
      },
      // Device Management Actions
      loadDevices: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.LOADING_DEVICES,
              progress: 0,
              message: "Loading devices...",
            });
          });
          // TODO: Implement device loading
          const devices: HarmonyDevice[] = [];
          set((state) => {
            state.devices = devices.map(toMutableDevice);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Loaded ${devices.length} devices`,
            });
          });
        } catch (error) {
          ErrorHandler.handle(error, "Failed to load devices", ErrorCategory.DATA);
          set((state) => {
            state.error = error as HarmonyError;
          });
        }
      },
      executeCommand: async (command) => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.EXECUTING_COMMAND,
              progress: 0,
              message: `Executing command: ${command.label}`,
            });
          });
          // TODO: Implement command execution
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Executed command: ${command.label}`,
            });
          });
        } catch (error) {
          ErrorHandler.handle(error, "Failed to execute command", ErrorCategory.COMMAND);
          set((state) => {
            state.error = error as HarmonyError;
          });
        }
      },
      // Activity Management Actions
      loadActivities: async () => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.LOADING_ACTIVITIES,
              progress: 0,
              message: "Loading activities...",
            });
          });
          // TODO: Implement activity loading
          const activities: HarmonyActivity[] = [];
          set((state) => {
            state.activities = activities.map(toMutableActivity);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Loaded ${activities.length} activities`,
            });
          });
        } catch (error) {
          ErrorHandler.handle(error, "Failed to load activities", ErrorCategory.DATA);
          set((state) => {
            state.error = error as HarmonyError;
          });
        }
      },
      startActivity: async (activity) => {
        try {
          const { selectedHub } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.STARTING_ACTIVITY,
              progress: 0,
              message: `Starting activity: ${activity.name}`,
            });
          });
          // TODO: Implement activity start
          set((state) => {
            state.currentActivity = toMutableActivity(activity);
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Started activity: ${activity.name}`,
            });
          });
          ToastManager.success(`Started activity: ${activity.name}`);
        } catch (error) {
          ErrorHandler.handle(error, "Failed to start activity", ErrorCategory.COMMAND);
          set((state) => {
            state.error = error as HarmonyError;
          });
        }
      },
      stopActivity: async (activity) => {
        try {
          const { selectedHub, currentActivity } = get();
          if (!selectedHub) {
            throw new HarmonyError("No hub selected", ErrorCategory.STATE);
          }
          if (!currentActivity) {
            throw new HarmonyError("No activity is running", ErrorCategory.STATE);
          }
          set((state) => {
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.STOPPING_ACTIVITY,
              progress: 0,
              message: `Stopping activity: ${activity.name}`,
            });
          });
          // TODO: Implement activity stop
          set((state) => {
            state.currentActivity = null;
            state.loadingState = toMutableLoadingState({
              stage: HarmonyStage.CONNECTED,
              progress: 1,
              message: `Stopped activity: ${activity.name}`,
            });
          });
          ToastManager.success(`Stopped activity: ${activity.name}`);
        } catch (error) {
          ErrorHandler.handle(error, "Failed to stop activity", ErrorCategory.COMMAND);
          set((state) => {
            state.error = error as HarmonyError;
          });
        }
      },
      // State Management Actions
      setError: (error) => {
        set((state) => {
          state.error = error;
        });
      },
      clearError: () => {
        set((state) => {
          state.error = null;
        });
      },
      setLoadingState: (loadingState) => {
        set((state) => {
          state.loadingState = toMutableLoadingState(loadingState);
        });
      },
      reset: () => {
        set((state) => {
          state.hubs = [];
          state.selectedHub = null;
          state.devices = [];
          state.activities = [];
          state.currentActivity = null;
          state.error = null;
          state.loadingState = toMutableLoadingState({
            stage: HarmonyStage.INITIAL,
            progress: 0,
            message: "Ready",
          });
        });
        saveState(get());
      },
    };
  })
);
// Export selectors for common state derivations
export const selectHubs = (state: HarmonyStore) => state.hubs;
export const selectSelectedHub = (state: HarmonyStore) => state.selectedHub;
export const selectDevices = (state: HarmonyStore) => state.devices;
export const selectActivities = (state: HarmonyStore) => state.activities;
export const selectCurrentActivity = (state: HarmonyStore) => state.currentActivity;
export const selectError = (state: HarmonyStore) => state.error;
export const selectLoadingState = (state: HarmonyStore) => state.loadingState;
export const selectIsLoading = (state: HarmonyStore) =>
  state.loadingState.stage !== HarmonyStage.INITIAL &&
  state.loadingState.stage !== HarmonyStage.CONNECTED &&
  state.loadingState.stage !== HarmonyStage.ERROR;
</file>

<file path="src/stores/view.ts">
/**
 * View state management store
 * @module
 */
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { View, ViewState, ViewFilters, ViewActions, MutableViewState } from "../types/core/views";
import { HarmonyDevice, HarmonyActivity } from "../types/core/harmony";
import { getPreferenceValues } from "@raycast/api";
import { Preferences } from "../types/preferences";
import { toMutableDevice, toMutableActivity } from "../utils/state";
import { LocalStorage } from "../services/localStorage";
import { Logger } from "../services/logger";
/**
 * Combined store type with state and actions
 */
type ViewStore = MutableViewState & ViewActions;
/**
 * Create the view store with Zustand and Immer
 */
export const useViewStore = create<ViewStore>()(
  immer((set, get) => {
    const preferences = getPreferenceValues<Preferences>();
    Logger.debug("Initializing view store with preferences", { defaultView: preferences.defaultView });
    // Load persisted state
    const loadPersistedState = async () => {
      try {
        const persistedJSON = await LocalStorage.getItem("harmony-view-state");
        if (persistedJSON) {
          const { state } = JSON.parse(persistedJSON);
          set((draft) => {
            // Don't override the default view from preferences
            draft.filters = state.filters;
          });
          Logger.info("Loaded persisted view state");
        }
      } catch (err) {
        Logger.error("Failed to load persisted view state", err);
      }
    };
    // Save state changes
    const saveState = async (state: ViewStore) => {
      try {
        const persistedState = {
          filters: state.filters,
        };
        await LocalStorage.setItem(
          "harmony-view-state",
          JSON.stringify({ state: persistedState, version: 1 })
        );
        Logger.info("Saved view state");
      } catch (err) {
        Logger.error("Failed to save view state", err);
      }
    };
    // Initialize state
    loadPersistedState();
    const initialView = preferences.defaultView === "activities" ? View.ACTIVITIES : View.DEVICES;
    Logger.debug("Setting initial view", { initialView });
    return {
      // Initial State
      currentView: initialView,
      selectedDevice: null,
      selectedActivity: null,
      searchQuery: "",
      filters: {
        deviceType: undefined,
        activityType: undefined,
        showFavorites: false,
      },
      // View Actions
      changeView: (view: View) => {
        set((state: MutableViewState) => {
          // If transitioning from hubs view after connection, use the preferred view
          if (state.currentView === View.HUBS && view === View.DEVICES) {
            const preferences = getPreferenceValues<Preferences>();
            state.currentView = preferences.defaultView === "activities" ? View.ACTIVITIES : View.DEVICES;
          } else {
            state.currentView = view;
          }
          // Clear selection when changing views
          if (view !== View.DEVICE_DETAIL) {
            state.selectedDevice = null;
          }
          if (view !== View.ACTIVITY_DETAIL) {
            state.selectedActivity = null;
          }
          // Clear search and filters
          state.searchQuery = "";
          state.filters = {
            deviceType: undefined,
            activityType: undefined,
            showFavorites: false,
          };
        });
        saveState(get());
      },
      selectDevice: (device: HarmonyDevice) => {
        Logger.debug("Selecting device in store", { device });
        set((state: MutableViewState) => {
          state.selectedDevice = toMutableDevice(device);
          state.currentView = View.DEVICE_DETAIL;
        });
        saveState(get());
      },
      selectActivity: (activity: HarmonyActivity) => {
        set((state: MutableViewState) => {
          state.selectedActivity = toMutableActivity(activity);
          state.currentView = View.ACTIVITY_DETAIL;
        });
        saveState(get());
      },
      clearSelection: () => {
        set((state: MutableViewState) => {
          if (state.currentView === View.DEVICE_DETAIL) {
            state.currentView = View.DEVICES;
            state.selectedDevice = null;
          } else if (state.currentView === View.ACTIVITY_DETAIL) {
            state.currentView = View.ACTIVITIES;
            state.selectedActivity = null;
          }
        });
        saveState(get());
      },
      setSearch: (query: string) => {
        set((state: MutableViewState) => {
          state.searchQuery = query;
        });
      },
      setFilters: (filters: Partial<ViewFilters>) => {
        set((state: MutableViewState) => {
          state.filters = {
            ...state.filters,
            ...filters,
          };
        });
        saveState(get());
      },
    };
  })
);
// Selectors
export const selectCurrentView = (state: ViewStore) => state.currentView;
export const selectSelectedDevice = (state: ViewStore) => state.selectedDevice;
export const selectSelectedActivity = (state: ViewStore) => state.selectedActivity;
export const selectSearchQuery = (state: ViewStore) => state.searchQuery;
export const selectFilters = (state: ViewStore) => state.filters;
// Derived selectors
export const selectIsDetailView = (state: ViewStore) =>
  state.currentView === View.DEVICE_DETAIL || state.currentView === View.ACTIVITY_DETAIL;
export const selectCanGoBack = (state: ViewStore) =>
  state.currentView === View.DEVICE_DETAIL || state.currentView === View.ACTIVITY_DETAIL;
</file>

<file path="src/types/core/command.ts">
/**
 * Command-related type definitions for Harmony Hub integration
 * @module
 */
/**
 * Status of a command in the queue
 * @enum {string}
 */
export enum CommandStatus {
  /** Command is queued for execution */
  QUEUED = "QUEUED",
  /** Command is pending execution */
  PENDING = "PENDING",
  /** Command is currently executing */
  EXECUTING = "EXECUTING",
  /** Command has completed successfully */
  COMPLETED = "COMPLETED",
  /** Command has failed */
  FAILED = "FAILED",
  /** Command was cancelled */
  CANCELLED = "CANCELLED"
}
/**
 * Command queue configuration
 * @interface CommandQueueConfig
 */
export interface CommandQueueConfig {
  /** Maximum number of commands that can be queued */
  readonly maxQueueSize?: number;
  /** Maximum number of commands that can run concurrently */
  readonly maxConcurrent?: number;
  /** Default timeout for command execution in milliseconds */
  readonly defaultTimeout?: number;
  /** Default number of retries for failed commands */
  readonly defaultRetries?: number;
  /** Delay between commands in milliseconds */
  readonly commandDelay?: number;
}
/**
 * Command request for the queue
 * @interface CommandRequest
 */
export interface CommandRequest {
  /** Unique identifier for the command request */
  readonly id: string;
  /** Command to execute */
  readonly command: import("./harmony").HarmonyCommand;
  /** Timestamp when the request was created */
  readonly timestamp: number;
  /** Optional timeout in milliseconds */
  readonly timeout?: number;
  /** Optional number of retries */
  readonly retries?: number;
  /** Optional callback when command completes successfully */
  readonly onComplete?: () => void;
  /** Optional callback when command fails */
  readonly onError?: (error: Error) => void;
}
/**
 * Result of a command execution
 * @interface CommandResult
 */
export interface CommandResult {
  /** Unique identifier matching the request */
  readonly id: string;
  /** Command that was executed */
  readonly command: import("./harmony").HarmonyCommand;
  /** Current status of the command */
  readonly status: CommandStatus;
  /** Error if command failed */
  readonly error?: Error;
  /** When the command was queued */
  readonly queuedAt: number;
  /** When the command started executing */
  readonly startedAt?: number;
  /** When the command completed (success or failure) */
  readonly completedAt?: number;
}
/**
 * Error recovery actions for failed commands
 * @enum {string}
 */
export enum ErrorRecoveryAction {
  /** Retry the operation */
  RETRY = "retry",
  /** Reconnect to the hub */
  RECONNECT = "reconnect",
  /** Clear cache and retry */
  CLEAR_CACHE = "clear_cache",
  /** Reset configuration */
  RESET_CONFIG = "reset_config",
  /** Restart extension */
  RESTART = "restart",
  /** Manual user intervention required */
  MANUAL = "manual"
}
/**
 * Retry configuration for error handling
 * @interface RetryConfig
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  readonly maxAttempts: number;
  /** Base delay between retries in milliseconds */
  readonly baseDelay: number;
  /** Maximum delay between retries in milliseconds */
  readonly maxDelay: number;
  /** Whether to use exponential backoff */
  readonly useExponentialBackoff: boolean;
  /** Categories to never retry */
  readonly nonRetryableCategories?: import("./harmony").ErrorCategory[];
  /** Maximum total retry duration in milliseconds */
  readonly maxRetryDuration?: number;
}
/**
 * Timeout configuration for operations
 * @interface TimeoutConfig
 */
export interface TimeoutConfig {
  /** Connection timeout in milliseconds */
  readonly connection: number;
  /** Message timeout in milliseconds */
  readonly message: number;
  /** Activity timeout in milliseconds */
  readonly activity: number;
  /** Command timeout in milliseconds */
  readonly command: number;
  /** Discovery timeout in milliseconds */
  readonly discovery: number;
  /** Cache timeout in milliseconds */
  readonly cache: number;
}
/**
 * Retry context for error handling
 * @interface RetryContext
 */
export interface RetryContext {
  /** Number of retry attempts made */
  readonly attempts: number;
  /** Time of first attempt */
  readonly firstAttempt: number;
  /** Time of last attempt */
  readonly lastAttempt: number;
  /** Next scheduled retry time */
  readonly nextRetry: number | null;
  /** Whether maximum retries have been reached */
  readonly maxRetriesReached: boolean;
  /** Total retry duration in milliseconds */
  readonly totalDuration: number;
  /** Success rate of previous attempts */
  readonly successRate?: number;
}
</file>

<file path="src/types/core/errors.ts">
/**
 * Error type definitions for Harmony Hub integration
 * @module
 */
import { ErrorCategory, TimeoutConfig } from "./harmony";
// Re-export ErrorCategory and TimeoutConfig for convenience
export { ErrorCategory } from "./harmony";
export type { TimeoutConfig } from "./harmony";
/**
 * Error severity levels
 */
export enum ErrorSeverity {
  /** Informational issues that don't affect functionality */
  INFO = "info",
  /** Minor issues that may affect some functionality */
  WARNING = "warning",
  /** Serious issues that affect core functionality */
  ERROR = "error",
  /** Critical issues that prevent operation */
  CRITICAL = "critical"
}
/**
 * Recovery actions available for different error types
 */
export enum ErrorRecoveryAction {
  /** Retry the failed operation */
  RETRY = "retry",
  /** Reconnect to the hub */
  RECONNECT = "reconnect",
  /** Clear local cache */
  CLEAR_CACHE = "clear_cache",
  /** Reset configuration */
  RESET_CONFIG = "reset_config",
  /** Restart the hub */
  RESTART = "restart",
  /** Manual intervention required */
  MANUAL = "manual"
}
/**
 * Configuration for retry behavior
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Base delay between retries in milliseconds */
  baseDelay: number;
  /** Maximum delay between retries in milliseconds */
  maxDelay: number;
  /** Whether to use exponential backoff */
  useExponentialBackoff: boolean;
  /** Maximum total retry duration in milliseconds */
  maxRetryDuration?: number;
  /** Categories that should not be retried */
  nonRetryableCategories?: ErrorCategory[];
}
/**
 * Context for retry attempts
 */
export interface RetryContext {
  /** Number of retry attempts made */
  attempts: number;
  /** Total time spent retrying in milliseconds */
  totalDuration: number;
  /** Whether max retries has been reached */
  maxRetriesReached: boolean;
  /** Success rate of retry attempts */
  successRate?: number;
}
/**
 * Strategy for error recovery
 */
export interface ErrorRecoveryStrategy {
  /** Actions to take for recovery */
  actions: ErrorRecoveryAction[];
  /** Priority of this strategy (lower is higher priority) */
  priority: number;
  /** Whether recovery can be automatic */
  automatic: boolean;
  /** Maximum attempts for this strategy */
  maxAttempts: number;
  /** Delay between attempts in milliseconds */
  delayBetweenAttempts: number;
}
/**
 * Custom error class for Harmony-related errors
 * @class HarmonyError
 * @extends Error
 */
export class HarmonyError extends Error {
  /** The category of the error */
  readonly category: ErrorCategory;
  /** Error severity level */
  readonly severity: ErrorSeverity;
  /** The original error that caused this error, if any */
  readonly cause?: Error;
  /** Retry context if applicable */
  readonly retryContext?: RetryContext;
  /** Whether the error is retryable */
  readonly isRetryable: boolean;
  /** Error code if any */
  readonly code?: string;
  /** Additional error details */
  readonly details?: Record<string, unknown>;
  /** Recovery strategies */
  readonly recoveryStrategies?: ErrorRecoveryStrategy[];
  /** Timestamp when error occurred */
  readonly timestamp: number;
  /**
   * Creates a new HarmonyError
   * @param message The error message
   * @param category The category of the error
   * @param cause The original error that caused this error, if any
   * @param retryContext Retry attempt context if applicable
   * @param isRetryable Whether the error can be retried
   * @param code Error code if any
   * @param details Additional error details
   * @param severity Error severity level
   * @param recoveryStrategies Available recovery strategies
   */
  constructor(
    message: string,
    category: ErrorCategory,
    cause?: Error,
    retryContext?: RetryContext,
    isRetryable = true,
    code?: string,
    details?: Record<string, unknown>,
    severity: ErrorSeverity = ErrorSeverity.ERROR,
    recoveryStrategies?: ErrorRecoveryStrategy[]
  ) {
    super(message);
    this.name = "HarmonyError";
    this.category = category;
    this.severity = severity;
    this.cause = cause;
    this.retryContext = retryContext;
    this.isRetryable = isRetryable;
    this.code = code;
    this.details = details;
    this.recoveryStrategies = recoveryStrategies;
    this.timestamp = Date.now();
    // Maintains proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, HarmonyError);
    }
  }
  /**
   * Gets a user-friendly message for this error
   * @returns A user-friendly error message
   */
  public getUserMessage(): string {
    const baseMessage = this.getBaseUserMessage();
    const recoveryMessage = this.getRecoveryMessage();
    return recoveryMessage ? `${baseMessage}\n\n${recoveryMessage}` : baseMessage;
  }
  /**
   * Gets a detailed error message including the cause if available
   * @returns A detailed error message
   */
  public getDetailedMessage(): string {
    let message = `${this.message} (${this.category})`;
    if (this.code) {
      message += `\nCode: ${this.code}`;
    }
    if (this.cause) {
      message += `\nCaused by: ${this.cause.message}`;
    }
    if (this.details) {
      message += `\nDetails: ${JSON.stringify(this.details)}`;
    }
    return message;
  }
  /**
   * Create a new error with updated retry context
   */
  public withRetryContext(retryContext: RetryContext): HarmonyError {
    return new HarmonyError(
      this.message,
      this.category,
      this.cause,
      retryContext,
      this.isRetryable,
      this.code,
      this.details,
      this.severity,
      this.recoveryStrategies
    );
  }
  /**
   * Create a new error with updated recovery strategies
   */
  public withRecoveryStrategies(strategies: ErrorRecoveryStrategy[]): HarmonyError {
    return new HarmonyError(
      this.message,
      this.category,
      this.cause,
      this.retryContext,
      this.isRetryable,
      this.code,
      this.details,
      this.severity,
      strategies
    );
  }
  /**
   * Check if error should be retried based on category and context
   */
  public shouldRetry(config: RetryConfig): boolean {
    if (!this.isRetryable) return false;
    if (!this.retryContext) return true;
    if (this.retryContext.maxRetriesReached) return false;
    // Don't retry if we've exceeded max attempts
    if (this.retryContext.attempts >= config.maxAttempts) return false;
    // Don't retry if we've exceeded max duration
    if (config.maxRetryDuration && this.retryContext.totalDuration >= config.maxRetryDuration) {
      return false;
    }
    // Don't retry certain error categories
    const nonRetryableCategories = config.nonRetryableCategories || [];
    if (nonRetryableCategories.includes(this.category)) return false;
    // Don't retry if success rate is too low
    if (this.retryContext.successRate !== undefined && this.retryContext.successRate < 0.2) {
      return false;
    }
    return true;
  }
  /**
   * Calculate next retry delay using exponential backoff
   */
  public getRetryDelay(config: RetryConfig): number {
    if (!this.retryContext) return config.baseDelay;
    const { attempts } = this.retryContext;
    const { baseDelay, maxDelay, useExponentialBackoff } = config;
    if (!useExponentialBackoff) return baseDelay;
    // Calculate delay with exponential backoff
    const delay = Math.min(
      baseDelay * Math.pow(2, attempts),
      maxDelay
    );
    // Add jitter to prevent thundering herd
    return delay * (0.5 + Math.random());
  }
  /**
   * Get recommended recovery strategy
   */
  public getRecoveryStrategy(): ErrorRecoveryStrategy | null {
    if (!this.recoveryStrategies || this.recoveryStrategies.length === 0) {
      return this.getDefaultRecoveryStrategy();
    }
    // Get highest priority strategy that hasn't exceeded max attempts
    return this.recoveryStrategies
      .sort((a, b) => a.priority - b.priority)
      .find(s => !this.retryContext || this.retryContext.attempts < s.maxAttempts) || null;
  }
  private getBaseUserMessage(): string {
    switch (this.category) {
      case ErrorCategory.CONNECTION:
        return "Failed to connect to Harmony Hub. Please check your network connection and try again.";
      case ErrorCategory.DISCOVERY:
        return "Failed to discover Harmony Hubs. Please ensure your hub is powered on and connected to the network.";
      case ErrorCategory.COMMAND:
        return "Failed to execute command. Please try again.";
      case ErrorCategory.STATE:
        return "Failed to update state. Please try reconnecting to the hub.";
      case ErrorCategory.DATA:
        return "Failed to retrieve data from Harmony Hub. Please try again.";
      case ErrorCategory.HUB_COMMUNICATION:
        return "Lost communication with the Harmony Hub. Please check your connection.";
      default:
        return this.message;
    }
  }
  private getRecoveryMessage(): string | null {
    const strategy = this.getRecoveryStrategy();
    if (!strategy) return null;
    if (!strategy.automatic) {
      switch (strategy.actions[0]) {
        case ErrorRecoveryAction.RESET_CONFIG:
          return "Try resetting your configuration in the extension settings.";
        case ErrorRecoveryAction.RESTART:
          return "Please restart the extension to resolve this issue.";
        case ErrorRecoveryAction.MANUAL:
          return "Manual intervention is required. Please check the documentation.";
        default:
          return null;
      }
    }
    return null;
  }
  private getDefaultRecoveryStrategy(): ErrorRecoveryStrategy | null {
    switch (this.category) {
      case ErrorCategory.CONNECTION:
        return {
          actions: [ErrorRecoveryAction.RECONNECT],
          priority: 1,
          automatic: true,
          maxAttempts: 3,
          delayBetweenAttempts: 1000
        };
      case ErrorCategory.DISCOVERY:
        return {
          actions: [ErrorRecoveryAction.RETRY, ErrorRecoveryAction.CLEAR_CACHE],
          priority: 1,
          automatic: true,
          maxAttempts: 2,
          delayBetweenAttempts: 500
        };
      case ErrorCategory.COMMAND:
        return {
          actions: [ErrorRecoveryAction.RETRY],
          priority: 1,
          automatic: true,
          maxAttempts: 2,
          delayBetweenAttempts: 500
        };
      case ErrorCategory.STATE:
        return {
          actions: [ErrorRecoveryAction.RESET_CONFIG],
          priority: 2,
          automatic: false,
          maxAttempts: 1,
          delayBetweenAttempts: 0
        };
      case ErrorCategory.DATA:
        return {
          actions: [ErrorRecoveryAction.RETRY, ErrorRecoveryAction.CLEAR_CACHE],
          priority: 1,
          automatic: true,
          maxAttempts: 2,
          delayBetweenAttempts: 500
        };
      case ErrorCategory.HUB_COMMUNICATION:
        return {
          actions: [ErrorRecoveryAction.RETRY, ErrorRecoveryAction.RECONNECT],
          priority: 1,
          automatic: true,
          maxAttempts: 3,
          delayBetweenAttempts: 1000
        };
      default:
        return null;
    }
  }
}
/**
 * Type guard to check if an error is a HarmonyError
 * @param error The error to check
 * @returns True if the error is a HarmonyError
 */
export function isHarmonyError(error: unknown): error is HarmonyError {
  return error instanceof HarmonyError;
}
/**
 * Wraps an error in a HarmonyError if it isn't one already
 * @param error The error to wrap
 * @param category The category to use if wrapping
 * @param message The message to use if wrapping
 * @returns A HarmonyError
 */
export function wrapError(
  error: unknown,
  category: ErrorCategory,
  message = "An unexpected error occurred"
): HarmonyError {
  if (isHarmonyError(error)) {
    return error;
  }
  return new HarmonyError(
    message,
    category,
    error instanceof Error ? error : undefined
  );
}
</file>

<file path="src/types/core/harmony.ts">
/**
 * Core type definitions for Harmony Hub integration
 * @module
 */
/**
 * Represents a Logitech Harmony Hub device on the network
 * @interface HarmonyHub
 */
export interface HarmonyHub {
  /** Unique identifier for the hub */
  readonly id: string;
  /** User-friendly name of the hub */
  readonly name: string;
  /** IP address of the hub on the local network */
  readonly ip: string;
  /** Remote ID assigned by Harmony service */
  readonly remoteId?: string;
  /** Hub ID from Logitech service */
  readonly hubId?: string;
  /** Version of the hub firmware */
  readonly version?: string;
  /** Port number for hub communication */
  readonly port?: string;
  /** Product ID of the hub */
  readonly productId?: string;
  /** Protocol versions supported by the hub */
  readonly protocolVersion?: string;
}
/**
 * Represents a device that can be controlled by the Harmony Hub
 * @interface HarmonyDevice
 */
export interface HarmonyDevice {
  /** Unique identifier for the device */
  readonly id: string;
  /** User-friendly name of the device */
  readonly name: string;
  /** Type of device (e.g., TV, Receiver, etc.) */
  readonly type: string;
  /** Available commands for this device */
  readonly commands: readonly HarmonyCommand[];
}
/**
 * Represents a command that can be sent to a device
 * @interface HarmonyCommand
 */
export interface HarmonyCommand {
  /** Unique identifier for the command */
  readonly id: string;
  /** Internal name of the command */
  readonly name: string;
  /** User-friendly label for display */
  readonly label: string;
  /** ID of the device this command belongs to */
  readonly deviceId: string;
  /** Command group for categorization (e.g., "IRCommand", "PowerToggle", etc.) */
  readonly group?: string;
}
/**
 * Represents an activity configured on the Harmony Hub
 * @interface HarmonyActivity
 */
export interface HarmonyActivity {
  /** Unique identifier for the activity */
  readonly id: string;
  /** User-friendly name of the activity */
  readonly name: string;
  /** Type of activity (e.g., "WatchTV", "ListenToMusic", etc.) */
  readonly type: string;
  /** Whether this is the currently running activity */
  readonly isCurrent: boolean;
}
/**
 * Represents the stage of the Harmony Hub connection process
 * @enum {string}
 */
export enum HarmonyStage {
  /** Initial state before any connection attempt */
  INITIAL = "initial",
  /** Actively discovering hubs on the network */
  DISCOVERING = "discovering",
  /** Establishing connection to a specific hub */
  CONNECTING = "connecting",
  /** Loading device information from the hub */
  LOADING_DEVICES = "loading_devices",
  /** Loading activity information from the hub */
  LOADING_ACTIVITIES = "loading_activities",
  /** Starting a new activity */
  STARTING_ACTIVITY = "starting_activity",
  /** Stopping the current activity */
  STOPPING_ACTIVITY = "stopping_activity",
  /** Executing a device command */
  EXECUTING_COMMAND = "executing_command",
  /** Refreshing hub state */
  REFRESHING = "refreshing",
  /** Successfully connected and ready */
  CONNECTED = "connected",
  /** Error state */
  ERROR = "error"
}
/**
 * Categories of errors that can occur during Harmony operations
 * @enum {string}
 */
export enum ErrorCategory {
  /** Network or connectivity errors */
  CONNECTION = "connection",
  /** Hub discovery errors */
  DISCOVERY = "discovery",
  /** Command execution errors */
  COMMAND = "command",
  /** State management errors */
  STATE = "state",
  /** Data retrieval or parsing errors */
  DATA = "data",
  /** Hub communication errors */
  HUB_COMMUNICATION = "hub_communication",
  /** Command execution specific errors */
  COMMAND_EXECUTION = "command_execution",
  /** Activity start errors */
  ACTIVITY_START = "activity_start",
  /** Activity stop errors */
  ACTIVITY_STOP = "activity_stop",
  /** Validation errors */
  VALIDATION = "validation",
  /** Storage errors */
  STORAGE = "storage",
  /** Cache errors */
  CACHE = "cache",
  /** Queue errors */
  QUEUE = "queue",
  /** Network-specific errors */
  NETWORK = "network",
  /** Harmony-specific errors */
  HARMONY = "harmony",
  /** WebSocket errors */
  WEBSOCKET = "websocket",
  /** Authentication errors */
  AUTHENTICATION = "authentication",
  /** System-level errors */
  SYSTEM = "system",
  /** Unknown errors */
  UNKNOWN = "unknown"
}
/**
 * Recovery actions available for different error types
 * @enum {string}
 */
export enum ErrorRecoveryAction {
  /** Retry the failed operation */
  RETRY = "retry",
  /** Reconnect to the hub */
  RECONNECT = "reconnect",
  /** Clear local cache */
  CLEAR_CACHE = "clear_cache",
  /** Reset configuration */
  RESET_CONFIG = "reset_config",
  /** Restart the hub */
  RESTART = "restart",
  /** Manual intervention required */
  MANUAL = "manual"
}
/**
 * Represents the loading state during operations
 * @interface LoadingState
 */
export interface LoadingState {
  /** Current stage of the process */
  readonly stage: HarmonyStage;
  /** Progress from 0 to 1 */
  readonly progress: number;
  /** User-friendly message about the current state */
  readonly message: string;
}
/**
 * Configuration for operation timeouts
 */
export interface TimeoutConfig {
  /** Timeout for network operations in milliseconds */
  connection: number;
  /** Timeout for message operations in milliseconds */
  message: number;
  /** Timeout for activity operations in milliseconds */
  activity: number;
  /** Timeout for command operations in milliseconds */
  command: number;
  /** Timeout for discovery operations in milliseconds */
  discovery: number;
  /** Timeout for cache operations in milliseconds */
  cache: number;
}
/**
 * Type guard to check if an object is a HarmonyHub
 * @param obj The object to check
 * @returns True if the object is a HarmonyHub
 */
export function isHarmonyHub(obj: unknown): obj is HarmonyHub {
  return (
    typeof obj === "object" &&
    obj !== null &&
    typeof (obj as HarmonyHub).id === "string" &&
    typeof (obj as HarmonyHub).name === "string" &&
    typeof (obj as HarmonyHub).ip === "string"
  );
}
/**
 * Type guard to check if an object is a HarmonyDevice
 * @param obj The object to check
 * @returns True if the object is a HarmonyDevice
 */
export function isHarmonyDevice(obj: unknown): obj is HarmonyDevice {
  return (
    typeof obj === "object" &&
    obj !== null &&
    typeof (obj as HarmonyDevice).id === "string" &&
    typeof (obj as HarmonyDevice).name === "string" &&
    typeof (obj as HarmonyDevice).type === "string" &&
    Array.isArray((obj as HarmonyDevice).commands)
  );
}
/**
 * Type guard to check if an object is a HarmonyCommand
 * @param obj The object to check
 * @returns True if the object is a HarmonyCommand
 */
export function isHarmonyCommand(obj: unknown): obj is HarmonyCommand {
  return (
    typeof obj === "object" &&
    obj !== null &&
    typeof (obj as HarmonyCommand).id === "string" &&
    typeof (obj as HarmonyCommand).name === "string" &&
    typeof (obj as HarmonyCommand).label === "string" &&
    typeof (obj as HarmonyCommand).deviceId === "string"
  );
}
/**
 * Type guard to check if an object is a HarmonyActivity
 * @param obj The object to check
 * @returns True if the object is a HarmonyActivity
 */
export function isHarmonyActivity(obj: unknown): obj is HarmonyActivity {
  return (
    typeof obj === "object" &&
    obj !== null &&
    typeof (obj as HarmonyActivity).id === "string" &&
    typeof (obj as HarmonyActivity).name === "string" &&
    typeof (obj as HarmonyActivity).type === "string" &&
    typeof (obj as HarmonyActivity).isCurrent === "boolean"
  );
}
/**
 * Validation utility to ensure a HarmonyHub object is valid
 * @param hub The hub object to validate
 * @throws {Error} If the hub object is invalid
 */
export function validateHarmonyHub(hub: HarmonyHub): void {
  if (!isHarmonyHub(hub)) {
    throw new Error("Invalid HarmonyHub object");
  }
}
/**
 * Validation utility to ensure a HarmonyDevice object is valid
 * @param device The device object to validate
 * @throws {Error} If the device object is invalid
 */
export function validateHarmonyDevice(device: HarmonyDevice): void {
  if (!isHarmonyDevice(device)) {
    throw new Error("Invalid HarmonyDevice object");
  }
  device.commands.forEach(validateHarmonyCommand);
}
/**
 * Validation utility to ensure a HarmonyCommand object is valid
 * @param command The command object to validate
 * @throws {Error} If the command object is invalid
 */
export function validateHarmonyCommand(command: HarmonyCommand): void {
  if (!isHarmonyCommand(command)) {
    throw new Error("Invalid HarmonyCommand object");
  }
}
/**
 * Validation utility to ensure a HarmonyActivity object is valid
 * @param activity The activity object to validate
 * @throws {Error} If the activity object is invalid
 */
export function validateHarmonyActivity(activity: HarmonyActivity): void {
  if (!isHarmonyActivity(activity)) {
    throw new Error("Invalid HarmonyActivity object");
  }
}
</file>

<file path="src/types/core/index.ts">
/**
 * Core types and utilities for Harmony Hub integration
 * @module
 */
// Base types
export * from "./harmony";
export * from "./errors";
export * from "./validation";
export * from "./command";
export * from "./logging";
export * from "./websocket";
export * from "./state";
// Re-export commonly used types for convenience
export type {
  // Harmony types
  HarmonyHub,
  HarmonyDevice,
  HarmonyCommand,
  HarmonyActivity,
  LoadingState,
} from "./harmony";
// Re-export commonly used enums
export {
  // Harmony enums
  HarmonyStage,
  ErrorCategory,
} from "./harmony";
// Re-export error types
export {
  HarmonyError,
  isHarmonyError,
  wrapError,
} from "./errors";
// Re-export validation functions
export {
  validateHub,
  validateDevice,
  validateCommand,
  validateActivity,
  validateLoadingState,
} from "./validation";
// Re-export command types
export type {
  CommandQueueConfig,
  CommandRequest,
  CommandResult,
  RetryConfig,
  TimeoutConfig,
  RetryContext,
} from "./command";
export {
  CommandStatus,
  ErrorRecoveryAction,
} from "./command";
// Re-export logging types
export type {
  LoggerOptions,
  LogEntry,
  ILogger,
  LogFilter,
  LogFormatter,
} from "./logging";
export {
  LogLevel,
  ErrorSeverity,
} from "./logging";
// Re-export WebSocket types
export type {
  WebSocketMessage,
  CommandPayload,
  ActivityPayload,
  WebSocketMessageUnion,
  WebSocketResponse,
  ActivitiesResponse,
  DevicesResponse,
  WebSocketEventHandler,
  WebSocketErrorHandler,
  QueuedMessage,
} from "./websocket";
export {
  WebSocketConnectionStatus,
  WebSocketMessageType,
} from "./websocket";
// Re-export state types
export type {
  MachineContext,
  DiscoverEvent,
  SelectHubEvent,
  RefreshEvent,
  RetryEvent,
  ClearEvent,
  DisconnectEvent,
  ErrorEvent,
  DoneDiscoverEvent,
  DoneLoadHubEvent,
  MachineEvent,
  MachineServices,
  HarmonyState,
} from "./state";
export {
  MachineState,
} from "./state";
</file>

<file path="src/types/core/logging.ts">
/**
 * Logging type definitions for Harmony Hub integration
 * @module
 */
/**
 * Log levels for application logging
 * @enum {number}
 */
export enum LogLevel {
  /** Debug level for detailed troubleshooting */
  DEBUG = 0,
  /** Info level for general operational messages */
  INFO = 1,
  /** Warning level for potentially problematic situations */
  WARN = 2,
  /** Error level for error conditions */
  ERROR = 3
}
/**
 * Error severity levels
 * @enum {string}
 */
export enum ErrorSeverity {
  /** Informational messages that don't affect functionality */
  INFO = "info",
  /** Minor issues that don't affect core functionality */
  WARNING = "warning",
  /** Serious issues that affect core functionality */
  ERROR = "error",
  /** Critical issues that prevent the extension from working */
  CRITICAL = "critical"
}
/**
 * Interface for logger configuration options
 * @interface LoggerOptions
 */
export interface LoggerOptions {
  /** Minimum log level to record */
  minLevel?: LogLevel;
  /** Maximum number of log entries to keep in memory */
  maxEntries?: number;
  /** Whether to include timestamps in log entries */
  includeTimestamp?: boolean;
  /** Whether to include log level in entries */
  includeLevel?: boolean;
}
/**
 * Structure of a log entry
 * @interface LogEntry
 */
export interface LogEntry {
  /** ISO timestamp of when the entry was created */
  readonly timestamp: string;
  /** Log level of the entry */
  readonly level: LogLevel;
  /** Log message */
  readonly message: string;
  /** Optional additional data */
  readonly data?: unknown;
}
/**
 * Interface for logger implementations
 * @interface ILogger
 */
export interface ILogger {
  /**
   * Log a debug message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  debug(message: string, data?: unknown): void;
  /**
   * Log an info message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  info(message: string, data?: unknown): void;
  /**
   * Log a warning message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  warn(message: string, data?: unknown): void;
  /**
   * Log an error message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  error(message: string, data?: unknown): void;
  /**
   * Log an error with full stack trace
   * @param error - Error to log
   * @param context - Optional context information
   */
  logError(error: Error, context?: string): void;
  /**
   * Get log history
   * @returns Array of log entries
   */
  getHistory(): LogEntry[];
  /**
   * Clear log history
   */
  clearHistory(): void;
  /**
   * Set minimum log level
   * @param level - New minimum log level
   */
  setMinLevel(level: LogLevel): void;
}
/**
 * Type for log entry filter functions
 * @type {LogFilter}
 */
export type LogFilter = (entry: LogEntry) => boolean;
/**
 * Type for log entry formatter functions
 * @type {LogFormatter}
 */
export type LogFormatter = (entry: LogEntry) => string;
</file>

<file path="src/types/core/state-mutable.ts">
/**
 * Mutable state types for use with Immer
 * @module
 */
import type {
  HarmonyHub,
  HarmonyDevice,
  HarmonyActivity,
  HarmonyCommand,
  LoadingState,
} from "./harmony";
/**
 * Mutable version of HarmonyHub
 */
export interface MutableHarmonyHub {
  id: string;
  name: string;
  ip: string;
  remoteId?: string;
  hubId?: string;
  version?: string;
  port?: string;
  productId?: string;
  protocolVersion?: string;
}
/**
 * Mutable version of HarmonyCommand
 */
export interface MutableHarmonyCommand {
  id: string;
  name: string;
  label: string;
  deviceId: string;
  group?: string;
}
/**
 * Mutable version of HarmonyDevice
 */
export interface MutableHarmonyDevice {
  id: string;
  name: string;
  type: string;
  commands: MutableHarmonyCommand[];
}
/**
 * Mutable version of HarmonyActivity
 */
export interface MutableHarmonyActivity {
  id: string;
  name: string;
  type: string;
  isCurrent: boolean;
}
/**
 * Mutable version of LoadingState
 */
export interface MutableLoadingState {
  stage: string;
  progress: number;
  message: string;
}
/**
 * Mutable version of HarmonyState
 */
export interface MutableHarmonyState {
  hubs: MutableHarmonyHub[];
  selectedHub: MutableHarmonyHub | null;
  devices: MutableHarmonyDevice[];
  activities: MutableHarmonyActivity[];
  currentActivity: MutableHarmonyActivity | null;
  error: Error | null;
  loadingState: MutableLoadingState;
}
/**
 * Convert a readonly HarmonyHub to a mutable one
 */
export function toMutableHub(hub: HarmonyHub): MutableHarmonyHub {
  return {
    id: hub.id,
    name: hub.name,
    ip: hub.ip,
    remoteId: hub.remoteId,
    hubId: hub.hubId,
    version: hub.version,
    port: hub.port,
    productId: hub.productId,
    protocolVersion: hub.protocolVersion,
  };
}
/**
 * Convert a readonly HarmonyCommand to a mutable one
 */
export function toMutableCommand(command: HarmonyCommand): MutableHarmonyCommand {
  return {
    id: command.id,
    name: command.name,
    label: command.label,
    deviceId: command.deviceId,
    group: command.group,
  };
}
/**
 * Convert a readonly HarmonyDevice to a mutable one
 */
export function toMutableDevice(device: HarmonyDevice): MutableHarmonyDevice {
  return {
    id: device.id,
    name: device.name,
    type: device.type,
    commands: device.commands.map(toMutableCommand),
  };
}
/**
 * Convert a readonly HarmonyActivity to a mutable one
 */
export function toMutableActivity(activity: HarmonyActivity): MutableHarmonyActivity {
  return {
    id: activity.id,
    name: activity.name,
    type: activity.type,
    isCurrent: activity.isCurrent,
  };
}
/**
 * Convert a readonly LoadingState to a mutable one
 */
export function toMutableLoadingState(state: LoadingState): MutableLoadingState {
  return {
    stage: state.stage,
    progress: state.progress,
    message: state.message,
  };
}
</file>

<file path="src/types/core/state.ts">
/**
 * State-related type definitions for Harmony Hub integration
 * @module
 */
import type { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import type { HarmonyError } from "./errors";
import type { LoadingState } from "./harmony";
/**
 * State machine states for Harmony Hub control
 * @enum {string}
 */
export enum MachineState {
  /** Initial state */
  IDLE = "IDLE",
  /** Discovering available hubs */
  DISCOVERING = "DISCOVERING",
  /** Connecting to a hub */
  CONNECTING = "CONNECTING",
  /** Connected to a hub */
  CONNECTED = "CONNECTED",
  /** Error state */
  ERROR = "ERROR"
}
/**
 * Context data for Harmony state machine
 * @interface MachineContext
 */
export interface MachineContext {
  /** List of available hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices on the hub */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities on the hub */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Error state if any */
  readonly error: HarmonyError | null;
}
/**
 * Event payload for hub discovery
 * @interface DiscoverEvent
 */
export interface DiscoverEvent {
  readonly type: "DISCOVER";
}
/**
 * Event payload for hub selection
 * @interface SelectHubEvent
 */
export interface SelectHubEvent {
  readonly type: "SELECT_HUB";
  /** Hub to select */
  readonly hub: HarmonyHub;
}
/**
 * Event payload for state refresh
 * @interface RefreshEvent
 */
export interface RefreshEvent {
  readonly type: "REFRESH";
}
/**
 * Event payload for retrying a failed action
 * @interface RetryEvent
 */
export interface RetryEvent {
  readonly type: "RETRY";
}
/**
 * Event payload for clearing the state
 * @interface ClearEvent
 */
export interface ClearEvent {
  readonly type: "CLEAR";
}
/**
 * Event payload for hub disconnection
 * @interface DisconnectEvent
 */
export interface DisconnectEvent {
  readonly type: "DISCONNECT";
}
/**
 * Event payload for error state
 * @interface ErrorEvent
 */
export interface ErrorEvent {
  readonly type: "error.platform";
  /** Error that occurred */
  readonly data: HarmonyError;
}
/**
 * Event payload for done discovering hubs
 * @interface DoneDiscoverEvent
 */
export interface DoneDiscoverEvent {
  readonly type: "done.invoke.discoverHubs";
  /** List of discovered hubs */
  readonly data: {
    readonly hubs: readonly HarmonyHub[];
  };
}
/**
 * Event payload for done loading hub data
 * @interface DoneLoadHubEvent
 */
export interface DoneLoadHubEvent {
  readonly type: "done.invoke.loadHubData";
  /** Loaded hub data */
  readonly data: {
    readonly devices: readonly HarmonyDevice[];
    readonly activities: readonly HarmonyActivity[];
  };
}
/**
 * Union type of all possible state machine events
 * @type {MachineEvent}
 */
export type MachineEvent =
  | DiscoverEvent
  | SelectHubEvent
  | DisconnectEvent
  | RefreshEvent
  | RetryEvent
  | ClearEvent
  | ErrorEvent
  | DoneDiscoverEvent
  | DoneLoadHubEvent;
/**
 * Service types for XState
 * @interface MachineServices
 */
export interface MachineServices {
  readonly discoverHubs: {
    readonly data: { readonly hubs: readonly HarmonyHub[] };
  };
  readonly loadHubData: {
    readonly data: {
      readonly devices: readonly HarmonyDevice[];
      readonly activities: readonly HarmonyActivity[];
    };
  };
}
/**
 * Core state for Harmony operations
 * @interface HarmonyState
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  readonly hubs: readonly HarmonyHub[];
  /** Currently selected hub */
  readonly selectedHub: HarmonyHub | null;
  /** Available devices */
  readonly devices: readonly HarmonyDevice[];
  /** Available activities */
  readonly activities: readonly HarmonyActivity[];
  /** Currently running activity */
  readonly currentActivity: HarmonyActivity | null;
  /** Current error if any */
  readonly error: Error | null;
  /** Current loading state */
  readonly loadingState: LoadingState;
}
</file>

<file path="src/types/core/validation.ts">
/**
 * Validation utilities for Harmony Hub types
 * @module
 */
import { HarmonyError } from "./errors";
import { ErrorCategory } from "./harmony";
import type {
  HarmonyHub,
  HarmonyDevice,
  HarmonyCommand,
  HarmonyActivity,
  LoadingState,
} from "./harmony";
/**
 * Validates a string field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @throws {HarmonyError} If the value is invalid
 */
function validateString(value: unknown, fieldName: string): void {
  if (typeof value !== "string" || value.trim().length === 0) {
    throw new HarmonyError(
      `Invalid ${fieldName}: must be a non-empty string`,
      ErrorCategory.DATA
    );
  }
}
/**
 * Validates a number field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @throws {HarmonyError} If the value is invalid
 */
function validateNumber(value: unknown, fieldName: string): void {
  if (typeof value !== "number" || isNaN(value)) {
    throw new HarmonyError(
      `Invalid ${fieldName}: must be a number`,
      ErrorCategory.DATA
    );
  }
}
/**
 * Validates an array field
 * @param value The value to validate
 * @param fieldName The name of the field
 * @param itemValidator Function to validate each item in the array
 * @throws {HarmonyError} If the value is invalid
 */
function validateArray<T>(
  value: unknown,
  fieldName: string,
  itemValidator: (item: unknown) => void
): void {
  if (!Array.isArray(value)) {
    throw new HarmonyError(
      `Invalid ${fieldName}: must be an array`,
      ErrorCategory.DATA
    );
  }
  value.forEach((item, index) => {
    try {
      itemValidator(item);
    } catch (error) {
      throw new HarmonyError(
        `Invalid item at index ${index} in ${fieldName}`,
        ErrorCategory.DATA,
        error instanceof Error ? error : undefined
      );
    }
  });
}
/**
 * Validates a HarmonyHub object
 * @param hub The hub to validate
 * @throws {HarmonyError} If the hub is invalid
 */
export function validateHub(hub: unknown): asserts hub is HarmonyHub {
  if (!hub || typeof hub !== "object") {
    throw new HarmonyError("Invalid hub: must be an object", ErrorCategory.DATA);
  }
  validateString((hub as HarmonyHub).id, "hub.id");
  validateString((hub as HarmonyHub).name, "hub.name");
  validateString((hub as HarmonyHub).ip, "hub.ip");
}
/**
 * Validates a HarmonyCommand object
 * @param command The command to validate
 * @throws {HarmonyError} If the command is invalid
 */
export function validateCommand(command: unknown): asserts command is HarmonyCommand {
  if (!command || typeof command !== "object") {
    throw new HarmonyError(
      "Invalid command: must be an object",
      ErrorCategory.DATA
    );
  }
  validateString((command as HarmonyCommand).id, "command.id");
  validateString((command as HarmonyCommand).name, "command.name");
  validateString((command as HarmonyCommand).label, "command.label");
  validateString((command as HarmonyCommand).deviceId, "command.deviceId");
}
/**
 * Validates a HarmonyDevice object
 * @param device The device to validate
 * @throws {HarmonyError} If the device is invalid
 */
export function validateDevice(device: unknown): asserts device is HarmonyDevice {
  if (!device || typeof device !== "object") {
    throw new HarmonyError(
      "Invalid device: must be an object",
      ErrorCategory.DATA
    );
  }
  validateString((device as HarmonyDevice).id, "device.id");
  validateString((device as HarmonyDevice).name, "device.name");
  validateString((device as HarmonyDevice).type, "device.type");
  validateArray((device as HarmonyDevice).commands, "device.commands", validateCommand);
}
/**
 * Validates a HarmonyActivity object
 * @param activity The activity to validate
 * @throws {HarmonyError} If the activity is invalid
 */
export function validateActivity(activity: unknown): asserts activity is HarmonyActivity {
  if (!activity || typeof activity !== "object") {
    throw new HarmonyError(
      "Invalid activity: must be an object",
      ErrorCategory.DATA
    );
  }
  validateString((activity as HarmonyActivity).id, "activity.id");
  validateString((activity as HarmonyActivity).name, "activity.name");
  validateString((activity as HarmonyActivity).type, "activity.type");
  if (typeof (activity as HarmonyActivity).isCurrent !== "boolean") {
    throw new HarmonyError(
      "Invalid activity.isCurrent: must be a boolean",
      ErrorCategory.DATA
    );
  }
}
/**
 * Validates a LoadingState object
 * @param state The loading state to validate
 * @throws {HarmonyError} If the loading state is invalid
 */
export function validateLoadingState(state: unknown): asserts state is LoadingState {
  if (!state || typeof state !== "object") {
    throw new HarmonyError(
      "Invalid loading state: must be an object",
      ErrorCategory.DATA
    );
  }
  validateString((state as LoadingState).stage, "loadingState.stage");
  validateNumber((state as LoadingState).progress, "loadingState.progress");
  validateString((state as LoadingState).message, "loadingState.message");
  const progress = (state as LoadingState).progress;
  if (progress < 0 || progress > 1) {
    throw new HarmonyError(
      "Invalid loadingState.progress: must be between 0 and 1",
      ErrorCategory.DATA
    );
  }
}
</file>

<file path="src/types/core/views.ts">
/**
 * View-related type definitions
 * @module
 */
import type { HarmonyDevice, HarmonyActivity } from './harmony';
import type { Draft } from 'immer';
/**
 * Available views in the application
 */
export enum View {
  HUBS = 'hubs',
  DEVICES = 'devices',
  ACTIVITIES = 'activities',
  DEVICE_DETAIL = 'device_detail',
  ACTIVITY_DETAIL = 'activity_detail'
}
/**
 * View state for the application
 */
export interface ViewState {
  /** Current active view */
  readonly currentView: View;
  /** Selected device for detail view */
  readonly selectedDevice: HarmonyDevice | null;
  /** Selected activity for detail view */
  readonly selectedActivity: HarmonyActivity | null;
  /** Search query for current view */
  readonly searchQuery: string;
  /** Filter settings */
  readonly filters: ViewFilters;
}
/**
 * Mutable view state for Immer
 */
export interface MutableViewState {
  /** Current active view */
  currentView: View;
  /** Selected device for detail view */
  selectedDevice: Draft<HarmonyDevice> | null;
  /** Selected activity for detail view */
  selectedActivity: Draft<HarmonyActivity> | null;
  /** Search query for current view */
  searchQuery: string;
  /** Filter settings */
  filters: MutableViewFilters;
}
/**
 * Filter settings for views
 */
export interface ViewFilters {
  /** Device type filter */
  readonly deviceType?: string;
  /** Activity type filter */
  readonly activityType?: string;
  /** Show only favorite items */
  readonly showFavorites: boolean;
}
/**
 * Mutable filter settings for Immer
 */
export interface MutableViewFilters {
  /** Device type filter */
  deviceType?: string;
  /** Activity type filter */
  activityType?: string;
  /** Show only favorite items */
  showFavorites: boolean;
}
/**
 * View transition events
 */
export type ViewEvent =
  | { type: 'VIEW_CHANGE'; view: View }
  | { type: 'SELECT_DEVICE'; device: HarmonyDevice }
  | { type: 'SELECT_ACTIVITY'; activity: HarmonyActivity }
  | { type: 'CLEAR_SELECTION' }
  | { type: 'SET_SEARCH'; query: string }
  | { type: 'SET_FILTERS'; filters: Partial<ViewFilters> };
/**
 * View action handlers
 */
export interface ViewActions {
  /** Change the current view */
  changeView: (view: View) => void;
  /** Select a device for detail view */
  selectDevice: (device: HarmonyDevice) => void;
  /** Select an activity for detail view */
  selectActivity: (activity: HarmonyActivity) => void;
  /** Clear current selection */
  clearSelection: () => void;
  /** Update search query */
  setSearch: (query: string) => void;
  /** Update filter settings */
  setFilters: (filters: Partial<ViewFilters>) => void;
}
</file>

<file path="src/types/core/websocket.ts">
/**
 * WebSocket-related type definitions for Harmony Hub integration
 * @module
 */
import type { HarmonyActivity, HarmonyDevice, HarmonyCommand } from "./harmony";
/**
 * WebSocket connection status
 * @enum {string}
 */
export enum WebSocketConnectionStatus {
  /** The WebSocket connection is closed */
  DISCONNECTED = "disconnected",
  /** The WebSocket connection is being established */
  CONNECTING = "connecting",
  /** The WebSocket connection is established */
  CONNECTED = "connected"
}
/**
 * WebSocket message types for Harmony Hub communication
 * @enum {string}
 */
export enum WebSocketMessageType {
  /** Request to start an activity */
  START_ACTIVITY = "startActivity",
  /** Request to stop an activity */
  STOP_ACTIVITY = "stopActivity",
  /** Request to get activities */
  GET_ACTIVITIES = "getactivities",
  /** Request to get devices */
  GET_DEVICES = "getdevices",
  /** Request to execute a command */
  EXECUTE_COMMAND = "executecommand"
}
/**
 * Base interface for all WebSocket messages
 * @interface WebSocketMessage
 */
export interface WebSocketMessage<T = unknown> {
  /** Type of the message */
  readonly type: WebSocketMessageType;
  /** Payload of the message */
  readonly payload: T;
}
/**
 * Payload for command execution requests
 * @interface CommandPayload
 */
export interface CommandPayload {
  /** Device to send command to */
  readonly deviceId: string;
  /** Command to execute */
  readonly command: string;
}
/**
 * Payload for activity control requests
 * @interface ActivityPayload
 */
export interface ActivityPayload {
  /** Activity to control */
  readonly activityId: string;
  /** Optional timestamp */
  readonly timestamp?: number;
  /** Optional status */
  readonly status?: string;
}
/**
 * Union type of all possible WebSocket messages
 * @type {WebSocketMessageUnion}
 */
export type WebSocketMessageUnion =
  | WebSocketMessage<ActivityPayload>
  | WebSocketMessage<CommandPayload>
  | WebSocketMessage<Record<string, never>>;
/**
 * WebSocket response interface
 * @interface WebSocketResponse
 */
export interface WebSocketResponse<T> {
  /** Unique identifier for the response */
  readonly id: string;
  /** Status of the response */
  readonly status: "success" | "error";
  /** Optional response data */
  readonly data?: T;
  /** Optional error information */
  readonly error?: string;
}
/**
 * Activity response interface
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse extends WebSocketResponse<HarmonyActivity[]> {
  /** List of activities */
  readonly activities: Array<{
    /** Activity ID */
    readonly id: string;
    /** Activity name */
    readonly name: string;
    /** Activity type */
    readonly type: string;
    /** Whether this activity is currently active */
    readonly isCurrent: boolean;
  }>;
}
/**
 * Device response interface
 * @interface DevicesResponse
 */
export interface DevicesResponse extends WebSocketResponse<HarmonyDevice[]> {
  /** List of devices */
  readonly devices: Array<{
    /** Device ID */
    readonly id: string;
    /** Device name */
    readonly name: string;
    /** Device type */
    readonly type: string;
    /** Device commands */
    readonly commands: Array<{
      /** Command ID */
      readonly id: string;
      /** Command name */
      readonly name: string;
      /** Command label */
      readonly label: string;
      /** Command group */
      readonly group?: string;
    }>;
  }>;
}
/**
 * WebSocket event handler type
 * @type {WebSocketEventHandler}
 */
export type WebSocketEventHandler = (message: WebSocketMessageUnion) => void;
/**
 * WebSocket error handler type
 * @type {WebSocketErrorHandler}
 */
export type WebSocketErrorHandler = (error: Error) => void;
/**
 * Queued message interface
 * @interface QueuedMessage
 */
export interface QueuedMessage<T> {
  /** Unique identifier for the message */
  readonly id: string;
  /** Resolve function for the message */
  readonly resolve: (value: WebSocketResponse<T>) => void;
  /** Reject function for the message */
  readonly reject: (error: Error) => void;
  /** Timestamp for the message */
  readonly timestamp: number;
}
</file>

<file path="src/types/components.ts">
/**
 * React component Props types.
 * @module
 */
import { Icon } from "@raycast/api";
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import { HarmonyError } from "./core/errors";
/**
 * Props for components that display feedback states (loading, error, empty)
 * @interface FeedbackStateProps
 */
export interface FeedbackStateProps {
  /**
   * Title text to display
   */
  title: string;
  /**
   * Optional description or details
   */
  description?: string;
  /**
   * Icon to display with the feedback
   */
  icon?: Icon;
  /**
   * Optional color for styling
   */
  color?: string;
  /**
   * Optional actions that can be taken from this state
   */
  actions?: React.ReactNode;
}
/**
 * Props for HarmonyCommand component
 * @interface HarmonyCommandProps
 */
export interface HarmonyCommandProps {
  /**
   * Command title
   */
  title: string;
  /**
   * Command subtitle
   */
  subtitle?: string;
  /**
   * Command icon
   */
  icon?: Icon;
  /**
   * Action to execute when command is selected
   */
  onAction: () => void | Promise<void>;
  /**
   * Whether the command is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
}
/**
 * Props for the DeviceList component
 * @interface DeviceListProps
 */
export interface DeviceListProps {
  /**
   * List of devices to display
   */
  devices: HarmonyDevice[];
  /**
   * Currently selected device
   */
  selectedDevice?: HarmonyDevice;
  /**
   * Action to execute when a device is selected
   */
  onDeviceSelect: (device: HarmonyDevice) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for device types
   */
  deviceType?: string;
  /**
   * Optional filter for specific device IDs
   */
  deviceIds?: string[];
  /**
   * Optional custom render function for device items
   */
  renderItem?: (device: HarmonyDevice) => React.ReactNode;
}
/**
 * Props for the ActivityList component
 * @interface ActivityListProps
 */
export interface ActivityListProps {
  /**
   * List of activities to display
   */
  activities: HarmonyActivity[];
  /**
   * Currently active activity
   */
  currentActivity?: HarmonyActivity;
  /**
   * Action to execute when an activity is selected
   */
  onActivitySelect: (activity: HarmonyActivity) => void;
  /**
   * Whether the list is currently loading
   */
  isLoading?: boolean;
  /**
   * Error state
   */
  error?: HarmonyError;
  /**
   * Optional filter for activity types
   */
  activityType?: string;
  /**
   * Optional filter for specific activity IDs
   */
  activityIds?: string[];
  /**
   * Optional custom render function for activity items
   */
  renderItem?: (activity: HarmonyActivity) => React.ReactNode;
}
/**
 * Props for the HarmonyContext provider
 * @interface HarmonyContextProps
 */
export interface HarmonyContextProps {
  /**
   * Connected Harmony Hub instance
   */
  hub: HarmonyHub | null;
  /**
   * List of available devices
   */
  devices: HarmonyDevice[];
  /**
   * List of available activities
   */
  activities: HarmonyActivity[];
  /**
   * Currently running activity
   */
  currentActivity: HarmonyActivity | null;
  /**
   * Loading state indicator
   */
  isLoading: boolean;
  /**
   * Error state if any
   */
  error: Error | null;
  /**
   * Function to refresh hub connection
   */
  refresh: () => Promise<void>;
  /**
   * Function to execute device command
   */
  executeCommand: (deviceId: string, command: string) => Promise<void>;
  /**
   * Function to start activity
   */
  startActivity: (activityId: string) => Promise<void>;
}
/**
 * Props for the ErrorBoundary component
 * @interface ErrorBoundaryProps
 */
export interface ErrorBoundaryProps {
  /**
   * Child components to wrap with error boundary
   */
  children: React.ReactNode;
  /**
   * Optional custom error renderer
   */
  renderError?: (error: Error) => React.ReactNode;
  /**
   * Optional error handler callback
   */
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}
/**
 * Props for the ErrorDisplay component
 * @interface ErrorDisplayProps
 */
export interface ErrorDisplayProps {
  /**
   * Error to display
   */
  error: HarmonyError;
  /**
   * Action to execute when retry is clicked
   */
  onRetry?: () => void;
  /**
   * Action to execute when dismiss is clicked
   */
  onDismiss?: () => void;
}
/**
 * Props for the HubSelector component
 * @interface HubSelectorProps
 */
export interface HubSelectorProps {
  /** List of available Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Callback when a hub is selected */
  onHubSelect: (hub: HarmonyHub) => void;
  /** Whether the component is in a loading state */
  isLoading?: boolean;
  /** Error state if any */
  error?: HarmonyError;
}
/**
 * Props for the LoadingIndicator component
 * @interface LoadingIndicatorProps
 */
export interface LoadingIndicatorProps {
  /**
   * Loading message to display
   */
  message?: string;
  /**
   * Progress percentage (0-100)
   */
  progress?: number;
}
</file>

<file path="src/types/harmony.ts">
/**
 * Types and interfaces for Harmony Hub integration.
 * @module
 */
/**
 * Represents a Logitech Harmony Hub device
 */
export interface HarmonyHub {
  /** Unique identifier for the hub */
  id: string;
  /** User-friendly name of the hub */
  name: string;
  /** Remote ID assigned by Harmony service */
  remoteId?: string;
  /** IP address of the hub on the local network */
  ip: string;
  /** Hub ID from Logitech service */
  hubId?: string;
  /** Version of the hub firmware */
  version?: string;
  /** Port number for hub communication */
  port?: string;
  /** Product ID of the hub */
  productId?: string;
  /** Protocol versions supported by the hub */
  protocolVersion?: string;
}
/**
 * Represents a device controlled by the Harmony Hub
 */
export interface HarmonyDevice {
  /** Unique identifier for the device */
  id: string;
  /** User-friendly name of the device */
  name: string;
  /** Type of device (e.g., TV, Receiver) */
  type: string;
  /** Available commands for this device */
  commands: HarmonyCommand[];
}
/**
 * Represents a command that can be sent to a device
 */
export interface HarmonyCommand {
  /** Command identifier */
  id: string;
  /** Command name */
  name: string;
  /** User-friendly label */
  label: string;
  /** ID of the device this command belongs to */
  deviceId: string;
  /** Optional command group for categorization */
  group?: string;
}
/**
 * Command queue configuration
 */
export interface CommandQueueConfig {
  /** Maximum number of commands that can be queued */
  maxQueueSize?: number;
  /** Maximum number of commands that can run concurrently */
  maxConcurrent?: number;
  /** Default timeout for command execution in milliseconds */
  defaultTimeout?: number;
  /** Default number of retries for failed commands */
  defaultRetries?: number;
  /** Delay between commands in milliseconds */
  commandDelay?: number;
}
/**
 * Represents an activity configured on the Harmony Hub
 */
export interface HarmonyActivity {
  /** Activity identifier */
  id: string;
  /** User-friendly name */
  name: string;
  /** Type of activity */
  type: string;
  /** Whether this is the current activity */
  isCurrent: boolean;
}
/**
 * Stage of the Harmony Hub connection process
 */
export enum HarmonyStage {
  /** Initial state */
  INITIAL = "initial",
  /** Discovering hubs */
  DISCOVERING = "discovering",
  /** Connecting to hub */
  CONNECTING = "connecting",
  /** Loading devices */
  LOADING_DEVICES = "loading_devices",
  /** Loading activities */
  LOADING_ACTIVITIES = "loading_activities",
  /** Starting activity */
  STARTING_ACTIVITY = "starting_activity",
  /** Stopping activity */
  STOPPING_ACTIVITY = "stopping_activity",
  /** Executing command */
  EXECUTING_COMMAND = "executing_command",
  /** Refreshing state */
  REFRESHING = "refreshing",
  /** Connected and ready */
  CONNECTED = "connected",
  /** Error state */
  ERROR = "error"
}
/**
 * Loading state information
 */
export interface LoadingState {
  /** Current stage of the process */
  stage: HarmonyStage;
  /** Progress from 0 to 1 */
  progress: number;
  /** User-friendly message */
  message: string;
}
/**
 * Current state of the Harmony Hub system
 */
export interface HarmonyState {
  /** Available Harmony Hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Available devices */
  devices: HarmonyDevice[];
  /** Available activities */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Current error if any */
  error: Error | null;
  /** Current loading state */
  loadingState: LoadingState;
}
/**
 * Error categories for Harmony operations
 */
export enum ErrorCategory {
  /** Network or connectivity errors */
  CONNECTION = "connection",
  /** Hub discovery errors */
  DISCOVERY = "discovery",
  /** Command execution errors */
  COMMAND = "command",
  /** State management errors */
  STATE = "state",
  /** Data retrieval or parsing errors */
  DATA = "data"
}
import { WebSocket } from "ws";
/**
 * WebSocket message format from Harmony Hub
 */
export interface HarmonyMessage {
  type: string;
  data?: {
    id?: string;
    status?: string;
    errorCode?: string;
    errorMessage?: string;
    [key: string]: unknown;
  };
}
/**
 * Message handler type.
 */
export type MessageHandler = (message: HarmonyMessage) => void;
/**
 * Error handler type.
 */
export type ErrorHandler = (error: Error) => void;
/**
 * Hub discovery handler type.
 */
export type HubDiscoveryHandler = (hub: HarmonyHub) => void;
/**
 * Status of a command in the queue
 */
export enum CommandStatus {
  /** Command is queued for execution */
  QUEUED = "QUEUED",
  /** Command is pending execution */
  PENDING = "PENDING",
  /** Command is currently executing */
  EXECUTING = "EXECUTING",
  /** Command has completed successfully */
  COMPLETED = "COMPLETED",
  /** Command has failed */
  FAILED = "FAILED",
  /** Command was cancelled */
  CANCELLED = "CANCELLED"
}
/**
 * Command request for the queue
 */
export interface CommandRequest {
  /** Unique identifier for the command request */
  id: string;
  /** Command to execute */
  command: HarmonyCommand;
  /** Timestamp when the request was created */
  timestamp: number;
  /** Optional timeout in milliseconds */
  timeout?: number;
  /** Optional number of retries */
  retries?: number;
  /** Optional callback when command completes successfully */
  onComplete?: () => void;
  /** Optional callback when command fails */
  onError?: (error: Error) => void;
}
/**
 * Result of a command execution
 */
export interface CommandResult {
  /** Unique identifier matching the request */
  id: string;
  /** Command that was executed */
  command: HarmonyCommand;
  /** Current status of the command */
  status: CommandStatus;
  /** Error if command failed */
  error?: Error;
  /** When the command was queued */
  queuedAt: number;
  /** When the command started executing */
  startedAt?: number;
  /** When the command completed (success or failure) */
  completedAt?: number;
}
</file>

<file path="src/types/logging.ts">
/**
 * Log levels for application logging
 * @enum {number}
 */
export enum LogLevel {
  /** Debug level for detailed troubleshooting */
  DEBUG = 0,
  /** Info level for general operational messages */
  INFO = 1,
  /** Warning level for potentially problematic situations */
  WARN = 2,
  /** Error level for error conditions */
  ERROR = 3
}
/**
 * Interface for logger configuration options
 * @interface LoggerOptions
 */
export interface LoggerOptions {
  /** Minimum log level to record */
  minLevel?: LogLevel;
  /** Maximum number of log entries to keep in memory */
  maxEntries?: number;
  /** Whether to include timestamps in log entries */
  includeTimestamp?: boolean;
  /** Whether to include log level in entries */
  includeLevel?: boolean;
}
/**
 * Structure of a log entry
 * @interface LogEntry
 */
export interface LogEntry {
  /** ISO timestamp of when the entry was created */
  timestamp: string;
  /** Log level of the entry */
  level: LogLevel;
  /** Log message */
  message: string;
  /** Optional additional data */
  data?: unknown;
}
/**
 * Interface for logger implementations
 * @interface ILogger
 */
export interface ILogger {
  /**
   * Log a debug message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  debug(message: string, data?: unknown): void;
  /**
   * Log an info message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  info(message: string, data?: unknown): void;
  /**
   * Log a warning message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  warn(message: string, data?: unknown): void;
  /**
   * Log an error message
   * @param message - Message to log
   * @param data - Optional data to include
   */
  error(message: string, data?: unknown): void;
  /**
   * Log an error with full stack trace
   * @param error - Error to log
   * @param context - Optional context information
   */
  logError(error: Error, context?: string): void;
  /**
   * Get log history
   */
  getHistory(): LogEntry[];
  /**
   * Clear log history
   */
  clearHistory(): void;
  /**
   * Set minimum log level
   */
  setMinLevel(level: LogLevel): void;
}
/**
 * Type for log entry filter functions
 * @type {LogFilter}
 */
export type LogFilter = (entry: LogEntry) => boolean;
/**
 * Type for log entry formatter functions
 * @type {LogFormatter}
 */
export type LogFormatter = (entry: LogEntry) => string;
</file>

<file path="src/types/preferences.ts">
/**
 * Preferences for the Harmony extension.
 */
export interface Preferences {
  /** The default view to display */
  defaultView: "activities" | "devices";
  /** The duration to hold a command in milliseconds */
  commandHoldTime: string;
  /** Whether to enable debug mode */
  debugMode: boolean;
  /** Whether to auto-retry failed commands */
  autoRetry: boolean;
  /** The maximum number of retries */
  maxRetries: string;
}
</file>

<file path="src/types/state.ts">
import { HarmonyHub, HarmonyDevice, HarmonyActivity } from "./harmony";
import { HarmonyError } from "./core/errors";
/**
 * State machine states for Harmony Hub control
 * @enum {string}
 */
export enum MachineState {
  /** Initial state */
  IDLE = "IDLE",
  /** Discovering available hubs */
  DISCOVERING = "DISCOVERING",
  /** Connecting to a hub */
  CONNECTING = "CONNECTING",
  /** Connected to a hub */
  CONNECTED = "CONNECTED",
  /** Error state */
  ERROR = "ERROR",
}
/**
 * Context data for Harmony state machine
 * @interface MachineContext
 */
export interface MachineContext {
  /** List of available hubs */
  hubs: HarmonyHub[];
  /** Currently selected hub */
  selectedHub: HarmonyHub | null;
  /** Available devices on the hub */
  devices: HarmonyDevice[];
  /** Available activities on the hub */
  activities: HarmonyActivity[];
  /** Currently running activity */
  currentActivity: HarmonyActivity | null;
  /** Error state if any */
  error: HarmonyError | null;
}
/**
 * Event payload for hub discovery
 * @interface DiscoverEvent
 */
export interface DiscoverEvent {
  type: "DISCOVER";
}
/**
 * Event payload for hub selection
 * @interface SelectHubEvent
 */
export interface SelectHubEvent {
  type: "SELECT_HUB";
  /** Hub to select */
  hub: HarmonyHub;
}
/**
 * Event payload for state refresh
 * @interface RefreshEvent
 */
export interface RefreshEvent {
  type: "REFRESH";
}
/**
 * Event payload for retrying a failed action
 * @interface RetryEvent
 */
export interface RetryEvent {
  type: "RETRY";
}
/**
 * Event payload for clearing the state
 * @interface ClearEvent
 */
export interface ClearEvent {
  type: "CLEAR";
}
/**
 * Event payload for hub disconnection
 * @interface DisconnectEvent
 */
export interface DisconnectEvent {
  type: "DISCONNECT";
}
/**
 * Event payload for error state
 * @interface ErrorEvent
 */
export interface ErrorEvent {
  type: "error.platform";
  /** Error that occurred */
  data: HarmonyError;
}
/**
 * Event payload for done discovering hubs
 * @interface DoneDiscoverEvent
 */
export interface DoneDiscoverEvent {
  type: "done.invoke.discoverHubs";
  /** List of discovered hubs */
  data: {
    hubs: HarmonyHub[];
  };
}
/**
 * Event payload for done loading hub data
 * @interface DoneLoadHubEvent
 */
export interface DoneLoadHubEvent {
  type: "done.invoke.loadHubData";
  /** Loaded hub data */
  data: {
    devices: HarmonyDevice[];
    activities: HarmonyActivity[];
  };
}
/**
 * Union type of all possible state machine events
 * @type {MachineEvent}
 */
export type MachineEvent =
  | DiscoverEvent
  | SelectHubEvent
  | DisconnectEvent
  | RefreshEvent
  | RetryEvent
  | ClearEvent
  | ErrorEvent
  | DoneDiscoverEvent
  | DoneLoadHubEvent;
/**
 * Service types for XState
 * @interface MachineServices
 */
export interface MachineServices {
  discoverHubs: {
    data: { hubs: HarmonyHub[] };
  };
  loadHubData: {
    data: { devices: HarmonyDevice[]; activities: HarmonyActivity[] };
  };
}
</file>

<file path="src/types/websocket.ts">
/**
 * WebSocket-related types for Harmony Hub communication.
 * @module
 */
import { HarmonyError } from "./core/errors";
import { HarmonyActivity, HarmonyDevice } from "./harmony";
/**
 * WebSocket connection status
 * @enum {string}
 */
export enum WebSocketConnectionStatus {
  /** The WebSocket connection is closed. */
  DISCONNECTED = "disconnected",
  /** The WebSocket connection is being established. */
  CONNECTING = "connecting",
  /** The WebSocket connection is established. */
  CONNECTED = "connected",
}
/**
 * WebSocket message types for Harmony Hub communication
 * @enum {string}
 */
export enum WebSocketMessageType {
  /** Request to start an activity */
  START_ACTIVITY = "startActivity",
  /** Request to stop an activity */
  STOP_ACTIVITY = "stopActivity",
  /** Request to get activities */
  GET_ACTIVITIES = "getactivities",
  /** Request to get devices */
  GET_DEVICES = "getdevices",
  /** Request to execute a command */
  EXECUTE_COMMAND = "executecommand",
}
/**
 * Base interface for all WebSocket messages
 * @interface WebSocketMessage
 */
export interface WebSocketMessage<T = unknown> {
  /** Type of the message */
  type: WebSocketMessageType;
  /** Payload of the message */
  payload: T;
}
/**
 * Payload for command execution requests
 * @interface CommandPayload
 */
export interface CommandPayload {
  /** Device to send command to */
  deviceId: string;
  /** Command to execute */
  command: string;
}
/**
 * Payload for activity control requests
 * @interface ActivityPayload
 */
export interface ActivityPayload {
  /** Activity to control */
  activityId: string;
  /** Optional timestamp */
  timestamp?: number;
  /** Optional status */
  status?: string;
}
/**
 * Union type of all possible WebSocket messages
 * @type {WebSocketMessageUnion}
 */
export type WebSocketMessageUnion =
  | WebSocketMessage<ActivityPayload>
  | WebSocketMessage<CommandPayload>
  | WebSocketMessage<Record<string, never>>;
/**
 * WebSocket response interface
 * @interface WebSocketResponse
 */
export interface WebSocketResponse<T> {
  /** Unique identifier for the response */
  id: string;
  /** Status of the response */
  status: "success" | "error";
  /** Optional response data */
  data?: T;
  /** Optional error information */
  error?: string;
}
/**
 * Activity response interface
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse extends WebSocketResponse<HarmonyActivity[]> {
  /** List of activities */
  activities: Array<{
    /** Activity ID */
    id: string;
    /** Activity name */
    name: string;
    /** Activity type */
    type: string;
    /** Whether this activity is currently active */
    isCurrent: boolean;
  }>;
}
/**
 * Device response interface
 * @interface DevicesResponse
 */
export interface DevicesResponse extends WebSocketResponse<HarmonyDevice[]> {
  /** List of devices */
  devices: Array<{
    /** Device ID */
    id: string;
    /** Device name */
    name: string;
    /** Device type */
    type: string;
    /** Device commands */
    commands: Array<{
      /** Command ID */
      id: string;
      /** Command name */
      name: string;
      /** Command label */
      label: string;
      /** Command group */
      group?: string;
    }>;
  }>;
}
/**
 * WebSocket event handler type
 * @type {WebSocketEventHandler}
 */
export type WebSocketEventHandler = (message: WebSocketMessageUnion) => void;
/**
 * WebSocket error handler type
 * @type {WebSocketErrorHandler}
 */
export type WebSocketErrorHandler = (error: Error) => void;
/**
 * Queued message interface
 * @interface QueuedMessage
 */
export interface QueuedMessage<T> {
  /** Unique identifier for the message */
  id: string;
  /** Resolve function for the message */
  resolve: (value: WebSocketResponse<T>) => void;
  /** Reject function for the message */
  reject: (error: Error) => void;
  /** Timestamp for the message */
  timestamp: number;
}
</file>

<file path="src/ui/components/actions/ActivityActionPanel.tsx">
import { Action, ActionPanel, Icon } from "@raycast/api";
import { HarmonyActivity } from "../../../types/core/harmony";
import { BaseActionPanel, BaseActionPanelProps } from "./BaseActionPanel";
interface ActivityActionPanelProps extends BaseActionPanelProps {
  activity: HarmonyActivity;
  isCurrentActivity: boolean;
  onStartActivity: () => void;
  onStopActivity: () => void;
  onCopyId?: () => void;
}
export function ActivityActionPanel({
  activity,
  isCurrentActivity,
  onStartActivity,
  onStopActivity,
  onCopyId,
  ...baseProps
}: ActivityActionPanelProps) {
  return (
    <BaseActionPanel {...baseProps}>
      <ActionPanel.Section title="Activity Controls">
        {!isCurrentActivity ? (
          <Action
            title="Start Activity"
            icon={Icon.Play}
            shortcut={{ modifiers: ["cmd"], key: "return" }}
            onAction={onStartActivity}
          />
        ) : (
          <Action
            title="Stop Activity"
            icon={Icon.Stop}
            shortcut={{ modifiers: ["cmd"], key: "return" }}
            onAction={onStopActivity}
          />
        )}
      </ActionPanel.Section>
      {onCopyId && (
        <ActionPanel.Section>
          <Action
            title="Copy Activity ID"
            icon={Icon.Clipboard}
            shortcut={{ modifiers: ["cmd"], key: "." }}
            onAction={onCopyId}
          />
        </ActionPanel.Section>
      )}
    </BaseActionPanel>
  );
}
</file>

<file path="src/ui/components/actions/BaseActionPanel.tsx">
import { Action, ActionPanel, Icon } from "@raycast/api";
import { memo } from "react";
export interface BaseActionPanelProps {
  onRefresh?: () => void;
  onClearCache?: () => void;
  onReconnect?: () => void;
  children?: React.ReactNode;
}
function BaseActionPanelImpl({ onRefresh, onClearCache, onReconnect, children }: BaseActionPanelProps) {
  return (
    <ActionPanel>
      <ActionPanel.Section>
        {children}
      </ActionPanel.Section>
      <ActionPanel.Section title="Management">
        {onRefresh && (
          <Action
            icon={Icon.ArrowClockwise}
            title="Refresh"
            shortcut={{ modifiers: ["cmd"], key: "r" }}
            onAction={onRefresh}
          />
        )}
        {onReconnect && (
          <Action
            icon={Icon.Link}
            title="Reconnect"
            shortcut={{ modifiers: ["cmd", "shift"], key: "r" }}
            onAction={onReconnect}
          />
        )}
        {onClearCache && (
          <Action
            icon={Icon.Trash}
            title="Clear Cache"
            shortcut={{ modifiers: ["cmd"], key: "backspace" }}
            onAction={onClearCache}
          />
        )}
      </ActionPanel.Section>
    </ActionPanel>
  );
}
export const BaseActionPanel = memo(BaseActionPanelImpl, (prevProps, nextProps) => {
  return (
    prevProps.onRefresh === nextProps.onRefresh &&
    prevProps.onClearCache === nextProps.onClearCache &&
    prevProps.onReconnect === nextProps.onReconnect &&
    prevProps.children === nextProps.children
  );
});
</file>

<file path="src/ui/components/actions/DeviceActionPanel.tsx">
import { Action, ActionPanel, Icon } from "@raycast/api";
import { HarmonyDevice, HarmonyCommand } from "../../../types/core/harmony";
import { BaseActionPanel, BaseActionPanelProps } from "./BaseActionPanel";
interface DeviceActionPanelProps extends BaseActionPanelProps {
  device: HarmonyDevice;
  onExecuteCommand: (command: HarmonyCommand) => void;
  onCopyId?: () => void;
}
export function DeviceActionPanel({
  device,
  onExecuteCommand,
  onCopyId,
  ...baseProps
}: DeviceActionPanelProps) {
  return (
    <BaseActionPanel {...baseProps}>
      <ActionPanel.Section title="Device Commands">
        {device.commands.map((command) => (
          <Action
            key={command.id}
            title={command.label}
            icon={Icon.Terminal}
            onAction={() => onExecuteCommand(command)}
          />
        ))}
      </ActionPanel.Section>
      {onCopyId && (
        <ActionPanel.Section>
          <Action
            title="Copy Device ID"
            icon={Icon.Clipboard}
            shortcut={{ modifiers: ["cmd"], key: "." }}
            onAction={onCopyId}
          />
        </ActionPanel.Section>
      )}
    </BaseActionPanel>
  );
}
</file>

<file path="src/ui/components/views/ActivitiesView.tsx">
import { List, Icon, ActionPanel, Action } from "@raycast/api";
import { memo, useCallback, useMemo, useState } from "react";
import { HarmonyActivity, HarmonyStage, LoadingState } from "../../../types/core/harmony";
import { HarmonyError } from "../../../types/core/errors";
import { FeedbackState } from "../FeedbackState";
import { ActivityActionPanel } from "../actions/ActivityActionPanel";
import { useViewStore } from "../../../stores/view";
import { View } from "../../../types/core/views";
interface ActivitiesViewProps {
  activities: HarmonyActivity[];
  currentActivity: HarmonyActivity | null;
  loadingState: LoadingState | null;
  error: HarmonyError | null;
  onStartActivity: (activity: HarmonyActivity) => void;
  onStopActivity: () => void;
  onRefresh: () => void;
  onClearCache: () => void;
  onReconnect: () => void;
}
interface ActivityListItemProps {
  activity: HarmonyActivity;
  isCurrentActivity: boolean;
  onStartActivity: () => void;
  onStopActivity: () => void;
  onRefresh: () => void;
  onClearCache: () => void;
  onReconnect: () => void;
}
const ActivityListItem = memo(({
  activity,
  isCurrentActivity,
  onStartActivity,
  onStopActivity,
  onRefresh,
  onClearCache,
  onReconnect,
}: ActivityListItemProps) => (
  <List.Item
    key={activity.id}
    title={activity.name}
    subtitle={isCurrentActivity ? "Currently Running" : undefined}
    icon={isCurrentActivity ? Icon.Play : Icon.Stop}
    accessories={[
      {
        icon: isCurrentActivity ? Icon.CheckCircle : undefined,
        tooltip: isCurrentActivity ? "Currently Running" : undefined
      }
    ]}
    detail={
      <List.Item.Detail
        metadata={
          <List.Item.Detail.Metadata>
            <List.Item.Detail.Metadata.Label
              title="Activity Type"
              text={activity.type}
            />
            <List.Item.Detail.Metadata.Separator />
            <List.Item.Detail.Metadata.Label
              title="Status"
              text={isCurrentActivity ? "Running" : "Stopped"}
            />
            {isCurrentActivity && (
              <>
                <List.Item.Detail.Metadata.Separator />
                <List.Item.Detail.Metadata.Label
                  title="Action"
                  text="Press ⏎ to Stop"
                />
              </>
            )}
            {!isCurrentActivity && (
              <>
                <List.Item.Detail.Metadata.Separator />
                <List.Item.Detail.Metadata.Label
                  title="Action"
                  text="Press ⏎ to Start"
                />
              </>
            )}
          </List.Item.Detail.Metadata>
        }
      />
    }
    actions={
      <ActionPanel>
        <ActionPanel.Section>
          {isCurrentActivity ? (
            <Action
              title="Stop Activity"
              icon={Icon.Stop}
              onAction={onStopActivity}
            />
          ) : (
            <Action
              title="Start Activity"
              icon={Icon.Play}
              onAction={onStartActivity}
            />
          )}
        </ActionPanel.Section>
        <ActionPanel.Section title="Navigation">
          <Action
            title="Switch to Devices"
            icon={Icon.Devices}
            shortcut={{ modifiers: ["cmd", "shift"], key: "d" }}
            onAction={() => useViewStore.getState().changeView(View.DEVICES)}
          />
        </ActionPanel.Section>
        <ActionPanel.Section title="Management">
          {onRefresh && (
            <Action
              icon={Icon.ArrowClockwise}
              title="Refresh"
              shortcut={{ modifiers: ["cmd"], key: "r" }}
              onAction={onRefresh}
            />
          )}
          {onReconnect && (
            <Action
              icon={Icon.Link}
              title="Reconnect"
              shortcut={{ modifiers: ["cmd", "shift"], key: "r" }}
              onAction={onReconnect}
            />
          )}
          {onClearCache && (
            <Action
              icon={Icon.Trash}
              title="Clear Cache"
              shortcut={{ modifiers: ["cmd"], key: "backspace" }}
              onAction={onClearCache}
            />
          )}
        </ActionPanel.Section>
      </ActionPanel>
    }
  />
));
function ActivitiesViewImpl({
  activities,
  currentActivity,
  loadingState,
  error,
  onStartActivity,
  onStopActivity,
  onRefresh,
  onClearCache,
  onReconnect,
}: ActivitiesViewProps) {
  const [searchText, setSearchText] = useState("");
  const handleStartActivity = useCallback((activity: HarmonyActivity) => {
    onStartActivity(activity);
  }, [onStartActivity]);
  // Memoize filtered activities to prevent unnecessary recalculations
  const filteredActivities = useMemo(() => {
    if (!searchText) return activities;
    const lowerSearch = searchText.toLowerCase();
    return activities.filter(
      (activity) =>
        activity.name.toLowerCase().includes(lowerSearch) ||
        activity.type.toLowerCase().includes(lowerSearch)
    );
  }, [activities, searchText]);
  // Group activities by type for better organization
  const activitiesByType = useMemo(() => {
    const groups = new Map<string, HarmonyActivity[]>();
    filteredActivities.forEach((activity) => {
      const type = activity.type || "Other";
      const typeActivities = groups.get(type) || [];
      typeActivities.push(activity);
      groups.set(type, typeActivities);
    });
    return groups;
  }, [filteredActivities]);
  // Show error state if there's an error
  if (error) {
    return (
      <FeedbackState
        title="Activity Loading Error"
        description="Unable to load activities from the Harmony Hub"
        icon={Icon.ExclamationMark}
        error={error}
        onRetry={onRefresh}
        onClearCache={onClearCache}
        onReconnect={onReconnect}
      />
    );
  }
  // Show loading state while loading activities
  if (loadingState?.stage === HarmonyStage.LOADING_ACTIVITIES) {
    return (
      <FeedbackState
        title="Loading Activities"
        description={loadingState.message}
        icon={Icon.CircleProgress}
      />
    );
  }
  // Show loading state while starting/stopping activities
  if (loadingState?.stage === HarmonyStage.STARTING_ACTIVITY || 
      loadingState?.stage === HarmonyStage.STOPPING_ACTIVITY) {
    return (
      <FeedbackState
        title={loadingState.stage === HarmonyStage.STARTING_ACTIVITY ? 
          "Starting Activity" : "Stopping Activity"}
        description={loadingState.message}
        icon={Icon.CircleProgress}
      />
    );
  }
  // Show empty state if no activities found
  if (!activities.length) {
    return (
      <FeedbackState
        title="No Activities Found"
        description="No activities are configured on this Harmony Hub"
        icon={Icon.XMarkCircle}
        onRetry={onRefresh}
        onClearCache={onClearCache}
      />
    );
  }
  return (
    <List
      navigationTitle="Harmony Activities"
      searchBarPlaceholder="Search activities..."
      onSearchTextChange={setSearchText}
      isShowingDetail
    >
      {Array.from(activitiesByType.entries()).map(([type, activities]) => (
        <List.Section key={type} title={type}>
          {activities.map((activity) => (
            <ActivityListItem
              key={activity.id}
              activity={activity}
              isCurrentActivity={activity.id === currentActivity?.id}
              onStartActivity={() => handleStartActivity(activity)}
              onStopActivity={onStopActivity}
              onRefresh={onRefresh}
              onClearCache={onClearCache}
              onReconnect={onReconnect}
            />
          ))}
        </List.Section>
      ))}
    </List>
  );
}
export const ActivitiesView = memo(ActivitiesViewImpl);
</file>

<file path="src/ui/components/views/CommandsView.tsx">
import { List, Icon, ActionPanel, Action } from "@raycast/api";
import { memo, useCallback } from "react";
import { HarmonyDevice, HarmonyCommand } from "../../../types/core/harmony";
import { Logger } from "../../../services/logger";
import { useViewStore } from "../../../stores/view";
import { View } from "../../../types/core/views";
interface CommandsViewProps {
  device: HarmonyDevice;
  onExecuteCommand: (command: HarmonyCommand) => void;
  onBack: () => void;
}
interface CommandListItemProps {
  command: HarmonyCommand;
  onExecute: (command: HarmonyCommand) => void;
  onBack: () => void;
}
const CommandListItem = memo(({ command, onExecute, onBack }: CommandListItemProps) => (
  <List.Item
    key={command.id}
    title={command.label}
    icon={Icon.Terminal}
    actions={
      <ActionPanel>
        <ActionPanel.Section>
          <Action
            title={`Execute ${command.label}`}
            onAction={() => onExecute(command)}
          />
        </ActionPanel.Section>
        <ActionPanel.Section>
          <Action
            title="Back to Devices"
            icon={Icon.ArrowLeft}
            onAction={onBack}
            shortcut={{ modifiers: ["cmd"], key: "[" }}
          />
        </ActionPanel.Section>
      </ActionPanel>
    }
  />
));
function CommandsViewImpl({ device, onExecuteCommand, onBack }: CommandsViewProps) {
  const viewStore = useViewStore();
  const handleExecuteCommand = useCallback((command: HarmonyCommand) => {
    Logger.debug("Executing command", { command });
    onExecuteCommand(command);
  }, [onExecuteCommand]);
  const handleBack = useCallback(() => {
    viewStore.clearSelection();
    viewStore.changeView(View.DEVICES);
  }, [viewStore]);
  return (
    <List
      navigationTitle={`${device.name} Commands`}
      searchBarPlaceholder="Search commands..."
    >
      {device.commands.map((command) => (
        <CommandListItem
          key={command.id}
          command={command}
          onExecute={handleExecuteCommand}
          onBack={handleBack}
        />
      ))}
    </List>
  );
}
export const CommandsView = memo(CommandsViewImpl);
</file>

<file path="src/ui/components/views/DevicesView.tsx">
import { List, Icon, ActionPanel, Action } from "@raycast/api";
import { memo, useCallback, useMemo, useState } from "react";
import { HarmonyDevice, HarmonyCommand, LoadingState, HarmonyStage } from "../../../types/core/harmony";
import { HarmonyError } from "../../../types/core/errors";
import { FeedbackState } from "../FeedbackState";
import { Logger } from "../../../services/logger";
import { useViewStore } from "../../../stores/view";
import { View } from "../../../types/core/views";
interface DevicesViewProps {
  devices: HarmonyDevice[];
  loadingState: LoadingState | null;
  error: HarmonyError | null;
  onExecuteCommand: (command: HarmonyCommand) => void;
  onRefresh: () => void;
  onClearCache: () => void;
  onReconnect: () => void;
}
interface DeviceListItemProps {
  device: HarmonyDevice;
  searchText: string;
  onSelectDevice: (device: HarmonyDevice) => void;
  onRefresh: () => void;
  onClearCache: () => void;
  onReconnect: () => void;
}
const DeviceListItem = memo(({ 
  device, 
  searchText, 
  onSelectDevice, 
  onRefresh, 
  onClearCache, 
  onReconnect 
}: DeviceListItemProps) => {
  return (
    <List.Item
      key={device.id}
      id={device.id}
      title={device.name}
      subtitle={`${device.commands.length} commands`}
      icon={Icon.Devices}
      actions={
        <ActionPanel>
          <ActionPanel.Section>
            <Action
              title="View Commands"
              icon={Icon.Terminal}
              onAction={() => onSelectDevice(device)}
            />
          </ActionPanel.Section>
          <ActionPanel.Section title="Navigation">
            <Action
              title="Switch to Activities"
              icon={Icon.Play}
              shortcut={{ modifiers: ["cmd", "shift"], key: "a" }}
              onAction={() => useViewStore.getState().changeView(View.ACTIVITIES)}
            />
          </ActionPanel.Section>
          <ActionPanel.Section title="Management">
            {onRefresh && (
              <Action
                icon={Icon.ArrowClockwise}
                title="Refresh"
                shortcut={{ modifiers: ["cmd"], key: "r" }}
                onAction={onRefresh}
              />
            )}
            {onReconnect && (
              <Action
                icon={Icon.Link}
                title="Reconnect"
                shortcut={{ modifiers: ["cmd", "shift"], key: "r" }}
                onAction={onReconnect}
              />
            )}
            {onClearCache && (
              <Action
                icon={Icon.Trash}
                title="Clear Cache"
                shortcut={{ modifiers: ["cmd"], key: "backspace" }}
                onAction={onClearCache}
              />
            )}
          </ActionPanel.Section>
        </ActionPanel>
      }
    />
  );
});
function DevicesViewImpl({
  devices,
  loadingState,
  error,
  onExecuteCommand,
  onRefresh,
  onClearCache,
  onReconnect,
}: DevicesViewProps) {
  const [searchText, setSearchText] = useState("");
  const viewStore = useViewStore();
  const handleSelectDevice = useCallback((device: HarmonyDevice) => {
    Logger.debug("Selected device", { device });
    viewStore.selectDevice(device);
    setTimeout(() => {
      viewStore.changeView(View.DEVICE_DETAIL);
    }, 0);
  }, [viewStore]);
  // Memoize filtered devices to prevent unnecessary recalculations
  const filteredDevices = useMemo(() => {
    if (!searchText) return devices;
    const lowerSearch = searchText.toLowerCase();
    return devices.filter(
      (device) =>
        device.name.toLowerCase().includes(lowerSearch) ||
        device.type.toLowerCase().includes(lowerSearch) ||
        device.commands.some((cmd) => cmd.label.toLowerCase().includes(lowerSearch))
    );
  }, [devices, searchText]);
  // Group devices by type for better organization
  const devicesByType = useMemo(() => {
    const groups = new Map<string, HarmonyDevice[]>();
    filteredDevices.forEach((device) => {
      const type = device.type || "Other";
      const devices = groups.get(type) || [];
      devices.push(device);
      groups.set(type, devices);
    });
    return groups;
  }, [filteredDevices]);
  // Show error state if there's an error
  if (error) {
    return (
      <FeedbackState
        title="Device Loading Error"
        description="Unable to load devices from the Harmony Hub"
        icon={Icon.ExclamationMark}
        error={error}
        onRetry={onRefresh}
        onClearCache={onClearCache}
        onReconnect={onReconnect}
      />
    );
  }
  // Show loading state while loading devices
  if (loadingState?.stage === HarmonyStage.LOADING_DEVICES || 
      loadingState?.stage === HarmonyStage.LOADING_ACTIVITIES) {
    return (
      <FeedbackState
        title="Loading Devices"
        description={loadingState.message}
        icon={Icon.CircleProgress}
      />
    );
  }
  // Show empty state if no devices found
  if (!devices.length) {
    return (
      <FeedbackState
        title="No Devices Found"
        description="No devices are configured on this Harmony Hub"
        icon={Icon.XMarkCircle}
        onRetry={onRefresh}
        onClearCache={onClearCache}
      />
    );
  }
  Logger.debug("Rendering devices list", {
    totalDevices: devices.length,
    filteredCount: filteredDevices.length,
    deviceTypes: Array.from(devicesByType.keys())
  });
  return (
    <List
      navigationTitle="Harmony Devices"
      searchBarPlaceholder="Search devices..."
      onSearchTextChange={setSearchText}
    >
      {Array.from(devicesByType.entries()).map(([type, devices]) => (
        <List.Section key={type} title={type}>
          {devices.map((device) => (
            <DeviceListItem
              key={device.id}
              device={device}
              searchText={searchText}
              onSelectDevice={handleSelectDevice}
              onRefresh={onRefresh}
              onClearCache={onClearCache}
              onReconnect={onReconnect}
            />
          ))}
        </List.Section>
      ))}
    </List>
  );
}
export const DevicesView = memo(DevicesViewImpl);
</file>

<file path="src/ui/components/views/HarmonyCommand.tsx">
import React, { useEffect, useRef } from "react";
import { useHarmony } from "../../../hooks/useHarmony";
import { useViewStore } from "../../../stores/view";
import { View } from "../../../types/core/views";
import { HarmonyError } from "../../../types/core/errors";
import { HubsView } from "./HubsView";
import { DevicesView } from "./DevicesView";
import { ActivitiesView } from "./ActivitiesView";
import { CommandsView } from "./CommandsView";
import { Logger } from "../../../services/logger";
export function HarmonyCommand(): React.ReactElement {
  const {
    hubs,
    selectedHub,
    devices,
    activities,
    currentActivity,
    loadingState,
    error,
    connect,
    disconnect,
    refresh,
    executeCommand,
    clearCache,
    startActivity,
    stopActivity,
  } = useHarmony();
  const currentView = useViewStore((state) => state.currentView);
  const selectedDevice = useViewStore((state) => state.selectedDevice);
  const isMounted = useRef(false);
  const viewStore = useViewStore();
  // Start hub discovery on mount
  useEffect(() => {
    if (!isMounted.current) {
      Logger.info("HarmonyCommand mounted, starting refresh");
      refresh();
      isMounted.current = true;
    }
  }, [refresh]);
  // Log state changes
  useEffect(() => {
    Logger.debug("State updated", {
      currentView,
      hubCount: hubs.length,
      selectedHub: selectedHub?.name,
      deviceCount: devices.length,
      activityCount: activities.length,
      loadingState: loadingState?.stage,
      hasError: !!error
    });
  }, [currentView, hubs, selectedHub, devices, activities, loadingState, error]);
  // Handle view transitions based on state
  useEffect(() => {
    // If we have a selected hub but no devices are showing, switch to hubs view
    if (!selectedHub && currentView !== View.HUBS) {
      Logger.info("No hub selected, switching to hubs view");
      viewStore.changeView(View.HUBS);
      return;
    }
    // If we have a selected hub and devices, switch from hubs view
    if (selectedHub && devices.length > 0 && currentView === View.HUBS) {
      Logger.info("Hub selected with devices, switching from hubs view");
      viewStore.changeView(View.DEVICES); // The view store will handle the preference
    }
  }, [selectedHub, devices.length, currentView, viewStore]);
  // Handle device detail view transitions
  useEffect(() => {
    if (currentView === View.DEVICE_DETAIL && !selectedDevice) {
      Logger.info("No device selected, switching to devices view");
      viewStore.changeView(View.DEVICES);
    }
  }, [currentView, selectedDevice, viewStore]);
  // Handle view rendering based on current view state
  Logger.debug("Rendering view", { currentView });
  switch (currentView) {
    case View.HUBS:
      Logger.info("Rendering HubsView", {
        hubCount: hubs.length,
        selectedHub: selectedHub?.name,
        loadingState: loadingState?.stage
      });
      return (
        <HubsView
          hubs={hubs}
          selectedHub={selectedHub}
          loadingState={loadingState}
          error={error}
          onSelectHub={connect}
          onRefresh={refresh}
          onClearCache={clearCache}
        />
      );
    case View.DEVICES:
      Logger.info("Rendering DevicesView", {
        deviceCount: devices.length,
        loadingState: loadingState?.stage
      });
      return (
        <DevicesView
          devices={devices}
          loadingState={loadingState}
          error={error}
          onExecuteCommand={executeCommand}
          onRefresh={refresh}
          onClearCache={clearCache}
          onReconnect={disconnect}
        />
      );
    case View.DEVICE_DETAIL:
      if (!selectedDevice) {
        return (
          <DevicesView
            devices={devices}
            loadingState={loadingState}
            error={error}
            onExecuteCommand={executeCommand}
            onRefresh={refresh}
            onClearCache={clearCache}
            onReconnect={disconnect}
          />
        );
      }
      Logger.info("Rendering CommandsView", {
        device: selectedDevice.name,
        commandCount: selectedDevice.commands.length
      });
      return (
        <CommandsView
          device={selectedDevice}
          onExecuteCommand={executeCommand}
          onBack={() => viewStore.changeView(View.DEVICES)}
        />
      );
    case View.ACTIVITIES:
      Logger.info("Rendering ActivitiesView", {
        activityCount: activities.length,
        currentActivity: currentActivity?.name,
        loadingState: loadingState?.stage
      });
      return (
        <ActivitiesView
          activities={activities}
          currentActivity={currentActivity}
          loadingState={loadingState}
          error={error}
          onStartActivity={(activity) => startActivity(activity.id)}
          onStopActivity={stopActivity}
          onRefresh={refresh}
          onClearCache={clearCache}
          onReconnect={disconnect}
        />
      );
    default:
      Logger.info("Rendering default HubsView", {
        hubCount: hubs.length,
        selectedHub: selectedHub?.name,
        loadingState: loadingState?.stage
      });
      return (
        <HubsView
          hubs={hubs}
          selectedHub={selectedHub}
          loadingState={loadingState}
          error={error}
          onSelectHub={connect}
          onRefresh={refresh}
          onClearCache={clearCache}
        />
      );
  }
}
</file>

<file path="src/ui/components/views/HubsView.tsx">
import { List, Icon, Action } from "@raycast/api";
import { memo, useCallback } from "react";
import { HarmonyHub, HarmonyStage, LoadingState } from "../../../types/core/harmony";
import { HarmonyError } from "../../../types/core/errors";
import { FeedbackState } from "../FeedbackState";
import { BaseActionPanel } from "../actions/BaseActionPanel";
interface HubsViewProps {
  hubs: HarmonyHub[];
  selectedHub: HarmonyHub | null;
  loadingState: LoadingState | null;
  error: HarmonyError | null;
  onSelectHub: (hub: HarmonyHub) => void;
  onRefresh: () => void;
  onClearCache: () => void;
}
interface HubListItemProps {
  hub: HarmonyHub;
  isSelected: boolean;
  onSelectHub: (hub: HarmonyHub) => void;
  onRefresh: () => void;
  onClearCache: () => void;
}
const HubListItem = memo(({ hub, isSelected, onSelectHub, onRefresh, onClearCache }: HubListItemProps) => (
  <List.Item
    key={hub.id}
    title={hub.name}
    subtitle={hub.ip}
    icon={isSelected ? Icon.CheckCircle : Icon.Circle}
    accessories={[
      { text: hub.version || "Unknown Version" },
      { icon: isSelected ? Icon.Link : undefined },
    ]}
    actions={
      <BaseActionPanel
        onRefresh={onRefresh}
        onClearCache={onClearCache}
      >
        <Action
          title="Select Hub"
          icon={Icon.Link}
          onAction={() => onSelectHub(hub)}
        />
      </BaseActionPanel>
    }
  />
));
function HubsViewImpl({
  hubs,
  selectedHub,
  loadingState,
  error,
  onSelectHub,
  onRefresh,
  onClearCache,
}: HubsViewProps) {
  const handleSelectHub = useCallback((hub: HarmonyHub) => {
    onSelectHub(hub);
  }, [onSelectHub]);
  // Show error state if there's an error
  if (error) {
    return (
      <FeedbackState
        title="Hub Discovery Error"
        description="Unable to discover Harmony Hubs on your network"
        icon={Icon.ExclamationMark}
        error={error}
        onRetry={onRefresh}
        onClearCache={onClearCache}
      />
    );
  }
  // Show loading state while discovering
  if (loadingState?.stage === HarmonyStage.DISCOVERING) {
    return (
      <FeedbackState
        title="Discovering Hubs"
        description={loadingState.message}
        icon={Icon.CircleProgress}
      />
    );
  }
  // Show empty state if no hubs found
  if (!hubs.length) {
    return (
      <FeedbackState
        title="No Hubs Found"
        description="Make sure your Harmony Hub is powered on and connected to your network"
        icon={Icon.WifiDisabled}
        onRetry={onRefresh}
        onClearCache={onClearCache}
      />
    );
  }
  return (
    <List
      navigationTitle="Select Harmony Hub"
      searchBarPlaceholder="Search hubs..."
    >
      {hubs.map((hub) => (
        <HubListItem
          key={hub.id}
          hub={hub}
          isSelected={selectedHub?.id === hub.id}
          onSelectHub={handleSelectHub}
          onRefresh={onRefresh}
          onClearCache={onClearCache}
        />
      ))}
    </List>
  );
}
export const HubsView = memo(HubsViewImpl);
</file>

<file path="src/ui/components/FeedbackState.tsx">
import { ActionPanel, Action, Icon, Detail, Color } from "@raycast/api";
import { HarmonyError } from "../../types/core/errors";
import { ErrorCategory, ErrorRecoveryAction } from "../../types/core/harmony";
import { memo } from "react";
interface FeedbackStateProps {
  title: string;
  description?: string;
  icon?: Icon | { source: string };
  color?: string;
  actions?: React.ReactNode;
  error?: HarmonyError;
  onRetry?: () => void;
  onReconnect?: () => void;
  onClearCache?: () => void;
  onResetConfig?: () => void;
}
function getErrorColor(category: ErrorCategory): Color {
  switch (category) {
    case ErrorCategory.CONNECTION:
    case ErrorCategory.HUB_COMMUNICATION:
      return Color.Red;
    case ErrorCategory.DISCOVERY:
    case ErrorCategory.DATA:
      return Color.Orange;
    case ErrorCategory.COMMAND:
    case ErrorCategory.STATE:
      return Color.Yellow;
    default:
      return Color.SecondaryText;
  }
}
function getErrorIcon(category: ErrorCategory): Icon {
  switch (category) {
    case ErrorCategory.CONNECTION:
    case ErrorCategory.HUB_COMMUNICATION:
      return Icon.WifiDisabled;
    case ErrorCategory.DISCOVERY:
      return Icon.MagnifyingGlass;
    case ErrorCategory.COMMAND:
      return Icon.ExclamationMark;
    case ErrorCategory.STATE:
      return Icon.Warning;
    case ErrorCategory.DATA:
      return Icon.XMarkCircle;
    default:
      return Icon.ExclamationMark;
  }
}
function getRecoverySteps(error: HarmonyError): string[] {
  const steps: string[] = [];
  const actions = ErrorRecoveryAction;
  switch (error.category) {
    case ErrorCategory.CONNECTION:
    case ErrorCategory.HUB_COMMUNICATION:
      steps.push(
        "1. Check your network connection",
        "2. Verify the Harmony Hub is powered on",
        "3. Try reconnecting to the hub",
        "4. If issues persist, restart your hub"
      );
      break;
    case ErrorCategory.DISCOVERY:
      steps.push(
        "1. Ensure your hub is on the same network",
        "2. Check your firewall settings",
        "3. Try clearing the cache",
        "4. Attempt manual hub discovery"
      );
      break;
    case ErrorCategory.COMMAND:
      steps.push(
        "1. Wait a moment and try again",
        "2. Check if the device is powered on",
        "3. Verify the hub can control the device",
        "4. Try reconnecting to the hub"
      );
      break;
    case ErrorCategory.STATE:
      steps.push(
        "1. Try reconnecting to the hub",
        "2. Clear the local cache",
        "3. Reset the configuration",
        "4. If issues persist, restart the hub"
      );
      break;
    case ErrorCategory.DATA:
      steps.push(
        "1. Try refreshing the data",
        "2. Clear the local cache",
        "3. Reconnect to the hub",
        "4. Check hub connectivity"
      );
      break;
    default:
      steps.push(
        "1. Try the operation again",
        "2. Check hub connectivity",
        "3. Clear the local cache",
        "4. Contact support if issues persist"
      );
  }
  return steps;
}
function FeedbackStateImpl({
  title,
  description,
  icon,
  color,
  actions,
  error,
  onRetry,
  onReconnect,
  onClearCache,
  onResetConfig,
}: FeedbackStateProps) {
  const errorIcon = error ? getErrorIcon(error.category) : icon;
  const errorColor = error ? getErrorColor(error.category) : color;
  const recoverySteps = error ? getRecoverySteps(error) : [];
  const defaultActions = (
    <ActionPanel>
      {onRetry && (
        <Action
          title="Retry"
          icon={Icon.ArrowClockwise}
          onAction={onRetry}
          shortcut={{ modifiers: ["cmd"], key: "r" }}
        />
      )}
      {onReconnect && (
        <Action
          title="Reconnect"
          icon={Icon.Link}
          onAction={onReconnect}
          shortcut={{ modifiers: ["cmd", "shift"], key: "r" }}
        />
      )}
      {onClearCache && (
        <Action
          title="Clear Cache"
          icon={Icon.Trash}
          onAction={onClearCache}
          shortcut={{ modifiers: ["cmd"], key: "backspace" }}
        />
      )}
      {onResetConfig && (
        <Action
          title="Reset Configuration"
          icon={Icon.Gear}
          onAction={onResetConfig}
          shortcut={{ modifiers: ["cmd", "shift"], key: "backspace" }}
        />
      )}
      {actions}
    </ActionPanel>
  );
  const markdown = `
# ${title}
${description ? `\n${description}` : ""}
${error ? `
## Error Details
\`\`\`
${error.getUserMessage()}
${error.message}
\`\`\`
## Troubleshooting Steps
${recoverySteps.join("\n")}
## Technical Details
- **Category**: ${error.category}
- **Error**: ${error.getDetailedMessage()}
${error.cause ? `- **Cause**: ${error.cause.message}` : ""}
` : ""}
  `.trim();
  return (
    <Detail
      markdown={markdown}
      navigationTitle={title}
      metadata={
        error
          ? <Detail.Metadata>
              <Detail.Metadata.TagList title="Status">
                <Detail.Metadata.TagList.Item
                  text={error.category}
                  color={errorColor}
                  icon={errorIcon}
                />
              </Detail.Metadata.TagList>
              <Detail.Metadata.Separator />
              <Detail.Metadata.Label
                title="Error Message"
                text={error.getUserMessage()}
                icon={Icon.ExclamationMark}
              />
              <Detail.Metadata.Label
                title="Details"
                text={error.getDetailedMessage()}
              />
              {error.cause && (
                <Detail.Metadata.Label
                  title="Root Cause"
                  text={error.cause.message}
                  icon={Icon.Bug}
                />
              )}
              <Detail.Metadata.Separator />
              <Detail.Metadata.TagList title="Available Actions">
                {onRetry && (
                  <Detail.Metadata.TagList.Item text="Retry" color={Color.Blue} />
                )}
                {onReconnect && (
                  <Detail.Metadata.TagList.Item text="Reconnect" color={Color.Green} />
                )}
                {onClearCache && (
                  <Detail.Metadata.TagList.Item text="Clear Cache" color={Color.Yellow} />
                )}
                {onResetConfig && (
                  <Detail.Metadata.TagList.Item text="Reset Config" color={Color.Red} />
                )}
              </Detail.Metadata.TagList>
            </Detail.Metadata>
          : undefined
      }
      actions={defaultActions}
    />
  );
}
export const FeedbackState = memo(FeedbackStateImpl);
</file>

<file path="src/ui/toast-manager.ts">
import { showToast, Toast } from "@raycast/api";
export class ToastManager {
  static success(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Success,
      title,
      message,
    });
  }
  static error(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Failure,
      title,
      message,
    });
  }
  static warning(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Failure, // Raycast doesn't have a warning style
      title,
      message,
    });
  }
  static loading(title: string, message?: string): void {
    showToast({
      style: Toast.Style.Animated,
      title,
      message,
    });
  }
}
</file>

<file path="src/utils/state.ts">
/**
 * State conversion utilities
 * @module
 */
import type { Draft } from "immer";
import type { HarmonyDevice, HarmonyActivity } from "../types/core/harmony";
/**
 * Convert a readonly device to a mutable one for Immer
 */
export function toMutableDevice(device: HarmonyDevice): Draft<HarmonyDevice> {
  return device as Draft<HarmonyDevice>;
}
/**
 * Convert a readonly activity to a mutable one for Immer
 */
export function toMutableActivity(activity: HarmonyActivity): Draft<HarmonyActivity> {
  return activity as Draft<HarmonyActivity>;
}
/**
 * Convert a readonly array to a mutable one for Immer
 */
export function toMutableArray<T>(array: readonly T[]): Draft<T>[] {
  return array as Draft<T>[];
}
</file>

<file path="src/utils/validation.ts">
import { HarmonyError, ErrorCategory, RetryConfig, TimeoutConfig, ErrorSeverity } from "../types/core/errors";
import { HarmonyHub, HarmonyDevice, HarmonyActivity, CommandRequest, HarmonyCommand } from "../types/harmony";
import { Logger } from "../services/logger";
/**
 * Type guard for checking if a value is a non-empty string
 */
export function isNonEmptyString(value: unknown): value is string {
  return typeof value === "string" && value.trim().length > 0;
}
/**
 * Type guard for checking if a value is a positive number
 */
export function isPositiveNumber(value: unknown): value is number {
  return typeof value === "number" && !isNaN(value) && value > 0;
}
/**
 * Type guard for checking if a value is a valid port number
 */
export function isValidPort(value: unknown): value is number {
  return isPositiveNumber(value) && value <= 65535;
}
/**
 * Type guard for checking if a value is a valid IP address
 */
export function isValidIpAddress(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipv4Regex.test(value)) return false;
  return value.split(".").every(num => {
    const n = parseInt(num, 10);
    return n >= 0 && n <= 255;
  });
}
/**
 * Type guard for checking if a value is a valid command group
 */
export function isValidCommandGroup(value: unknown): value is string {
  if (!isNonEmptyString(value)) return false;
  const validGroups = ["IRCommand", "HTTPCommand", "BluetoothCommand", "WifiCommand"];
  return validGroups.includes(value);
}
/**
 * Validate Harmony Hub configuration
 */
export function validateHubConfig(hub: Partial<HarmonyHub>): asserts hub is HarmonyHub {
  if (!isNonEmptyString(hub.id)) {
    throw new HarmonyError(
      "Hub ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_ID"
    );
  }
  if (!isNonEmptyString(hub.name)) {
    throw new HarmonyError(
      "Hub name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_NAME"
    );
  }
  if (!isValidIpAddress(hub.ip)) {
    throw new HarmonyError(
      "Invalid hub IP address",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_IP"
    );
  }
  if (hub.port !== undefined && !isValidPort(hub.port)) {
    throw new HarmonyError(
      "Invalid hub port",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_HUB_PORT"
    );
  }
  Logger.debug("Hub config validation passed", { hub });
}
/**
 * Validate Harmony device configuration
 */
export function validateDevice(device: Partial<HarmonyDevice>): asserts device is HarmonyDevice {
  if (!isNonEmptyString(device.id)) {
    throw new HarmonyError(
      "Device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_ID"
    );
  }
  if (!isNonEmptyString(device.name)) {
    throw new HarmonyError(
      "Device name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_NAME"
    );
  }
  if (!isNonEmptyString(device.type)) {
    throw new HarmonyError(
      "Device type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_DEVICE_TYPE"
    );
  }
  if (!Array.isArray(device.commands)) {
    throw new HarmonyError(
      "Device commands must be an array",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMANDS_ARRAY"
    );
  }
  device.commands.forEach((command, index) => {
    if (!isNonEmptyString(command.id)) {
      throw new HarmonyError(
        `Invalid command ID at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_ID"
      );
    }
    if (!isNonEmptyString(command.name)) {
      throw new HarmonyError(
        `Invalid command name at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_NAME"
      );
    }
    if (!isNonEmptyString(command.deviceId)) {
      throw new HarmonyError(
        `Invalid device ID for command at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_DEVICE_ID"
      );
    }
    if (command.group && !isValidCommandGroup(command.group)) {
      throw new HarmonyError(
        `Invalid command group at index ${index}`,
        ErrorCategory.VALIDATION,
        undefined,
        undefined,
        false,
        "INVALID_COMMAND_GROUP"
      );
    }
  });
  Logger.debug("Device validation passed", { device });
}
/**
 * Validate Harmony activity configuration
 */
export function validateActivity(activity: Partial<HarmonyActivity>): asserts activity is HarmonyActivity {
  if (!isNonEmptyString(activity.id)) {
    throw new HarmonyError(
      "Activity ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_ID"
    );
  }
  if (!isNonEmptyString(activity.name)) {
    throw new HarmonyError(
      "Activity name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_NAME"
    );
  }
  if (!isNonEmptyString(activity.type)) {
    throw new HarmonyError(
      "Activity type is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_TYPE"
    );
  }
  if (typeof activity.isCurrent !== "boolean") {
    throw new HarmonyError(
      "Activity current status must be a boolean",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_ACTIVITY_STATUS"
    );
  }
  Logger.debug("Activity validation passed", { activity });
}
/**
 * Validate command request
 */
export function validateCommandRequest(request: Partial<CommandRequest>): asserts request is CommandRequest {
  if (!request) {
    throw new HarmonyError(
      "Command request is required",
      ErrorCategory.VALIDATION
    );
  }
  if (!request.command || !isNonEmptyString(request.command.deviceId)) {
    throw new HarmonyError(
      "Command request must include deviceId",
      ErrorCategory.VALIDATION
    );
  }
  if (!isNonEmptyString(request.command.name)) {
    throw new HarmonyError(
      "Command request must include command name",
      ErrorCategory.VALIDATION
    );
  }
}
/**
 * Validate retry configuration
 */
export function validateRetryConfig(config: Partial<RetryConfig>): asserts config is RetryConfig {
  if (!isPositiveNumber(config.maxAttempts)) {
    throw new HarmonyError(
      "Maximum retry attempts must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_MAX_ATTEMPTS"
    );
  }
  if (!isPositiveNumber(config.baseDelay)) {
    throw new HarmonyError(
      "Base retry delay must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_BASE_DELAY"
    );
  }
  if (!isPositiveNumber(config.maxDelay)) {
    throw new HarmonyError(
      "Maximum retry delay must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_MAX_DELAY"
    );
  }
  if (typeof config.useExponentialBackoff !== "boolean") {
    throw new HarmonyError(
      "Use exponential backoff must be a boolean",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_BACKOFF"
    );
  }
  if (config.maxRetryDuration !== undefined && !isPositiveNumber(config.maxRetryDuration)) {
    throw new HarmonyError(
      "Maximum retry duration must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_RETRY_DURATION"
    );
  }
  Logger.debug("Retry config validation passed", { config });
}
/**
 * Validate timeout configuration
 */
export function validateTimeoutConfig(config: Partial<TimeoutConfig>): asserts config is TimeoutConfig {
  if (!isPositiveNumber(config.connection)) {
    throw new HarmonyError(
      "Connection timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_CONNECTION"
    );
  }
  if (!isPositiveNumber(config.message)) {
    throw new HarmonyError(
      "Message timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_MESSAGE"
    );
  }
  if (!isPositiveNumber(config.activity)) {
    throw new HarmonyError(
      "Activity timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_ACTIVITY"
    );
  }
  if (!isPositiveNumber(config.command)) {
    throw new HarmonyError(
      "Command timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_COMMAND"
    );
  }
  if (!isPositiveNumber(config.discovery)) {
    throw new HarmonyError(
      "Discovery timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_DISCOVERY"
    );
  }
  if (!isPositiveNumber(config.cache)) {
    throw new HarmonyError(
      "Cache timeout must be a positive number",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_TIMEOUT_CACHE"
    );
  }
  Logger.debug("Timeout config validation passed", { config });
}
/**
 * Validate Harmony command
 */
export function validateCommand(command: Partial<HarmonyCommand>): asserts command is HarmonyCommand {
  if (!isNonEmptyString(command.id)) {
    throw new HarmonyError(
      "Command ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_ID"
    );
  }
  if (!isNonEmptyString(command.name)) {
    throw new HarmonyError(
      "Command name is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_NAME"
    );
  }
  if (!isNonEmptyString(command.deviceId)) {
    throw new HarmonyError(
      "Device ID is required",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_DEVICE_ID"
    );
  }
  if (command.group && !isValidCommandGroup(command.group)) {
    throw new HarmonyError(
      "Invalid command group",
      ErrorCategory.VALIDATION,
      undefined,
      undefined,
      false,
      "INVALID_COMMAND_GROUP"
    );
  }
  Logger.debug("Command validation passed", { command });
}
</file>

<file path="src/control.tsx">
import React from "react";
import { HarmonyCommand } from "./ui/components/views/HarmonyCommand";
import { HarmonyProvider } from "./hooks/useHarmony";
export default function Command(): React.ReactElement {
  return (
    <HarmonyProvider>
      <HarmonyCommand />
    </HarmonyProvider>
  );
}
</file>

<file path=".eslintrc.json">
{
  "extends": ["@raycast/eslint-config"],
  "plugins": ["import"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "import/order": [
      "error",
      {
        "groups": ["builtin", "external", "internal", "parent", "sibling", "index"],
        "newlines-between": "always",
        "alphabetize": {
          "order": "asc",
          "caseInsensitive": true
        }
      }
    ],
    "@typescript-eslint/explicit-function-return-type": [
      "error",
      {
        "allowExpressions": true,
        "allowTypedFunctionExpressions": true
      }
    ]
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# Raycast specific files
raycast-env.d.ts
.raycast-swift-build
.swiftpm
compiled_raycast_swift

# Windsurf files
.windsurfrules
global_rules.md

# misc
.DS_Store

# Project planning
.Plan
</file>

<file path=".prettierrc">
{
  "printWidth": 120,
  "singleQuote": false
}
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to the Harmony Control extension will be documented in this file.

## [1.0.0] - 2025-02-07

### Added
- Initial release of Harmony Control extension
- Automatic hub discovery on local network
- Device control with command execution
- Activity management (start/stop)
- Local caching of hub configuration
- Secure credential storage
- Error handling and recovery
- Configurable preferences:
  - Default view (Activities/Devices)
  - Command hold time
  - Cache duration
  - Network timeout
  - Debug mode
  - Auto retry settings

### Technical Improvements
- TypeScript strict mode compliance
- Proper error categorization and handling
- WebSocket connection management
- Performance optimizations with caching
- Secure storage implementation

### Documentation
- Comprehensive README with setup guide
- API documentation
- Troubleshooting guide
- Screenshots of key features
</file>

<file path="package.json">
{
  "$schema": "https://www.raycast.com/schemas/extension.json",
  "name": "harmony-control",
  "version": "1.0.0",
  "title": "Harmony Control",
  "description": "Control your Logitech Harmony Hub devices",
  "icon": "command-icon.png",
  "author": "chad_walters",
  "categories": [
    "Media",
    "System"
  ],
  "license": "MIT",
  "commands": [
    {
      "name": "control",
      "title": "Control Harmony Hub",
      "description": "Control your Harmony Hub devices and activities",
      "mode": "view"
    }
  ],
  "preferences": [
    {
      "name": "defaultView",
      "type": "dropdown",
      "required": false,
      "title": "Default View",
      "description": "Choose whether to show Activities or Devices by default",
      "default": "devices",
      "data": [
        {
          "title": "Activities",
          "value": "activities"
        },
        {
          "title": "Devices",
          "value": "devices"
        }
      ]
    },
    {
      "name": "commandHoldTime",
      "type": "textfield",
      "required": false,
      "title": "Command Hold Time",
      "description": "Duration to hold a command in milliseconds",
      "default": "100"
    },
    {
      "name": "debugMode",
      "type": "checkbox",
      "required": false,
      "title": "Debug Mode",
      "description": "Enable detailed logging for troubleshooting",
      "default": false,
      "label": "Enable Debug Mode"
    },
    {
      "name": "autoRetry",
      "type": "checkbox",
      "required": false,
      "title": "Auto Retry",
      "description": "Automatically retry failed operations",
      "default": true,
      "label": "Enable Auto Retry"
    },
    {
      "name": "maxRetries",
      "type": "textfield",
      "required": false,
      "title": "Max Retries",
      "description": "Maximum number of retry attempts",
      "default": "3"
    }
  ],
  "dependencies": {
    "@harmonyhub/client-ws": "^1.0.9",
    "@harmonyhub/discover": "^1.0.9",
    "@raycast/api": "^1.91.1",
    "@raycast/utils": "^1.10.1",
    "immer": "^10.1.1",
    "node-machine-id": "^1.1.12",
    "uuid": "^9.0.1",
    "ws": "^8.16.0",
    "xstate": "^5.19.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@raycast/eslint-config": "^1.0.6",
    "@types/node": "^20.8.10",
    "@types/react": "^18.2.27",
    "@types/uuid": "^9.0.7",
    "@types/ws": "^8.5.14",
    "eslint": "^8.51.0",
    "prettier": "^3.0.3",
    "typescript": "^5.2.2"
  },
  "scripts": {
    "build": "ray build -e dist",
    "dev": "ray develop",
    "fix-lint": "ray lint --fix",
    "lint": "ray lint",
    "publish": "npx @raycast/api@latest publish"
  }
}
</file>

<file path="Plan.md">
# Harmony Raycast Extension Refactoring Plan

## Overview
Based on the senior developer code review, we need to improve several areas of the codebase to align with Raycast extension best practices and enhance maintainability. This document outlines specific issues, solutions, and implementation strategy.

## Current Issues and Solutions

### Component Structure
**Issues:**
- `HarmonyCommand.tsx` is handling too much responsibility
- View logic is mixed with state management
- Duplicate error handling patterns

**Solutions:**
1. Break down `HarmonyCommand.tsx` into focused view components
2. Use simple view state management
3. Create reusable shared components

### State Management
**Issues:**
- Complex state updates in useHarmony
- Scattered preference management
- Redundant state derivations

**Solutions:**
1. Implement Zustand store for centralized state
2. Move async operations to store actions
3. Use selectors for derived state

### Error Handling
**Issues:**
- Inconsistent error handling
- Duplicate try/catch blocks
- Basic error messages

**Solutions:**
1. Implement simple, centralized error handling
2. Use Raycast's toast system effectively
3. Add proper error recovery flows

### Performance
**Issues:**
- Unnecessary re-renders
- Inefficient data fetching
- Memory leaks

**Solutions:**
1. Implement proper cleanup in useEffect
2. Use memoization for expensive computations
3. Proper component unmounting

## Implementation Strategy

### Phase 1: Core Foundation (1-2 days)
Dependencies: None
- [x] 1.1 Type Definition Consolidation ✅
  - Created organized type hierarchy in `src/types/core/`
  - Added comprehensive JSDoc documentation
  - Implemented type guards and validation utilities
  - Added immutable types with `readonly`
  - Created error handling types and utilities
  - Added WebSocket and state management types
  - Consolidated all types in central index
- [x] 1.2 Error and Logging Setup ✅
  - Implemented ErrorHandler with categorized error handling
  - Created ToastManager for consistent user notifications
  - Added Logger with multiple log levels and history
  - Integrated error handling with logging and toasts
  - Added error recovery actions and user-friendly messages
  - Implemented development mode console logging
- [x] 1.3 Zustand Store Setup ✅
  - Defined store structure with proper typing
  - Created mutable state types for Immer integration
  - Implemented comprehensive actions for hub, device, and activity management
  - Added error handling and loading state management
  - Created selectors for derived state
  - Integrated with error handling and toast notifications

### Phase 2: View Components (2-3 days)
Dependencies: Phase 1
- [x] 2.1 Shared Components ✅
  - Implemented FeedbackState for loading, error, and empty states
  - Created BaseActionPanel with common management actions
  - Added DeviceActionPanel for device-specific commands
  - Added ActivityActionPanel for activity controls
  - All components use Raycast UI patterns and keyboard shortcuts
  - Proper TypeScript typing and error handling
- [x] 2.2 HubsView Implementation ✅
  - Created HubsView component with hub discovery and selection
  - Integrated FeedbackState for loading, error, and empty states
  - Added search functionality for hubs
  - Implemented hub selection with visual feedback
  - Used BaseActionPanel for common actions
  - Added proper TypeScript typing and error handling
- [x] 2.3 DevicesView Implementation ✅
  - Created DevicesView with device listing and command execution
  - Implemented device grouping by type
  - Added search functionality for devices and commands
  - Integrated with DeviceActionPanel for command execution
  - Added detailed device view with command list
  - Implemented memoization for performance
  - Used FeedbackState for loading, error, and empty states
  - Added proper TypeScript typing and error handling
- [x] 2.4 ActivitiesView Implementation ✅
  - Created ActivitiesView with activity management
  - Implemented activity grouping by type
  - Added real-time status updates and visual feedback
  - Integrated with ActivityActionPanel for start/stop control
  - Added detailed activity view with status information
  - Implemented loading states for activity transitions
  - Added search functionality for activities
  - Used FeedbackState for loading, error, and empty states
  - Added proper TypeScript typing and error handling

### Phase 3: State and Navigation (1 day)
Dependencies: Phase 1, Phase 2
- [x] 3.1 View State Management ✅
  - Simple view state in HarmonyCommand
  - View transitions
  - Keyboard shortcuts
- [x] 3.2 Custom Hooks ✅
  - Implemented useCommandExecution with retry logic and error handling
  - Created useDeviceFiltering with memoized device filtering and grouping
  - Added useActivityFiltering with memoized activity filtering and status tracking
  - Built usePreferences with validation and error handling
- [x] 3.3 Store Integration ✅
  - Connected views to store using Zustand
  - Implemented proper cleanup in store actions
  - Added state persistence with versioning
  - Created persistence middleware for Zustand stores
  - Implemented local storage integration
  - Added error handling and logging for persistence
  - Implemented state hydration and migration support

### Phase 4: Performance and Polish (1-2 days)
Dependencies: All previous phases
- [x] 4.1 Performance Optimization ✅
  - Added React.memo for all view components
  - Extracted and memoized list item components
  - Implemented memoized callbacks with useCallback
  - Optimized data filtering with useMemo
  - Added custom comparison functions for memoization
  - Improved prop passing to reduce re-renders
  - Optimized component structure for better performance
  - Added proper cleanup in useEffect hooks
- [x] 4.2 Data Management ✅
  - Implemented LocalStorage for state persistence
  - Added preference handling with validation
  - Created cache management with versioning
  - Added state migration support
  - Implemented error handling for storage operations
- [x] 4.3 Error Experience ✅
  - Enhanced error visualization with color-coded status
  - Added category-specific icons and colors
  - Implemented detailed troubleshooting steps
  - Added progress feedback for async operations
  - Created recovery action suggestions
  - Improved error message formatting
  - Added technical details for debugging
  - Enhanced toast notifications with actions
  - Implemented error recovery flows
  - Added proper error cleanup and state reset

### Phase 5: Codebase Cleanup and Consolidation (1 day)
Dependencies: All previous phases
- [ ] 5.1 File Deletions
  - Delete `src/services/error-handler.ts` (⚠️ Used in harmony.ts store - needs migration to errorHandler.ts first)
    - Create backup of error-handler.ts
    - Update harmony.ts to import from errorHandler.ts
    - Verify error handling still works in harmony store
    - Run full test suite to verify no regressions
    - Delete error-handler.ts after successful verification
  - Delete `src/services/secure-storage.ts` (✅ Safe to delete - no active imports found)
    - Simple deletion - no migration needed
  - Delete `src/stores/middleware/persist.ts` (⚠️ Referenced in store implementations - verify stores have own persistence)
    - Audit harmony.ts store persistence implementation
    - Audit view.ts store persistence implementation
    - Verify both stores handle:
      - State hydration
      - State persistence
      - Error handling
      - Version migrations
    - Run tests to verify persistence still works
    - Delete persist.ts after verification
  - Delete `src/types/state.ts` (✅ Safe to delete - no active imports found)
    - Simple deletion - no migration needed
  - Verify no breaking changes after deletions
  - Update any remaining imports/references
- [ ] 5.2 File Consolidations
  - Merge `src/types/harmony.ts` into `src/types/core/harmony.ts`
    - ✅ RECOMMENDED: Full merge
    - Core types are already well-organized in core/harmony.ts
    - No unique types found in harmony.ts that aren't in core
    - Simple migration of any remaining imports
    - Delete harmony.ts after merge verification
  
  - Review `src/services/commandQueue.ts`
    - ⚠️ PARTIAL MIGRATION RECOMMENDED
    - Valuable features to keep:
      - Command retry logic
      - Queue management
      - Error handling
    - Migration steps:
      1. Extract retry logic into useCommandExecution hook
      2. Move queue management into harmony store if needed
      3. Keep error handling patterns
      4. Delete file after migration
    - Current implementation is not actively used but contains useful patterns

  - Update import statements
    - Create comprehensive import map before starting
    - Update imports in batches by feature area
    - Verify each batch before proceeding
    - Run type checks after each batch

  - Type consistency verification
    - Run full TypeScript compilation
    - Verify no type regressions
    - Check for any 'any' types introduced
    - Ensure all exports are properly typed

- [ ] 5.3 Code Cleanup
  - Remove unused imports
  - Remove unused functions and types
  - Update documentation to reflect changes
  - Verify all exports are properly used
- [ ] 5.4 Testing and Verification
  - Test all main functionality after cleanup
  - Verify no runtime errors from removed files
  - Check all type definitions are properly resolved
  - Ensure no broken references or imports

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking changes in Raycast API | Low | High | Monitor Raycast releases |
| Memory leaks | Medium | High | Proper useEffect cleanup |
| Network failures | Medium | Medium | Robust error handling |
| State corruption | Low | High | Proper validation |
| User settings loss | Low | High | LocalStorage backup |

## User Experience

### During Refactoring
- Maintain backward compatibility
- Clear error messages
- Performance monitoring
- Graceful degradation

### Release Strategy
1. Internal testing
   - Functionality verification
   - Performance checks
2. Limited user testing
   - Feedback collection
   - Issue tracking
3. Full release
   - Staged rollout
   - Monitor for issues

## Raycast Compliance

### Component Usage
- Use Raycast UI components exclusively
  - List
  - Detail
  - ActionPanel
  - Form
- Follow Raycast's design guidelines
  - Typography
  - Spacing
  - Icons
- Implement keyboard shortcuts
  - View switching
  - Common actions
  - Navigation

### Performance Requirements
- Proper useEffect cleanup
  - Event listeners
  - Timers
  - WebSocket connections
- Efficient state management
  - Zustand store
  - Memoized selectors
  - Minimal component state
- Raycast API usage
  - LocalStorage for persistence
  - Toast for user feedback
  - Preference management

## Next Steps

1. Review and approve updated plan
2. Begin Phase 1 implementation
3. Regular progress reviews
4. User communication
</file>

<file path="README.md">
# Harmony Raycast Extension

Control your Logitech Harmony Hub directly from Raycast. This extension allows you to manage your devices, execute commands, and control activities without leaving your keyboard.

## Features

- 🔍 Automatic hub discovery on your network
- 📱 Control all your Harmony-connected devices
- ⚡️ Quick access to device commands
- 🎮 Start and stop activities
- 🔄 Real-time status updates
- ⌨️ Full keyboard navigation

## Installation

1. Make sure you have [Raycast](https://raycast.com/) installed
2. Install the Harmony extension from the Raycast store
3. The extension will automatically discover your Harmony Hub(s) on the network

## Usage

### Hub Connection

The extension will automatically discover Harmony Hubs on your local network. 

**Note**: If only one Harmony Hub is found on your network, the extension will automatically connect to it. This auto-connection behavior is designed to streamline the experience for users with a single hub setup.

### Device Control

1. Select a device from the list
2. Browse available commands
3. Execute commands with a single click or keyboard shortcut

### Activities

1. View all configured activities
2. Start or stop activities
3. See real-time activity status

## Keyboard Shortcuts

- `⌘ + R`: Refresh hub/device list
- `⌘ + [`: Go back to previous view
- `⌘ + Backspace`: Clear cache
- `⌘ + Shift + R`: Reconnect to hub
- `⌘ + Shift + A`: Switch to Activities view
- `⌘ + Shift + D`: Switch to Devices view
- `⌘ + K`: Open command palette for quick actions

## Troubleshooting

If you encounter any issues:

1. Try refreshing the hub connection (⌘ + R)
2. Clear the cache (⌘ + Backspace)
3. Ensure your Harmony Hub is on the same network
4. Check your network firewall settings

## Development

```bash
# Clone the repository
git clone https://github.com/yourusername/harmony-raycast-extension.git

# Install dependencies
npm install

# Run in development mode
npm run dev
```

## Contributing

Contributions are welcome! Please read our [Contributing Guidelines](CONTRIBUTING.md) for details.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

<file path="tsconfig.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Node 16",
  "include": ["src/**/*", "raycast-env.d.ts"],
  "compilerOptions": {
    "lib": ["es2021"],
    "module": "commonjs",
    "target": "es2021",
    "strict": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "noEmit": false,
    "outDir": "dist"
  }
}
</file>

</files>
